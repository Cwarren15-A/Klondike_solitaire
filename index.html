<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Klondike Solitaire - AI Enhanced</title>
    <meta name="description" content="Play Klondike Solitaire with AI-powered hints, analysis, and adaptive difficulty. Advanced machine learning provides intelligent gameplay assistance.">
    
    <!-- Social Media Meta Tags -->
    <meta property="og:title" content="Klondike Solitaire - AI Enhanced">
    <meta property="og:description" content="Advanced Klondike Solitaire with AI-powered hints, complete board analysis, and machine learning assistance.">
    <meta property="og:image" content="https://raw.githubusercontent.com/yourusername/klondike-solitaire-ai/main/preview.png">
    <meta property="og:url" content="https://yourusername.github.io/klondike-solitaire-ai/">
    <meta property="og:type" content="website">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Klondike Solitaire - AI Enhanced">
    <meta name="twitter:description" content="Advanced Klondike Solitaire with AI-powered hints and machine learning assistance.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/yourusername/klondike-solitaire-ai/main/preview.png">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1e5128">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Solitaire AI">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="manifest" href="manifest.json">
    
    <!-- Performance and SEO -->
    <meta name="robots" content="index, follow">
    <meta name="author" content="Your Name">
    <meta name="keywords" content="solitaire, klondike, card game, AI, machine learning, hints, analysis, free game">
    <link rel="canonical" href="https://yourusername.github.io/klondike-solitaire-ai/">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.15.0/tf.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e5128, #2d5016);
            font-family: 'Arial', sans-serif;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: auto;
            touch-action: none;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .dark-theme {
            background: linear-gradient(135deg, #0f1419, #1a1a2e);
        }
        
        .light-theme {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            color: #333;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1000px;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: bold;
            flex-wrap: wrap;
            gap: 10px;
            animation: slideInDown 0.5s ease-out;
        }
        
        @keyframes slideInDown {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideInUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .stats {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 8px;
            min-width: 80px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .stat-label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 14px;
        }
        
        button:focus-visible {
            outline: 2px solid #4ade80;
            outline-offset: 2px;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .btn-blue { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: white; }
        .btn-yellow { background: linear-gradient(135deg, #d97706, #b45309); color: white; }
        .btn-purple { background: linear-gradient(135deg, #7c3aed, #6d28d9); color: white; }
        .btn-green { background: linear-gradient(135deg, #059669, #047857); color: white; }
        .btn-orange { background: linear-gradient(135deg, #ea580c, #c2410c); color: white; }
        .btn-red { background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        #gameCanvas {
            border: 3px solid #4ade80;
            border-radius: 15px;
            background: radial-gradient(ellipse at center, #166534 0%, #14532d 100%);
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            cursor: default;
            display: block;
            animation: slideInUp 0.5s ease-out;
            transition: all 0.3s ease;
        }
        
        #gameCanvas:hover {
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        
        .menu {
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            animation: slideInUp 0.6s ease-out;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .menu h1 {
            font-size: clamp(24px, 5vw, 48px);
            margin-bottom: 30px;
            color: #4ade80;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }
        
        .menu button {
            display: block;
            width: min(250px, 80vw);
            margin: 10px auto;
            padding: 15px;
            font-size: 18px;
            transform: translateY(20px);
            animation: slideInUp 0.6s ease-out forwards;
        }
        
        .menu button:nth-child(2) { animation-delay: 0.1s; }
        .menu button:nth-child(3) { animation-delay: 0.2s; }
        .menu button:nth-child(4) { animation-delay: 0.3s; }
        .menu button:nth-child(5) { animation-delay: 0.4s; }
        .menu button:nth-child(6) { animation-delay: 0.5s; }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
            z-index: 2000;
            animation: notificationPop 2s ease-out;
            max-width: 90vw;
            text-align: center;
        }
        
        @keyframes notificationPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
            50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }
        
        .theme-toggle, .sound-toggle {
            position: fixed;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        .theme-toggle {
            top: 20px;
        }
        
        .sound-toggle {
            top: 80px;
            font-size: 20px;
        }
        
        .theme-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(180deg);
        }
        
        .sound-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s ease;
            z-index: 1001;
        }
        
        .difficulty-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            text-transform: uppercase;
        }
        
        .diff-easy { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .diff-medium { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
        .diff-hard { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .diff-expert { background: linear-gradient(135deg, #7c3aed, #6d28d9); color: white; }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .game-header {
                font-size: 14px;
                gap: 5px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            .controls {
                gap: 5px;
            }
            
            #gameCanvas {
                border-width: 2px;
                border-radius: 10px;
            }
            
            .theme-toggle, .sound-toggle {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .sound-toggle {
                top: 70px;
            }
            
            .menu {
                padding: 20px;
            }
            
            .stat-item {
                min-width: 60px;
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="safeGameCall('ui.toggleTheme')" title="Toggle theme" aria-label="Toggle color theme">üåì</button>
    <button class="sound-toggle" onclick="safeGameCall('ui.toggleSound')" title="Toggle sound" aria-label="Toggle sound effects">üîä</button>
    <div class="progress-bar" id="progressBar"></div>
    
    <div id="menu" class="menu">
        <h1>üÉè Klondike Solitaire</h1>
        <div style="margin-bottom: 20px; font-size: 14px; color: #a78bfa;">
            Enhanced with AI/Machine Learning üß†
        </div>
        <button class="btn-green" onclick="game.ui.showDailyChallenge()">üèÜ Daily Challenge</button>
        <button class="btn-blue" onclick="game.startGame(1)">üéØ Draw 1 Card</button>
        <button class="btn-blue" onclick="game.startGame(3)">üéÆ Draw 3 Cards</button>
        <button class="btn-purple" onclick="game.ui.showSettings()">‚öôÔ∏è Settings</button>
        <button class="btn-yellow" onclick="game.ui.showStats()">üìä Statistics</button>
        <button class="btn-red" onclick="game.ui.showAchievements()">üèÖ Achievements</button>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 12px; opacity: 0.7; line-height: 1.4;">
            <strong>üß† AI Features:</strong><br>
            ‚Ä¢ Neural network-powered move analysis<br>
            ‚Ä¢ Intelligent game state evaluation<br>
            ‚Ä¢ Adaptive difficulty recommendations<br>
            ‚Ä¢ Works on all devices (CPU-optimized)<br>
            ‚Ä¢ Learning from your gameplay patterns
        </div>
    </div>
    
    <div id="gameArea" style="display: none;">
        <div class="game-header">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Moves</div>
                    <div class="stat-value" id="moves">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="time">0:00</div>
                </div>
                <div class="stat-item" id="scoreDisplay" style="display: none;">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn-blue" onclick="safeGameCall('newGame')" title="Start new game (N)" aria-label="Start new game">üé≤ New Game</button>
                <button class="btn-yellow" id="undoBtn" onclick="safeGameCall('undo')" title="Undo last move (U)" aria-label="Undo last move">‚Ü∂ Undo</button>
                <button class="btn-purple" onclick="safeGameCall('ai.showHint')" title="Show AI hint (H)" aria-label="Show AI move hint">üß† AI Hint</button>
                <button class="btn-orange" onclick="safeGameCall('ui.showMLAnalysis')" title="Show ML analysis" aria-label="Show machine learning analysis">üìä AI Analysis</button>
                <button class="btn-green" onclick="safeGameCall('storage.quickSave')" title="Quick save (S)" aria-label="Quick save game">üíæ Save</button>
            </div>
        </div>
        <canvas id="gameCanvas" width="1000" height="600" role="application" aria-label="Klondike Solitaire Game Board" tabindex="0"></canvas>
    </div>
    
    <!-- Additional menu screens -->
    <div id="dailyChallenge" class="menu" style="display: none;">
        <h1>üèÜ Daily Challenge</h1>
        <div id="challengeInfo" style="margin-bottom: 20px; font-size: 16px; line-height: 1.5;"></div>
        <button class="btn-green" id="playDailyBtn" onclick="safeGameCall('startDailyChallenge')">Play Today's Challenge</button>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">‚Üê Back to Menu</button>
    </div>
    
    <div id="settings" class="menu" style="display: none;">
        <h1>‚öôÔ∏è Settings</h1>
        <div style="text-align: left; max-width: 300px; margin: 0 auto;">
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold;" for="difficultySelect">Difficulty Level:</label>
                <select id="difficultySelect" onchange="safeGameCall('settings.updateDifficulty')" style="width: 100%; padding: 8px; border-radius: 6px; border: 2px solid #374151; font-size: 16px; color: #333;">
                    <option value="easy">Easy - Draw 1</option>
                    <option value="medium">Medium - Draw 3</option>
                    <option value="hard">Hard - Draw 3, Vegas Scoring</option>
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="autoMoveToFoundation" onchange="safeGameCall('settings.updateAutoMove')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Auto-move cards to foundation</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="showMoveHints" onchange="safeGameCall('settings.updateShowHints')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Show valid move hints</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="enableMLAnalysis" onchange="safeGameCall('settings.updateMLAnalysis')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Enable AI/ML analysis üß†</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="adaptiveDifficulty" onchange="safeGameCall('settings.updateAdaptiveDifficulty')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Adaptive difficulty (AI-powered)</span>
                </label>
            </div>
        </div>
        
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">‚Üê Back to Menu</button>
        <button class="btn-orange" onclick="safeGameCall('settings.resetSettings')">Reset to Defaults</button>
    </div>
    
    <div id="stats" class="menu" style="display: none;">
        <h1>üìä Statistics</h1>
        <div id="statsContent" style="text-align: left; max-width: 400px; margin: 0 auto; font-size: 16px; line-height: 1.6;"></div>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">‚Üê Back to Menu</button>
        <button class="btn-yellow" onclick="safeGameCall('stats.resetStats')">Reset Statistics</button>
    </div>
    
    <div id="achievements" class="menu" style="display: none;">
        <h1>üèÖ Achievements</h1>
        <div id="achievementsList" style="text-align: left; max-width: 500px; margin: 0 auto; font-size: 16px;"></div>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">‚Üê Back to Menu</button>
    </div>

    <script>
        'use strict';

        // Main game class
        class KlondikeSolitaire {
            constructor() {
                this.initializeComponents();
                this.setupEventListeners();
                this.loadGameData();
                this.ui.applyTheme();
            }
            
            initializeComponents() {
                this.constants = new GameConstants();
                this.storage = new StorageManager();
                this.settings = new SettingsManager(this);
                this.stats = new StatisticsManager(this);
                this.achievements = new AchievementManager(this);
                this.daily = new DailyChallenge(this);
                this.sound = new SoundManager(this);
                this.ui = new UIManager(this);
                this.cards = new CardManager(this);
                this.state = new GameState(this);
                this.rules = new GameRules(this);
                this.ai = new AIHintSystem(this);
                this.input = new InputManager(this);
                this.renderer = new RenderEngine(this);
                this.ml = new MLManager(this); // Initialize ML system
                
                // Initialize new enhanced features
                this.haptics = HapticManager;
                this.particles = null; // Will be initialized when canvas is ready
                
                this.gameWon = false;
                this.timer = null;
                this.currentGameMode = 'normal';
                this.currentDifficulty = 'medium';
            }
            
            setupEventListeners() {
                window.addEventListener('error', (e) => {
                    console.error('Game error:', e.error);
                });
                
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
            }
            
            loadGameData() {
                try {
                    this.settings.loadSettings();
                    this.stats.loadStatistics();
                    this.achievements.loadAchievements();
                } catch (error) {
                    console.error('Error loading game data:', error);
                }
            }
            
            startGame(drawMode) {
                try {
                    this.currentGameMode = 'normal';
                    this.state.drawMode = drawMode;
                    this.currentDifficulty = this.settings.data.difficulty;
                    
                    this.ui.hideAllMenus();
                    this.ui.showElement('gameArea');
                    this.input.initCanvas();
                    this.state.initializeGame();
                } catch (error) {
                    console.error('Error starting game:', error);
                }
            }
            
            startDailyChallenge() {
                try {
                    this.currentGameMode = 'daily';
                    const difficulty = this.daily.getDailyDifficulty();
                    const diffSettings = this.daily.getDifficultySettings(difficulty);
                    
                    this.state.drawMode = diffSettings.drawMode;
                    this.settings.data.scoringMode = diffSettings.scoringMode;
                    this.currentDifficulty = difficulty;
                    
                    this.ui.hideElement('dailyChallenge');
                    this.ui.showElement('gameArea');
                    this.input.initCanvas();
                    this.state.initializeGame();
                } catch (error) {
                    console.error('Error starting daily challenge:', error);
                }
            }
            
            newGame() {
                try {
                    if (confirm('Start a new game? Current progress will be lost.')) {
                        this.state.resetAllGameState();
                        this.state.initializeGame();
                    }
                } catch (error) {
                    console.error('Error starting new game:', error);
                }
            }
            
            undo() {
                try {
                    this.state.undo();
                } catch (error) {
                    console.error('Error undoing move:', error);
                }
            }
            
            cleanup() {
                try {
                    this.input.cleanup();
                    if (this.timer) clearInterval(this.timer);
                    if (this.ml && !this.ml.isDisposed) {
                        this.ml.dispose();
                    }
                } catch (error) {
                    console.error('Cleanup error:', error);
                }
            }
        }

        // Game constants
        class GameConstants {
            constructor() {
                this.SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                this.RED_SUITS = new Set(['‚ô•', '‚ô¶']);
                this.RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
                this.CARD_WIDTH = 80;
                this.CARD_HEIGHT = 120;
                this.FACE_DOWN_OFFSET = 8;
                this.FACE_UP_OFFSET = 20;
                this.WASTE_CARD_OFFSET = 25;
                this.MAX_HISTORY_SIZE = 50;
            }
        }

        // Storage manager
        class StorageManager {
            constructor() {
                this.available = this.checkStorageAvailability();
            }
            
            checkStorageAvailability() {
                try {
                    const test = '__storage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    return false;
                }
            }
            
            set(key, value) {
                if (!this.available) return false;
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (e) {
                    console.warn('Storage quota exceeded:', e);
                    return false;
                }
            }
            
            get(key) {
                if (!this.available) return null;
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : null;
                } catch (e) {
                    console.warn('Storage parse error:', e);
                    return null;
                }
            }
            
            quickSave() {
                try {
                    game.state.saveToLocalStorage();
                    game.sound.play('cardPlace');
                    game.ui.showNotification('üíæ Game Saved!', 'success');
                } catch (error) {
                    console.error('Quick save error:', error);
                }
            }
        }

        // Settings manager
        class SettingsManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.data = this.getDefaultSettings();
            }
            
            getDefaultSettings() {
                return {
                    difficulty: 'medium',
                    autoMoveToFoundation: true,
                    showMoveHints: true,
                    enableMLAnalysis: true,
                    adaptiveDifficulty: false,
                    drawMode: 3,
                    scoringMode: 'standard',
                    theme: 'green',
                    soundEnabled: true
                };
            }
            
            loadSettings() {
                try {
                    const saved = this.game.storage.get('klondike_settings');
                    if (saved) {
                        this.data = { ...this.data, ...saved };
                    }
                    this.applySettings();
                } catch (error) {
                    console.error('Error loading settings:', error);
                    this.applySettings();
                }
            }
            
            saveSettings() {
                try {
                    this.game.storage.set('klondike_settings', this.data);
                } catch (error) {
                    console.error('Error saving settings:', error);
                }
            }
            
            applySettings() {
                if (this.game.currentGameMode === 'normal') {
                    const diffSettings = this.game.daily.getDifficultySettings(this.data.difficulty);
                    this.data.drawMode = diffSettings.drawMode;
                    this.data.scoringMode = diffSettings.scoringMode;
                }
            }
            
            updateDifficulty() {
                const select = document.getElementById('difficultySelect');
                this.data.difficulty = select.value;
                this.applySettings();
                this.saveSettings();
            }
            
            updateAutoMove() {
                const checkbox = document.getElementById('autoMoveToFoundation');
                this.data.autoMoveToFoundation = checkbox.checked;
                this.saveSettings();
            }
            
            updateShowHints() {
                const checkbox = document.getElementById('showMoveHints');
                this.data.showMoveHints = checkbox.checked;
                this.saveSettings();
            }
            
            updateMLAnalysis() {
                const checkbox = document.getElementById('enableMLAnalysis');
                this.data.enableMLAnalysis = checkbox.checked;
                this.saveSettings();
                
                if (this.data.enableMLAnalysis) {
                    this.game.ui.showNotification('üß† AI analysis enabled! Enhanced hints and game analysis now available.', 'info', 3000);
                } else {
                    this.game.ui.showNotification('üß† AI analysis disabled. Using basic heuristics only.', 'info', 2000);
                }
            }
            
            updateAdaptiveDifficulty() {
                const checkbox = document.getElementById('adaptiveDifficulty');
                this.data.adaptiveDifficulty = checkbox.checked;
                this.saveSettings();
                
                if (this.data.adaptiveDifficulty) {
                    this.game.ui.showNotification('üéØ Adaptive difficulty enabled! AI will suggest optimal challenge level.', 'info', 3000);
                } else {
                    this.game.ui.showNotification('üéØ Adaptive difficulty disabled.', 'info', 2000);
                }
            }
            
            resetSettings() {
                if (confirm('Reset all settings to defaults?')) {
                    this.data = this.getDefaultSettings();
                    this.applySettings();
                    this.game.ui.updateSettingsUI();
                    this.saveSettings();
                }
            }
        }

        // Statistics manager
        class StatisticsManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.data = this.getDefaultStats();
            }
            
            getDefaultStats() {
                return {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    totalTime: 0,
                    totalMoves: 0,
                    bestTime: null,
                    bestScore: 0,
                    currentStreak: 0,
                    longestStreak: 0,
                    dailyChallenges: {}
                };
            }
            
            loadStatistics() {
                try {
                    const saved = this.game.storage.get('klondike_statistics');
                    if (saved) {
                        this.data = { ...this.data, ...saved };
                    }
                } catch (error) {
                    console.error('Error loading statistics:', error);
                }
            }
            
            saveStatistics() {
                try {
                    this.game.storage.set('klondike_statistics', this.data);
                } catch (error) {
                    console.error('Error saving statistics:', error);
                }
            }
            
            updateGameStatistics(won) {
                try {
                    if (won) {
                        this.data.gamesWon++;
                        this.data.totalTime += this.game.state.gameStats.time;
                        this.data.totalMoves += this.game.state.gameStats.moves;
                        this.data.currentStreak++;
                        this.data.longestStreak = Math.max(this.data.longestStreak, this.data.currentStreak);
                        
                        if (!this.data.bestTime || this.game.state.gameStats.time < this.data.bestTime) {
                            this.data.bestTime = this.game.state.gameStats.time;
                        }
                        if (this.game.state.gameStats.score > this.data.bestScore) {
                            this.data.bestScore = this.game.state.gameStats.score;
                        }
                    } else {
                        this.data.currentStreak = 0;
                    }
                    
                    if (this.game.currentGameMode === 'daily' && won) {
                        const today = new Date().toISOString().split('T')[0];
                        this.data.dailyChallenges[today] = {
                            completed: true,
                            score: this.game.state.gameStats.score,
                            time: this.game.state.gameStats.time,
                            moves: this.game.state.gameStats.moves
                        };
                    }
                    
                    this.saveStatistics();
                    
                    if (won) {
                        setTimeout(() => {
                            this.game.achievements.checkAchievements();
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error updating statistics:', error);
                }
            }
            
            resetStats() {
                if (confirm('Reset all statistics? This cannot be undone.')) {
                    this.data = this.getDefaultStats();
                    this.saveStatistics();
                    this.game.ui.updateStatsUI();
                }
            }
        }

        // Achievement manager
        class AchievementManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.achievements = {
                    firstWin: { name: "First Victory", description: "Win your first game", unlocked: false, icon: "üéâ" },
                    speedDemon: { name: "Speed Demon", description: "Win a game in under 3 minutes", unlocked: false, icon: "‚ö°" },
                    perfectGame: { name: "Perfect Game", description: "Win without using undo", unlocked: false, icon: "üíé" },
                    streakMaster: { name: "Streak Master", description: "Win 5 games in a row", unlocked: false, icon: "üî•" },
                    cardShark: { name: "Card Shark", description: "Win 100 games", unlocked: false, icon: "ü¶à" }
                };
            }
            
            loadAchievements() {
                try {
                    const saved = this.game.storage.get('klondike_achievements');
                    if (saved) {
                        Object.keys(this.achievements).forEach(key => {
                            if (saved[key]) {
                                this.achievements[key] = { ...this.achievements[key], ...saved[key] };
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading achievements:', error);
                }
            }
            
            saveAchievements() {
                try {
                    this.game.storage.set('klondike_achievements', this.achievements);
                } catch (error) {
                    console.error('Error saving achievements:', error);
                }
            }
            
            checkAchievements() {
                try {
                    const stats = this.game.stats.data;
                    
                    if (!this.achievements.firstWin.unlocked && stats.gamesWon >= 1) {
                        this.unlockAchievement('firstWin');
                    }
                    
                    if (!this.achievements.speedDemon.unlocked && 
                        this.game.state.gameStats.time <= 180 && this.game.gameWon) {
                        this.unlockAchievement('speedDemon');
                    }
                    
                    if (!this.achievements.perfectGame.unlocked && 
                        this.game.gameWon && this.game.state.gameHistory.length === 0) {
                        this.unlockAchievement('perfectGame');
                    }
                    
                    if (!this.achievements.streakMaster.unlocked && stats.currentStreak >= 5) {
                        this.unlockAchievement('streakMaster');
                    }
                    
                    if (!this.achievements.cardShark.unlocked && stats.gamesWon >= 100) {
                        this.unlockAchievement('cardShark');
                    }
                } catch (error) {
                    console.error('Error checking achievements:', error);
                }
            }
            
            unlockAchievement(achievementId) {
                try {
                    this.achievements[achievementId].unlocked = true;
                    this.game.ui.showAchievementNotification(achievementId);
                    this.game.sound.play('achievement');
                    this.saveAchievements();
                } catch (error) {
                    console.error('Error unlocking achievement:', error);
                }
            }
        }

        // Daily challenge system
        class DailyChallenge {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.difficulties = ['easy', 'medium', 'hard'];
            }
            
            getDailyDifficulty() {
                const dayOfWeek = new Date().getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) return 'easy';
                if (dayOfWeek <= 2) return 'medium';
                return 'hard';
            }
            
            getDifficultySettings(difficulty) {
                const settings = {
                    easy: { drawMode: 1, scoringMode: 'standard' },
                    medium: { drawMode: 3, scoringMode: 'standard' },
                    hard: { drawMode: 3, scoringMode: 'vegas' }
                };
                return settings[difficulty] || settings.medium;
            }
        }

        // Sound manager
        class SoundManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.audioContext = null;
                this.sounds = {
                    cardFlip: () => this.playTone(400, 100),
                    cardPlace: () => this.playTone(600, 150),
                    victory: () => this.playVictorySound(),
                    achievement: () => this.playAchievementSound(),
                    error: () => this.playTone(200, 200)
                };
                this.initAudioContext();
            }
            
            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }
            
            play(soundName) {
                if (!this.game.settings.data.soundEnabled || !this.sounds[soundName]) return;
                try {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    this.sounds[soundName]();
                } catch (error) {
                    console.warn('Sound playback error:', error);
                }
            }
            
            playTone(frequency, duration) {
                if (!this.audioContext) return;
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (error) {
                    console.warn('Tone generation error:', error);
                }
            }
            
            playVictorySound() {
                const notes = [523, 659, 784, 1047];
                notes.forEach((note, index) => {
                    setTimeout(() => this.playTone(note, 200), index * 150);
                });
            }
            
            playAchievementSound() {
                const notes = [784, 1047, 1319];
                notes.forEach((note, index) => {
                    setTimeout(() => this.playTone(note, 300), index * 100);
                });
            }
        }

        // UI manager
        class UIManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.currentTheme = 'green';
            }
            
            showElement(id) {
                const element = document.getElementById(id);
                if (element) element.style.display = 'block';
            }
            
            hideElement(id) {
                const element = document.getElementById(id);
                if (element) element.style.display = 'none';
            }
            
            hideAllMenus() {
                ['menu', 'achievements', 'dailyChallenge', 'settings', 'stats'].forEach(id => {
                    this.hideElement(id);
                });
            }
            
            showNotification(message, type = 'info', duration = 2000) {
                try {
                    const notification = document.createElement('div');
                    
                    if (type === 'error') {
                        notification.className = 'error-message';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            left: 50%;
                            transform: translateX(-50%) scale(1);
                            background: linear-gradient(135deg, #ef4444, #dc2626);
                            color: white;
                            padding: 15px 25px;
                            border-radius: 10px;
                            font-weight: bold;
                            z-index: 2000;
                            box-shadow: 0 10px 25px rgba(239,68,68,0.4);
                            max-width: 90vw;
                            text-align: center;
                            animation: shake 0.5s ease-in-out;
                        `;
                    } else if (type === 'hint') {
                        notification.className = 'hint-notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%) scale(1);
                            background: linear-gradient(135deg, #1f2937, #374151);
                            color: white;
                            padding: 20px;
                            border-radius: 15px;
                            font-weight: normal;
                            font-size: 14px;
                            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
                            z-index: 2000;
                            max-width: 90vw;
                            border: 2px solid #4ade80;
                            animation: notificationPop 0.5s ease-out;
                        `;
                    } else {
                        notification.className = 'notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%) scale(1);
                            background: linear-gradient(135deg, #ffd700, #ffed4e);
                            color: #333;
                            padding: 20px 30px;
                            border-radius: 15px;
                            font-weight: bold;
                            font-size: 18px;
                            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
                            z-index: 2000;
                            max-width: 90vw;
                            text-align: center;
                            animation: notificationPop 0.5s ease-out;
                        `;
                    }
                    
                    notification.innerHTML = message;
                    document.body.appendChild(notification);
                    notification.offsetHeight;
                    
                    setTimeout(() => {
                        try {
                            if (notification && notification.parentNode) {
                                notification.style.transform = notification.style.transform.replace('scale(1)', 'scale(0)');
                                setTimeout(() => {
                                    if (notification && notification.parentNode) {
                                        document.body.removeChild(notification);
                                    }
                                }, 300);
                            }
                        } catch (removeError) {
                            console.warn('Error removing notification:', removeError);
                        }
                    }, duration);
                    
                } catch (error) {
                    console.error('Error showing notification:', error);
                    alert(message.replace(/<[^>]*>/g, ''));
                }
            }
            
            showAchievementNotification(achievementId) {
                const achievement = this.game.achievements.achievements[achievementId];
                this.showNotification(`
                    <div style="font-size: 24px; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-size: 18px; font-weight: bold;">Achievement Unlocked!</div>
                    <div style="font-size: 16px;">${achievement.name}</div>
                    <div style="font-size: 14px; opacity: 0.8;">${achievement.description}</div>
                `, 'achievement', 4000);
            }
            
            toggleTheme() {
                const themes = ['green', 'dark', 'light'];
                const currentIndex = themes.indexOf(this.currentTheme);
                this.currentTheme = themes[(currentIndex + 1) % themes.length];
                this.game.settings.data.theme = this.currentTheme;
                this.applyTheme();
                this.game.settings.saveSettings();
                this.game.sound.play('cardFlip');
            }
            
            applyTheme() {
                const body = document.body;
                body.className = '';
                
                switch(this.currentTheme) {
                    case 'dark':
                        body.classList.add('dark-theme');
                        document.querySelector('.theme-toggle').textContent = 'üåô';
                        break;
                    case 'light':
                        body.classList.add('light-theme');
                        document.querySelector('.theme-toggle').textContent = '‚òÄÔ∏è';
                        break;
                    default:
                        document.querySelector('.theme-toggle').textContent = 'üåì';
                        break;
                }
                
                this.currentTheme = this.game.settings.data.theme;
            }
            
            toggleSound() {
                this.game.settings.data.soundEnabled = !this.game.settings.data.soundEnabled;
                const soundBtn = document.querySelector('.sound-toggle');
                soundBtn.textContent = this.game.settings.data.soundEnabled ? 'üîä' : 'üîá';
                this.game.settings.saveSettings();
                if (this.game.settings.data.soundEnabled) this.game.sound.play('cardPlace');
            }
            
            updateProgressBar() {
                const foundationCards = Object.values(this.game.state.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                const progress = (foundationCards / 52) * 100;
                
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                }
            }
            
            updateUI() {
                try {
                    document.getElementById('moves').textContent = this.game.state.gameStats.moves;
                    const minutes = Math.floor(this.game.state.gameStats.time / 60);
                    const seconds = this.game.state.gameStats.time % 60;
                    document.getElementById('time').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    document.getElementById('score').textContent = this.game.state.gameStats.score;
                    document.getElementById('undoBtn').disabled = this.game.state.gameHistory.length === 0;
                    
                    this.updateProgressBar();
                    
                    const scoreDisplay = document.getElementById('scoreDisplay');
                    if (this.game.state.gameStats.score !== 0 || 
                        this.game.settings.data.scoringMode === 'vegas' || 
                        this.game.currentGameMode === 'daily') {
                        scoreDisplay.style.display = 'block';
                    }
                    
                    this.game.state.checkWinCondition();
                } catch (error) {
                    console.error('Error updating UI:', error);
                }
            }
            
            showWinModal() {
                const minutes = Math.floor(this.game.state.gameStats.time / 60);
                const seconds = this.game.state.gameStats.time % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                this.showNotification(`
                    <h2>üéâ Congratulations! üéâ</h2>
                    <p>You won in <strong>${this.game.state.gameStats.moves}</strong> moves and <strong>${timeStr}</strong>!</p>
                    <p>Final Score: <strong>${this.game.state.gameStats.score}</strong> points</p>
                    <button class="btn-green" onclick="if(window.game && game.ui) game.ui.backToMenu(); else location.reload();" style="margin-top: 15px; padding: 10px 20px;">Play Again</button>
                `, 'win', 10000);
                
                this.game.sound.play('victory');
            }
            
            showDailyChallenge() {
                this.hideElement('menu');
                this.showElement('dailyChallenge');
                this.updateDailyChallengeInfo();
            }
            
            showSettings() {
                this.hideElement('menu');
                this.showElement('settings');
                this.updateSettingsUI();
            }
            
            showStats() {
                this.hideElement('menu');
                this.showElement('stats');
                this.updateStatsUI();
            }
            
            showAchievements() {
                this.hideElement('menu');
                this.showElement('achievements');
                this.updateAchievementsUI();
            }
            
            backToMainMenu() {
                this.hideAllMenus();
                this.showElement('menu');
            }
            
            backToMenu() {
                this.hideElement('gameArea');
                
                if (this.game.currentGameMode === 'daily') {
                    this.showElement('dailyChallenge');
                    this.updateDailyChallengeInfo();
                } else {
                    this.showElement('menu');
                }
                
                this.game.cleanup();
                this.game.currentGameMode = 'normal';
                this.game.state.drawMode = null;
                this.game.input.resetDragState();
            }
            
            updateDailyChallengeInfo() {
                const today = new Date().toISOString().split('T')[0];
                const difficulty = this.game.daily.getDailyDifficulty();
                const isCompleted = this.game.stats.data.dailyChallenges[today]?.completed || false;
                
                document.getElementById('challengeInfo').innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 12px;">
                        <strong>Today's Challenge</strong>
                        <span class="difficulty-indicator diff-${difficulty}">${difficulty.toUpperCase()}</span>
                        <br><br>
                        <strong>Status:</strong> 
                        <span style="color: ${isCompleted ? '#10b981' : '#f59e0b'};">
                            ${isCompleted ? '‚úÖ Completed' : 'üéØ Available'}
                        </span>
                        ${isCompleted ? `<br><br><strong>Your Score:</strong> ${this.game.stats.data.dailyChallenges[today]?.score || 0}` : ''}
                    </div>
                `;
            }
            
            updateSettingsUI() {
                document.getElementById('difficultySelect').value = this.game.settings.data.difficulty;
                document.getElementById('autoMoveToFoundation').checked = this.game.settings.data.autoMoveToFoundation;
                document.getElementById('showMoveHints').checked = this.game.settings.data.showMoveHints;
                
                const enableMLCheckbox = document.getElementById('enableMLAnalysis');
                const adaptiveDifficultyCheckbox = document.getElementById('adaptiveDifficulty');
                
                if (enableMLCheckbox) {
                    enableMLCheckbox.checked = this.game.settings.data.enableMLAnalysis;
                }
                if (adaptiveDifficultyCheckbox) {
                    adaptiveDifficultyCheckbox.checked = this.game.settings.data.adaptiveDifficulty;
                }
            }
            
            updateStatsUI() {
                const stats = this.game.stats.data;
                const winRate = stats.gamesPlayed > 0 ? 
                    Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
                const avgTime = stats.gamesWon > 0 ? 
                    Math.round(stats.totalTime / stats.gamesWon) : 0;
                const avgMoves = stats.gamesWon > 0 ? 
                    Math.round(stats.totalMoves / stats.gamesWon) : 0;
                
                document.getElementById('statsContent').innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h3 style="margin-top: 0; color: #4ade80;">Overall Statistics</h3>
                        <strong>Games Won:</strong> ${stats.gamesWon} / ${stats.gamesPlayed} (${winRate}%)<br>
                        <strong>Current Streak:</strong> ${stats.currentStreak}<br>
                        <strong>Longest Streak:</strong> ${stats.longestStreak}<br>
                        <strong>Best Score:</strong> ${stats.bestScore}<br>
                        <strong>Best Time:</strong> ${stats.bestTime ? this.formatTime(stats.bestTime) : 'N/A'}<br>
                        <strong>Average Time:</strong> ${avgTime > 0 ? this.formatTime(avgTime) : 'N/A'}<br>
                        <strong>Average Moves:</strong> ${avgMoves || 'N/A'}
                    </div>
                `;
            }
            
            updateAchievementsUI() {
                const achievementsList = document.getElementById('achievementsList');
                let html = '';
                
                Object.entries(this.game.achievements.achievements).forEach(([id, achievement]) => {
                    const unlocked = achievement.unlocked;
                    html += `
                        <div style="display: flex; align-items: center; margin: 15px 0; padding: 15px; background: rgba(255,255,255,${unlocked ? '0.2' : '0.05'}); border-radius: 10px; ${unlocked ? '' : 'opacity: 0.6;'}">
                            <div style="font-size: 24px; margin-right: 15px;">${unlocked ? achievement.icon : 'üîí'}</div>
                            <div>
                                <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                                <div style="font-size: 14px; opacity: 0.8;">${achievement.description}</div>
                                ${unlocked ? '<div style="color: #4ade80; font-size: 12px; margin-top: 3px;">‚úÖ Unlocked</div>' : ''}
                            </div>
                        </div>
                    `;
                });
                
                achievementsList.innerHTML = html;
            }
            
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
            
            async showMLAnalysis() {
                try {
                    let analysis, moves;
                    let mlAvailable = false;
                    
                    if (this.game.ml && this.game.ml.isInitialized) {
                        try {
                            // Get comprehensive analysis from advanced AI
                            analysis = await this.game.ml.getGameAnalysis(this.game.state);
                            moves = this.game.ai.findAllPossibleMoves();
                            
                            // Evaluate moves with advanced AI
                            const evaluatedMoves = [];
                            for (const move of moves.slice(0, 5)) { // Analyze top 5 moves
                                const evaluation = await this.game.ml.evaluateMove(move, this.game.state);
                                evaluatedMoves.push(evaluation);
                            }
                            
                            moves = evaluatedMoves.sort((a, b) => b.aiScore - a.aiScore);
                            mlAvailable = true;
                        } catch (mlError) {
                            console.warn('Advanced ML analysis failed, using fallback:', mlError);
                        }
                    }
                    
                    if (!analysis) {
                        moves = this.game.ai.findAllPossibleMoves();
                        
                        const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                        const foundationProgress = foundationCards / 52;
                        const faceUpCards = this.game.state.tableau.reduce((sum, pile) => 
                            sum + pile.filter(c => c.faceUp).length, 0);
                        const faceUpRatio = faceUpCards / 28;
                        
                        const winProb = Math.min((foundationProgress * 0.6) + (faceUpRatio * 0.3) + 0.1, 0.95);
                        
                        analysis = {
                            winProbability: winProb,
                            difficulty: winProb > 0.7 ? 'easy' : winProb > 0.5 ? 'medium' : winProb > 0.3 ? 'hard' : 'expert',
                            recommendation: winProb > 0.6 ? 'You\'re doing great! üéØ' : 
                                          winProb > 0.3 ? 'Stay focused and think ahead! ü§î' : 
                                          'This is challenging - consider your moves carefully! üò¨',
                            stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                        };
                    }
                    
                    // Prepare move analysis
                    let moveAnalysis = '';
                    if (moves && moves.length > 0) {
                        const top5 = moves.slice(0, 5);
                        moveAnalysis = top5.map((move, i) => {
                            let scoreDisplay = '';
                            if (move.aiScore !== undefined) {
                                scoreDisplay = `${Math.round(move.aiScore)}pts`;
                            } else {
                                scoreDisplay = `${Math.round((move.priority / 20) * 100)}%`;
                            }
                            
                            let confidence = '';
                            if (move.confidence !== undefined) {
                                confidence = ` (${Math.round(move.confidence * 100)}% confidence)`;
                            }
                            
                            let reasoning = '';
                            if (move.strategicReasoning && move.strategicReasoning.length > 0) {
                                reasoning = `<br><small style="opacity: 0.8;">‚Ä¢ ${move.strategicReasoning[0]}</small>`;
                            }
                            
                            return `${i + 1}. ${move.description} - ${scoreDisplay}${confidence}${reasoning}`;
                        }).join('<br><br>');
                    } else {
                        moveAnalysis = 'No immediate moves available - check stock drawing recommendation';
                    }
                    
                    // Stock drawing analysis
                    let stockAnalysis = '';
                    if (analysis.stockRecommendation) {
                        const stock = analysis.stockRecommendation;
                        stockAnalysis = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üìö Stock Drawing Strategy</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <span style="color: ${stock.shouldDraw ? '#4ade80' : '#f59e0b'}; font-weight: bold;">
                                        ${stock.shouldDraw ? '‚úÖ Recommended: Draw from stock' : '‚è∏Ô∏è Wait: Focus on tableau moves first'}
                                    </span><br>
                                    <strong>Reason:</strong> ${stock.reason}<br>
                                    ${stock.upcomingCards ? `<strong>Next cards:</strong> ${stock.upcomingCards.join(', ')}<br>` : ''}
                                    ${stock.immediateUseCards ? `<strong>Immediately useful:</strong> ${stock.immediateUseCards} card(s)<br>` : ''}
                                    ${stock.valuableCards ? `<strong>High-value cards:</strong> ${stock.valuableCards} card(s)<br>` : ''}
                                    ${stock.drawValue ? `<strong>Draw value score:</strong> ${stock.drawValue}` : ''}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Hidden card insights
                    let hiddenCardAnalysis = '';
                    if (analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0) {
                        const insights = analysis.hiddenCardInsights;
                        hiddenCardAnalysis = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üîç Complete Board Vision (Hidden Cards)</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <strong>Total hidden cards:</strong> ${insights.count}<br>
                                    <strong>Strategic value:</strong> ${insights.totalValue}<br><br>
                                    ${insights.insights.slice(0, 5).map(insight => `‚Ä¢ ${insight}`).join('<br>')}
                                    ${insights.insights.length > 5 ? `<br>‚Ä¢ ...and ${insights.insights.length - 5} more` : ''}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Learning insights
                    let learningProgress = '';
                    if (analysis.learningInsights) {
                        const learning = analysis.learningInsights;
                        learningProgress = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üß† AI Learning Progress</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    ‚Ä¢ Learning database: ${learning.totalLearningData} winning games<br>
                                    ‚Ä¢ Similar winning positions: ${learning.similarWinningGames}<br>
                                    ‚Ä¢ Historically successful moves available: ${learning.historicallySuccessfulMoves}<br>
                                    ‚Ä¢ Confidence boost from learning: +${Math.round(learning.confidenceBoost * 100)}%<br><br>
                                    ${learning.insights.length > 0 ? learning.insights.map(insight => `‚Ä¢ ${insight}`).join('<br>') : '‚Ä¢ Building learning database from your gameplay'}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Strategic insights
                    let strategicInsights = '';
                    if (analysis.strategicInsights && analysis.strategicInsights.length > 0) {
                        strategicInsights = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üéØ Strategic Insights</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    ${analysis.strategicInsights.map(insight => `‚Ä¢ ${insight}`).join('<br>')}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Web AI insights (if available)
                    let webAIInsights = '';
                    if (analysis.webAIInsights) {
                        const webAI = analysis.webAIInsights;
                        webAIInsights = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üåê External AI Consultation</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <strong>Confidence:</strong> ${Math.round(webAI.confidence * 100)}%<br>
                                    <strong>Recommendation:</strong> ${webAI.recommendation}<br>
                                    <strong>Risk Assessment:</strong> ${webAI.riskAssessment}<br><br>
                                    ${webAI.strategicInsights.map(insight => `‚Ä¢ ${insight}`).join('<br>')}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Neural network weights (for advanced users)
                    let neuralWeights = '';
                    if (analysis.neuralWeights && mlAvailable) {
                        const weights = analysis.neuralWeights;
                        neuralWeights = `
                            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; margin-bottom: 15px;">
                                <strong>üßÆ Neural Network Weights</strong><br>
                                <div style="margin-top: 5px; font-size: 11px; line-height: 1.3; opacity: 0.8;">
                                    Foundation: ${weights.foundationValue.toFixed(1)} | Sequence: ${weights.sequenceValue.toFixed(1)} | 
                                    Reveal: ${weights.revealValue.toFixed(1)} | Space: ${weights.emptySpaceValue.toFixed(1)} | 
                                    King: ${weights.kingPlacementValue.toFixed(1)} | Stock: ${weights.stockEfficiency.toFixed(1)}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Determine AI mode display
                    const aiMode = mlAvailable ? 'Advanced Neural Networks + Complete Board Vision + Learning' : 'Enhanced Heuristics';
                    const aiIcon = mlAvailable ? 'üß†' : 'üéØ';
                    const aiStatus = mlAvailable ? 
                        'Full AI system with neural networks, complete board analysis, learning algorithms, and strategic planning' :
                        'Using mathematical analysis and pattern recognition';
                    
                    // Game metrics
                    const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    const blockedCards = this.game.state.tableau.reduce((sum, pile) => 
                        sum + pile.filter(card => !card.faceUp).length, 0);
                    const emptySpaces = this.game.state.tableau.filter(pile => pile.length === 0).length;
                    const moveEfficiency = this.game.state.gameStats.moves > 0 ? 
                        Math.round((foundationCards / this.game.state.gameStats.moves) * 100) : 0;
                    
                    const message = `
                        <div style="text-align: left; line-height: 1.6; font-size: 14px; max-width: 550px;">
                            <div style="font-size: 20px; font-weight: bold; margin-bottom: 20px; text-align: center;">
                                ${aiIcon} Advanced AI Complete Analysis
                            </div>
                            
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üéØ Win Probability</strong><br>
                                <div style="background: #374151; border-radius: 10px; height: 20px; margin: 8px 0; position: relative;">
                                    <div style="background: linear-gradient(90deg, #ef4444, #f59e0b, #4ade80); width: ${Math.round(analysis.winProbability * 100)}%; height: 100%; border-radius: 10px; transition: width 0.5s ease;"></div>
                                    <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: bold; color: white; font-size: 12px;">
                                        ${Math.round(analysis.winProbability * 100)}%
                                    </span>
                                </div>
                            </div>
                            
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üìä Game Metrics</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    ‚Ä¢ Progress: ${foundationCards}/52 cards (${Math.round((foundationCards/52)*100)}%)<br>
                                    ‚Ä¢ Hidden cards: ${blockedCards}<br>
                                    ‚Ä¢ Empty spaces: ${emptySpaces}<br>
                                    ‚Ä¢ Move efficiency: ${moveEfficiency}% (cards per move)<br>
                                    ‚Ä¢ Difficulty: <span class="difficulty-indicator diff-${analysis.difficulty}">${analysis.difficulty.toUpperCase()}</span>
                                </div>
                            </div>
                            
                            ${stockAnalysis}
                            ${hiddenCardAnalysis}
                            
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>üéØ Top AI Move Recommendations</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    ${moveAnalysis}
                                </div>
                            </div>
                            
                            ${learningProgress}
                            ${strategicInsights}
                            ${webAIInsights}
                            ${neuralWeights}
                            
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                                <strong>üí≠ AI Strategic Recommendation</strong><br>
                                <span style="color: #a78bfa; font-style: italic;">${analysis.recommendation}</span>
                            </div>
                            
                            <div style="text-align: center; margin-top: 15px; font-size: 12px; opacity: 0.7;">
                                <strong>Analysis powered by:</strong> ${aiMode}<br>
                                <small>${aiStatus}</small>
                            </div>
                        </div>
                    `;
                    
                    this.showNotification(message, 'hint', 25000);
                    
                } catch (error) {
                    console.error('Enhanced analysis error:', error);
                    
                    const moves = this.game.ai.findAllPossibleMoves();
                    const moveCount = moves.length;
                    const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    const progress = Math.round((foundationCards / 52) * 100);
                    
                    this.showNotification(`
                        <div style="text-align: center;">
                            <h3>üéØ Quick Analysis</h3>
                            <p><strong>Game Progress:</strong> ${progress}%</p>
                            <p><strong>Available Moves:</strong> ${moveCount}</p>
                            <p><strong>Status:</strong> ${moveCount > 0 ? 'Keep playing! üéÆ' : 'Try drawing from stock üìö'}</p>
                            <p><small>Advanced AI analysis temporarily unavailable</small></p>
                        </div>
                    `, 'hint', 5000);
                }
            }
        }

        // Card manager
        class CardManager {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            createDeck() {
                return this.game.constants.SUITS.flatMap(suit =>
                    this.game.constants.RANKS.map((rank, index) => ({
                        id: `${rank}${suit}`,
                        suit,
                        rank,
                        value: index + 1,
                        faceUp: false
                    }))
                );
            }
            
            shuffle(deck) {
                const shuffled = [...deck];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            findCardLocation(card) {
                // Check waste pile
                for (let i = 0; i < this.game.state.waste.length; i++) {
                    if (this.game.state.waste[i].id === card.id) {
                        return { type: 'waste', index: i };
                    }
                }
                
                // Check foundation piles
                for (const [suit, pile] of Object.entries(this.game.state.foundations)) {
                    for (let i = 0; i < pile.length; i++) {
                        if (pile[i].id === card.id) {
                            return { type: 'foundation', suit: suit, index: i };
                        }
                    }
                }
                
                // Check tableau piles
                for (let pileIndex = 0; pileIndex < this.game.state.tableau.length; pileIndex++) {
                    const pile = this.game.state.tableau[pileIndex];
                    for (let cardIndex = 0; cardIndex < pile.length; cardIndex++) {
                        if (pile[cardIndex].id === card.id) {
                            return { type: 'tableau', pileIndex: pileIndex, cardIndex: cardIndex };
                        }
                    }
                }
                
                return null;
            }
        }

        // Game state
        class GameState {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.drawMode = null;
                this.stock = [];
                this.waste = [];
                this.tableau = Array.from({ length: 7 }, () => []);
                this.foundations = { '‚ô†': [], '‚ô•': [], '‚ô¶': [], '‚ô£': [] };
                this.gameStats = { moves: 0, time: 0, score: 0 };
                this.gameHistory = [];
                this.hintCardId = null;
                this.hoveredCard = null;
            }
            
            initializeGame() {
                try {
                    this.gameStats = { moves: 0, time: 0, score: 0 };
                    this.gameHistory = [];
                    this.hintCardId = null;
                    this.game.gameWon = false;
                    this.hoveredCard = null;
                    this.game.input.resetDragState();
                    
                    if (this.game.timer) clearInterval(this.game.timer);
                    
                    const deck = this.game.cards.shuffle(this.game.cards.createDeck());
                    
                    this.tableau = Array.from({ length: 7 }, () => []);
                    for (let col = 0; col < 7; col++) {
                        for (let row = 0; row <= col; row++) {
                            const card = deck.pop();
                            card.faceUp = row === col;
                            this.tableau[col].push(card);
                        }
                    }
                    
                    this.stock = deck;
                    this.waste = [];
                    this.foundations = { '‚ô†': [], '‚ô•': [], '‚ô¶': [], '‚ô£': [] };
                    
                    if (this.game.settings.data.scoringMode === 'vegas') {
                        this.gameStats.score = -52;
                    } else {
                        this.gameStats.score = this.tableau.reduce((score, pile) => {
                            return score + (pile.length > 0 && pile[pile.length - 1].faceUp ? 5 : 0);
                        }, 0);
                    }
                    
                    if (this.game.currentGameMode !== 'restored') {
                        this.game.stats.data.gamesPlayed++;
                        this.game.stats.saveStatistics();
                    }
                    
                    this.game.ui.updateUI();
                    this.game.renderer.render();
                    this.startTimer();
                } catch (error) {
                    console.error('Error initializing game:', error);
                }
            }
            
            startTimer() {
                this.game.timer = setInterval(() => {
                    this.gameStats.time++;
                    
                    if (this.game.settings.data.scoringMode === 'vegas' && this.gameStats.time % 10 === 0) {
                        this.gameStats.score = Math.max(-999, this.gameStats.score - 2);
                    }
                    
                    this.game.ui.updateUI();
                }, 1000);
            }
            
            saveGameState() {
                if (this.gameHistory.length >= this.game.constants.MAX_HISTORY_SIZE) {
                    this.gameHistory.shift();
                }
                
                this.gameHistory.push({
                    stock: this.stock.map(card => ({ ...card })),
                    waste: this.waste.map(card => ({ ...card })),
                    tableau: this.tableau.map(pile => pile.map(card => ({ ...card }))),
                    foundations: Object.fromEntries(
                        Object.entries(this.foundations).map(([suit, pile]) => 
                            [suit, pile.map(card => ({ ...card }))]
                        )
                    ),
                    gameStats: { ...this.gameStats }
                });
            }
            
            undo() {
                const prevState = this.gameHistory.pop();
                if (!prevState) return;
                
                this.stock = prevState.stock;
                this.waste = prevState.waste;
                this.tableau = prevState.tableau;
                this.foundations = prevState.foundations;
                this.gameStats = { ...prevState.gameStats };
                this.hintCardId = null;
                this.hoveredCard = null;
                this.game.input.resetDragState();
                
                this.game.ui.updateUI();
                this.game.renderer.render();
            }
            
            updateScore(action) {
                const isVegas = this.game.settings.data.scoringMode === 'vegas';
                
                switch(action) {
                    case 'foundation':
                        this.gameStats.score += isVegas ? 5 : 10;
                        break;
                    case 'reveal':
                        this.gameStats.score += 5;
                        break;
                    case 'waste_to_tableau':
                        this.gameStats.score += isVegas ? 0 : 5;
                        break;
                    case 'tableau_to_tableau':
                        this.gameStats.score += isVegas ? 0 : 3;
                        break;
                    case 'foundation_to_tableau':
                        this.gameStats.score -= isVegas ? 5 : 15;
                        break;
                    case 'win_bonus':
                        if (isVegas) {
                            this.gameStats.score += 500;
                        } else {
                            const timeBonus = Math.max(0, 1000 - this.gameStats.time);
                            const moveBonus = Math.max(0, 500 - this.gameStats.moves);
                            this.gameStats.score += timeBonus + moveBonus;
                        }
                        break;
                }
                
                if (isVegas) {
                    this.gameStats.score = Math.max(-999, Math.min(9999, this.gameStats.score));
                } else {
                    this.gameStats.score = Math.max(0, this.gameStats.score);
                }
            }
            
            checkWinCondition() {
                const totalFoundationCards = Object.values(this.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                if (totalFoundationCards === 52 && !this.game.gameWon) {
                    this.game.gameWon = true;
                    if (this.game.timer) clearInterval(this.game.timer);
                    
                    // Victory effects
                    this.game.haptics.victory();
                    if (this.game.particles) {
                        // Create victory particles across the screen
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                const x = Math.random() * 1000;
                                const y = Math.random() * 600;
                                this.game.particles.createVictoryEffect(x, y);
                            }, i * 200);
                        }
                    }
                    
                    this.updateScore('win_bonus');
                    
                    // Record game completion for advanced ML learning
                    if (this.game.ml && !this.game.ml.isDisposed) {
                        try {
                            const allMoves = this.gameHistory.map(state => ({
                                type: 'game_state',
                                gameStats: state.gameStats,
                                timestamp: Date.now()
                            }));
                            
                            // Record the winning game for learning
                            this.game.ml.recordGameOutcome(this, allMoves, true);
                            
                            console.log('üß† Recorded winning game for AI learning');
                        } catch (mlError) {
                            console.warn('Error recording game completion for ML:', mlError);
                        }
                    }
                    
                    this.game.stats.updateGameStatistics(true);
                    
                    setTimeout(() => {
                        this.game.ui.showWinModal();
                    }, 500);
                    
                    this.game.ui.updateUI();
                }
            }
            
            saveToLocalStorage() {
                try {
                    const gameState = {
                        drawMode: this.drawMode,
                        currentGameMode: this.game.currentGameMode,
                        currentDifficulty: this.game.currentDifficulty,
                        stock: this.stock.map(card => ({ ...card })),
                        waste: this.waste.map(card => ({ ...card })),
                        tableau: this.tableau.map(pile => pile.map(card => ({ ...card }))),
                        foundations: Object.fromEntries(
                            Object.entries(this.foundations).map(([suit, pile]) => 
                                [suit, pile.map(card => ({ ...card }))]
                            )
                        ),
                        gameStats: { ...this.gameStats },
                        timestamp: Date.now()
                    };
                    
                    this.game.storage.set('klondike_save', gameState);
                } catch (error) {
                    console.error('Error saving game:', error);
                }
            }
            
            resetAllGameState() {
                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }
                
                this.stock = [];
                this.waste = [];
                this.tableau = Array.from({ length: 7 }, () => []);
                this.foundations = { '‚ô†': [], '‚ô•': [], '‚ô¶': [], '‚ô£': [] };
                this.gameStats = { moves: 0, time: 0, score: 0 };
                this.gameHistory = [];
                this.hintCardId = null;
                this.game.gameWon = false;
                this.hoveredCard = null;
                
                this.game.input.resetDragState();
                
                if (this.game.renderer.cardPositions) {
                    this.game.renderer.cardPositions.clear();
                }
            }
        }

        // Game rules
        class GameRules {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            canPlaceOnFoundation(card) {
                const pile = this.game.state.foundations[card.suit];
                const topCard = pile[pile.length - 1];
                return (card.value === 1 && pile.length === 0) || 
                       (topCard && card.value === topCard.value + 1);
            }
            
            canPlaceOnTableau(card, targetPile) {
                if (targetPile.length === 0) {
                    return card.value === 13;
                }
                const topCard = targetPile[targetPile.length - 1];
                return topCard.faceUp && 
                       topCard.value === card.value + 1 && 
                       this.game.constants.RED_SUITS.has(topCard.suit) !== this.game.constants.RED_SUITS.has(card.suit);
            }
            
            isValidSequence(cards) {
                if (cards.length <= 1) return true;
                
                for (let i = 1; i < cards.length; i++) {
                    const prevCard = cards[i - 1];
                    const currCard = cards[i];
                    
                    if (prevCard.value !== currCard.value + 1 ||
                        this.game.constants.RED_SUITS.has(prevCard.suit) === this.game.constants.RED_SUITS.has(currCard.suit)) {
                        return false;
                    }
                }
                return true;
            }
            
            isSafeToAutoMove(card) {
                if (card.value <= 2) return true;
                
                const oppositeColors = this.game.constants.RED_SUITS.has(card.suit) ? ['‚ô†', '‚ô£'] : ['‚ô•', '‚ô¶'];
                const requiredValue = card.value - 1;
                
                return oppositeColors.every(suit => {
                    const pile = this.game.state.foundations[suit];
                    return pile.length >= requiredValue;
                });
            }
            
            checkAutoMoveToFoundation() {
                if (!this.game.settings.data.autoMoveToFoundation) return false;
                
                let moved = false;
                
                if (this.game.state.waste.length > 0) {
                    const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (this.canPlaceOnFoundation(topCard) && this.isSafeToAutoMove(topCard)) {
                        this.game.ai.moveCardToFoundation(topCard);
                        moved = true;
                    }
                }
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.canPlaceOnFoundation(topCard) && this.isSafeToAutoMove(topCard)) {
                            this.game.ai.moveCardToFoundation(topCard);
                            moved = true;
                            break;
                        }
                    }
                }
                
                return moved;
            }
        }

        // AI hint system
        class AIHintSystem {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            async showHint() {
                try {
                    this.game.sound.play('cardFlip');
                    
                    const moves = this.findAllPossibleMoves();
                    this.game.state.hintCardId = null;
                    
                    if (moves.length > 0) {
                        let bestMove, analysis, smartMoves;
                        
                        // Use advanced ML evaluation for each move
                        try {
                            if (this.game.ml && this.game.ml.isInitialized && this.game.settings.data.enableMLAnalysis) {
                                console.log('üß† Using advanced AI analysis...');
                                
                                // Evaluate all moves with advanced AI
                                const evaluatedMoves = [];
                                for (const move of moves) {
                                    const evaluation = await this.game.ml.evaluateMove(move, this.game.state);
                                    evaluatedMoves.push(evaluation);
                                }
                                
                                // Sort by AI score
                                smartMoves = evaluatedMoves.sort((a, b) => b.aiScore - a.aiScore);
                                bestMove = smartMoves[0];
                                
                                // Get comprehensive game analysis
                                analysis = await this.game.ml.getGameAnalysis(this.game.state);
                            }
                        } catch (mlError) {
                            console.warn('Advanced AI analysis failed, using fallback:', mlError);
                        }
                        
                        // Fallback to basic prioritization if ML failed
                        if (!bestMove) {
                            smartMoves = this.prioritizeMoves(moves);
                            bestMove = smartMoves[0];
                            analysis = {
                                winProbability: 0.5,
                                difficulty: 'unknown',
                                recommendation: 'Keep playing strategically!',
                                stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                            };
                        }
                        
                        this.game.state.hintCardId = bestMove.cardId;
                        this.game.renderer.render();
                        
                        // Create enhanced hint message with full AI capabilities
                        const mlMode = this.game.ml && this.game.ml.isInitialized && !this.game.ml.fallbackMode;
                        const aiIcon = mlMode ? 'üß†' : 'üéØ';
                        const aiType = mlMode ? 'Advanced AI with Complete Board Vision' : 'Smart Analysis';
                        
                        // Prepare move reasoning
                        let moveReasoning = '';
                        if (bestMove.strategicReasoning && bestMove.strategicReasoning.length > 0) {
                            moveReasoning = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>üéØ Strategic Reasoning:</strong><br>
                                    <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
                                        ${bestMove.strategicReasoning.map(reason => `<li>${reason}</li>`).join('')}
                                    </ul>
                                </div>
                            `;
                        }
                        
                        // Stock drawing recommendation
                        let stockAdvice = '';
                        if (analysis.stockRecommendation) {
                            const stockRec = analysis.stockRecommendation;
                            stockAdvice = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>üìö Stock Strategy:</strong><br>
                                    <span style="color: ${stockRec.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                        ${stockRec.shouldDraw ? '‚úÖ Draw from stock' : '‚è∏Ô∏è Focus on tableau first'}
                                    </span><br>
                                    <small>${stockRec.reason}</small>
                                    ${stockRec.upcomingCards ? `<br><small>Next cards: ${stockRec.upcomingCards.join(', ')}</small>` : ''}
                                </div>
                            `;
                        }
                        
                        // Hidden cards insights
                        let hiddenInsights = '';
                        if (analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0) {
                            const insights = analysis.hiddenCardInsights.insights.slice(0, 3); // Show top 3
                            hiddenInsights = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>üîç Hidden Card Intel:</strong><br>
                                    ${insights.map(insight => `<small>‚Ä¢ ${insight}</small>`).join('<br>')}
                                </div>
                            `;
                        }
                        
                        // Learning insights
                        let learningInfo = '';
                        if (analysis.learningInsights && analysis.learningInsights.totalLearningData > 0) {
                            learningInfo = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>üìñ AI Learning:</strong><br>
                                    <small>Learned from ${analysis.learningInsights.totalLearningData} winning games</small>
                                    ${analysis.learningInsights.insights.length > 0 ? '<br>' + analysis.learningInsights.insights.map(insight => `<small>‚Ä¢ ${insight}</small>`).join('<br>') : ''}
                                </div>
                            `;
                        }
                        
                        // Alternative moves
                        let alternativeMoves = '';
                        if (smartMoves && smartMoves.length > 1) {
                            const alternatives = smartMoves.slice(1, 3);
                            alternativeMoves = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                    <strong>üîÑ Alternative Moves:</strong><br>
                                    ${alternatives.map((move, i) => {
                                        const score = move.aiScore ? Math.round(move.aiScore) : Math.round((move.priority / 20) * 100);
                                        return `<small>${i + 2}. ${move.description} (${score}%)</small>`;
                                    }).join('<br>')}
                                </div>
                            `;
                        }
                        
                        const message = `
                            <div style="text-align: left; line-height: 1.6; font-size: 14px; max-width: 500px;">
                                <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                                    ${aiIcon} ${aiType}
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>üí° Best Move:</strong><br>
                                    <span style="color: #4ade80; font-weight: bold;">${bestMove.description}</span>
                                    ${bestMove.aiScore ? `<span style="color: #a78bfa; font-size: 12px;"> (AI Score: ${Math.round(bestMove.aiScore)})</span>` : ''}
                                    ${bestMove.confidence ? `<span style="color: #fbbf24; font-size: 12px;"> (${Math.round(bestMove.confidence * 100)}% confidence)</span>` : ''}
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>üéØ Win Probability:</strong> 
                                    <span style="color: ${analysis.winProbability > 0.6 ? '#4ade80' : analysis.winProbability > 0.3 ? '#f59e0b' : '#ef4444'};">
                                        ${Math.round(analysis.winProbability * 100)}%
                                    </span>
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>üìä Difficulty:</strong> 
                                    <span class="difficulty-indicator diff-${analysis.difficulty}">${analysis.difficulty.toUpperCase()}</span>
                                </div>
                                
                                ${moveReasoning}
                                ${stockAdvice}
                                ${hiddenInsights}
                                ${learningInfo}
                                ${alternativeMoves}
                                
                                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                                    <strong>ü§ñ AI Recommendation:</strong><br>
                                    <span style="color: #a78bfa; font-style: italic;">${analysis.recommendation}</span>
                                </div>
                                
                                <div style="text-align: center; margin-top: 15px; font-size: 11px; opacity: 0.7;">
                                    <strong>Powered by:</strong> ${aiType}<br>
                                    ${mlMode ? 'Complete board vision ‚Ä¢ Learning algorithms ‚Ä¢ Strategic planning' : 'Mathematical analysis ‚Ä¢ Pattern recognition'}
                                </div>
                            </div>
                        `;
                        
                        this.game.ui.showNotification(message, 'hint', 20000);
                        
                    } else if (this.game.state.stock.length > 0 || this.game.state.waste.length > 0) {
                        // No moves available - provide stock drawing guidance
                        let stockGuidance = '';
                        try {
                            if (this.game.ml && this.game.ml.isInitialized) {
                                const stockAnalysis = await this.game.ml.recommendStockDrawing(this.game.state);
                                stockGuidance = `
                                    <br><strong>üìö Stock Analysis:</strong><br>
                                    <small>${stockAnalysis.reason}</small>
                                    ${stockAnalysis.upcomingCards ? `<br><small>Next: ${stockAnalysis.upcomingCards.join(', ')}</small>` : ''}
                                `;
                            }
                        } catch (error) {
                            console.warn('Stock analysis failed:', error);
                        }
                        
                        this.game.ui.showNotification(`üìö Draw from stock to reveal new options${stockGuidance}`, 'hint', 5000);
                    } else {
                        // No moves and no stock - advanced analysis for stuck situations
                        let stuckAnalysis = '';
                        try {
                            if (this.game.ml && this.game.ml.isInitialized) {
                                const analysis = await this.game.ml.getGameAnalysis(this.game.state);
                                stuckAnalysis = `<br><small>${analysis.recommendation}</small>`;
                            }
                        } catch (error) {
                            console.warn('Stuck analysis failed:', error);
                        }
                        
                        this.game.ui.showNotification(`‚ùå No moves available${stuckAnalysis}<br><small>Consider undoing recent moves or starting fresh.</small>`, 'hint', 4000);
                    }
                } catch (error) {
                    console.error('Error showing enhanced hint:', error);
                    // Emergency fallback
                    this.game.ui.showNotification('üí° Try drawing from the stock pile or look for foundation moves', 'hint', 3000);
                }
            }
            
            findAllPossibleMoves() {
                const moves = [];
                
                moves.push(...this.findFoundationMoves());
                moves.push(...this.findTableauMoves());
                moves.push(...this.findWasteMoves());
                
                return moves;
            }
            
            findFoundationMoves() {
                const moves = [];
                
                if (this.game.state.waste.length > 0) {
                    const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (this.game.rules.canPlaceOnFoundation(topCard)) {
                        moves.push({
                            type: 'foundation',
                            cardId: topCard.id,
                            card: topCard,
                            priority: 10 + topCard.value,
                            description: `Move ${topCard.rank}${topCard.suit} to foundation`
                        });
                    }
                }
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.game.rules.canPlaceOnFoundation(topCard)) {
                            const willReveal = pile.length > 1 && !pile[pile.length - 2].faceUp;
                            moves.push({
                                type: 'foundation',
                                cardId: topCard.id,
                                card: topCard,
                                priority: 10 + topCard.value + (willReveal ? 5 : 0),
                                description: `Move ${topCard.rank}${topCard.suit} to foundation${willReveal ? ' (reveals card)' : ''}`
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            findTableauMoves() {
                const moves = [];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length === 0) continue;
                    
                    const topCard = pile[pile.length - 1];
                    if (!topCard.faceUp) continue;
                    
                    for (let j = 0; j < this.game.state.tableau.length; j++) {
                        if (i !== j && this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[j])) {
                            const targetEmpty = this.game.state.tableau[j].length === 0;
                            const priority = targetEmpty && topCard.value !== 13 ? 2 : 5;
                            
                            moves.push({
                                type: 'tableau',
                                cardId: topCard.id,
                                card: topCard,
                                priority: priority,
                                description: `Move ${topCard.rank}${topCard.suit} to ${targetEmpty ? 'empty space' : 'tableau pile'}`
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            findWasteMoves() {
                const moves = [];
                
                if (this.game.state.waste.length === 0) return moves;
                
                const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    if (this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[i])) {
                        const targetEmpty = this.game.state.tableau[i].length === 0;
                        const priority = targetEmpty && topCard.value !== 13 ? 3 : 6;
                        
                        moves.push({
                            type: 'waste-to-tableau',
                            cardId: topCard.id,
                            card: topCard,
                            priority: priority,
                            description: `Move ${topCard.rank}${topCard.suit} from waste to tableau`
                        });
                    }
                }
                
                return moves;
            }
            
            prioritizeMoves(moves) {
                return moves.sort((a, b) => {
                    if (a.priority !== b.priority) {
                        return b.priority - a.priority;
                    }
                    
                    const typeOrder = { foundation: 4, tableau: 2, 'waste-to-tableau': 1 };
                    return (typeOrder[b.type] || 0) - (typeOrder[a.type] || 0);
                });
            }
            
            moveCardToFoundation(card) {
                const cardLocation = this.game.cards.findCardLocation(card);
                if (!cardLocation) return;
                
                if (cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    const isTopCard = cardLocation.cardIndex === pile.length - 1;
                    if (!isTopCard) return;
                }
                
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                if (cardLocation.type === 'waste') {
                    const wasteIndex = this.game.state.waste.findIndex(c => c.id === card.id);
                    if (wasteIndex === this.game.state.waste.length - 1) {
                        this.game.state.waste.pop();
                    }
                } else if (cardLocation.type === 'foundation') {
                    const pile = this.game.state.foundations[cardLocation.suit];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                    }
                } else if (cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                        if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
                            pile[pile.length - 1].faceUp = true;
                            this.game.state.updateScore('reveal');
                        }
                    }
                }
                
                this.game.state.foundations[card.suit].push(card);
                this.game.state.updateScore('foundation');
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 300);
            }
            
            attemptAutoMove(card) {
                try {
                    const cardLocation = this.game.cards.findCardLocation(card);
                    if (!cardLocation) return false;
                    
                    if (cardLocation.type === 'tableau') {
                        const pile = this.game.state.tableau[cardLocation.pileIndex];
                        const cardIndex = cardLocation.cardIndex;
                        const isTopCard = cardIndex === pile.length - 1;
                        
                        if (isTopCard && this.game.rules.canPlaceOnFoundation(card)) {
                            this.moveCardToFoundation(card);
                            return true;
                        }
                        
                        const cardsToMove = pile.slice(cardIndex);
                        if (this.game.rules.isValidSequence(cardsToMove)) {
                            for (let i = 0; i < this.game.state.tableau.length; i++) {
                                if (i !== cardLocation.pileIndex && this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                                    this.moveCardSequenceToTableau(card, cardLocation, i);
                                    return true;
                                }
                            }
                        }
                    } else {
                        if (this.game.rules.canPlaceOnFoundation(card)) {
                            this.moveCardToFoundation(card);
                            return true;
                        }
                        
                        for (let i = 0; i < this.game.state.tableau.length; i++) {
                            if (this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                                this.moveCardToTableau(card, i);
                                return true;
                            }
                        }
                    }
                    
                    return false;
                } catch (error) {
                    console.error('Error attempting auto-move:', error);
                    return false;
                }
            }
            
            moveCardSequenceToTableau(card, sourceLocation, targetPileIndex) {
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                const sourcePile = this.game.state.tableau[sourceLocation.pileIndex];
                const cardIndex = sourceLocation.cardIndex;
                const movingCards = sourcePile.splice(cardIndex);
                
                if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                    sourcePile[sourcePile.length - 1].faceUp = true;
                    this.game.state.updateScore('reveal');
                }
                
                this.game.state.tableau[targetPileIndex].push(...movingCards);
                this.game.state.updateScore('tableau_to_tableau');
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 100);
            }
            
            moveCardToTableau(card, targetPileIndex) {
                const cardLocation = this.game.cards.findCardLocation(card);
                if (!cardLocation) return;
                
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                let moveType = 'tableau_to_tableau';
                
                if (cardLocation.type === 'waste') {
                    if (this.game.state.waste.length > 0 && this.game.state.waste[this.game.state.waste.length - 1].id === card.id) {
                        this.game.state.waste.pop();
                        this.game.state.tableau[targetPileIndex].push(card);
                        moveType = 'waste_to_tableau';
                    }
                } else if (cardLocation.type === 'foundation') {
                    const pile = this.game.state.foundations[cardLocation.suit];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                        this.game.state.tableau[targetPileIndex].push(card);
                        moveType = 'foundation_to_tableau';
                    }
                } else if (cardLocation.type === 'tableau') {
                    this.moveCardSequenceToTableau(card, cardLocation, targetPileIndex);
                    return;
                }
                
                this.game.state.updateScore(moveType);
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 100);
            }
            
            flipStock() {
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                this.game.sound.play('cardFlip');
                
                if (this.game.state.stock.length === 0) {
                    this.game.state.stock = this.game.state.waste.map(card => ({ ...card, faceUp: false })).reverse();
                    this.game.state.waste = [];
                    
                    if (this.game.settings.data.scoringMode === 'vegas') {
                        this.game.state.gameStats.score = Math.max(-999, this.game.state.gameStats.score - 100);
                    }
                } else {
                    const cardsToDraw = Math.min(this.game.state.drawMode, this.game.state.stock.length);
                    const drawn = this.game.state.stock.splice(-cardsToDraw).map(card => ({ ...card, faceUp: true }));
                    this.game.state.waste.push(...drawn);
                }
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
            }
        }

        // Enhanced haptic feedback for mobile
        class HapticManager {
            static vibrate(pattern = 50) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(pattern);
                }
            }
            
            static cardFlip() {
                this.vibrate([10]);
            }
            
            static cardPlace() {
                this.vibrate([30]);
            }
            
            static victory() {
                this.vibrate([100, 50, 100, 50, 200]);
            }
            
            static error() {
                this.vibrate([200]);
            }
        }

        // Particle effects system
        class ParticleSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
            }
            
            createVictoryEffect(x, y) {
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        decay: 0.02,
                        color: `hsl(${Math.random() * 60 + 300}, 100%, 50%)`
                    });
                }
            }
            
            createCardPlaceEffect(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 0.5,
                        decay: 0.05,
                        color: '#4ade80'
                    });
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2; // gravity
                    particle.life -= particle.decay;
                    return particle.life > 0;
                });
            }
            
            render() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
        }

        // Input manager
        class InputManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.canvas = null;
                this.isDragging = false;
                this.draggedCards = [];
                this.dragCurrentPos = { x: 0, y: 0 };
                this.dragSourceInfo = null;
                this.dragOffset = { x: 0, y: 0 };
                
                this.boundHandlers = {
                    mouseDown: this.handleMouseDown.bind(this),
                    mouseMove: this.handleMouseMove.bind(this),
                    mouseUp: this.handleMouseUp.bind(this),
                    click: this.handleCanvasClick.bind(this),
                    doubleClick: this.handleCanvasDoubleClick.bind(this),
                    mouseLeave: this.handleMouseLeave.bind(this),
                    touchStart: this.handleTouchStart.bind(this),
                    touchMove: this.handleTouchMove.bind(this),
                    touchEnd: this.handleTouchEnd.bind(this),
                    keyDown: this.handleKeyDown.bind(this),
                    contextMenu: this.handleContextMenu.bind(this)
                };
            }
            
            initCanvas() {
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) return;
                
                this.canvas.addEventListener('mousedown', this.boundHandlers.mouseDown, false);
                this.canvas.addEventListener('mousemove', this.boundHandlers.mouseMove, false);
                this.canvas.addEventListener('mouseup', this.boundHandlers.mouseUp, false);
                this.canvas.addEventListener('click', this.boundHandlers.click, false);
                this.canvas.addEventListener('dblclick', this.boundHandlers.doubleClick, false);
                this.canvas.addEventListener('mouseleave', this.boundHandlers.mouseLeave, false);
                
                this.canvas.addEventListener('touchstart', this.boundHandlers.touchStart, { passive: false });
                this.canvas.addEventListener('touchmove', this.boundHandlers.touchMove, { passive: false });
                this.canvas.addEventListener('touchend', this.boundHandlers.touchEnd, { passive: false });
                
                document.addEventListener('keydown', this.boundHandlers.keyDown, false);
                
                this.canvas.addEventListener('contextmenu', this.boundHandlers.contextMenu, false);
                
                this.canvas.style.userSelect = 'none';
                this.canvas.style.touchAction = 'none';
                this.canvas.tabIndex = 0;
            }
            
            cleanup() {
                if (!this.canvas) return;
                
                this.canvas.removeEventListener('mousedown', this.boundHandlers.mouseDown);
                this.canvas.removeEventListener('mousemove', this.boundHandlers.mouseMove);
                this.canvas.removeEventListener('mouseup', this.boundHandlers.mouseUp);
                this.canvas.removeEventListener('click', this.boundHandlers.click);
                this.canvas.removeEventListener('dblclick', this.boundHandlers.doubleClick);
                this.canvas.removeEventListener('mouseleave', this.boundHandlers.mouseLeave);
                this.canvas.removeEventListener('touchstart', this.boundHandlers.touchStart);
                this.canvas.removeEventListener('touchmove', this.boundHandlers.touchMove);
                this.canvas.removeEventListener('touchend', this.boundHandlers.touchEnd);
                this.canvas.removeEventListener('contextmenu', this.boundHandlers.contextMenu);
                
                document.removeEventListener('keydown', this.boundHandlers.keyDown);
            }
            
            resetDragState() {
                this.isDragging = false;
                this.draggedCards = [];
                this.dragSourceInfo = null;
                this.updateCursor();
            }
            
            updateCursor() {
                if (!this.canvas) return;
                
                if (this.isDragging) {
                    this.canvas.style.cursor = 'grabbing';
                } else if (this.game.state.hoveredCard && this.game.state.hoveredCard.faceUp && this.game.state.hoveredCard.id !== 'stock') {
                    this.canvas.style.cursor = 'pointer';
                } else if (this.game.state.hoveredCard && this.game.state.hoveredCard.id === 'stock') {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0] || e.changedTouches[0];
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            }
            
            handleKeyDown(e) {
                if (document.getElementById('gameArea').style.display === 'none') return;
                
                try {
                    switch(e.key.toLowerCase()) {
                        case 'n':
                            e.preventDefault();
                            this.game.newGame();
                            break;
                        case 'u':
                        case 'z':
                            if (e.ctrlKey || e.metaKey || e.key === 'u') {
                                e.preventDefault();
                                this.game.undo();
                            }
                            break;
                        case 'h':
                        case '?':
                            e.preventDefault();
                            this.game.ai.showHint();
                            break;
                        case 's':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.game.storage.quickSave();
                            }
                            break;
                        case ' ':
                        case 'enter':
                            e.preventDefault();
                            if (this.game.state.stock.length > 0 || this.game.state.waste.length > 0) {
                                this.game.ai.flipStock();
                            }
                            break;
                        case 'escape':
                            if (this.isDragging) {
                                this.resetDragState();
                                this.game.renderer.render();
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Error handling keyboard input:', error);
                }
            }
            
            handleMouseDown(e) {
                if (this.game.gameWon) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo) {
                        if (cardInfo.card.id === 'stock') {
                            return;
                        }
                        
                        if (cardInfo.card.faceUp) {
                            e.preventDefault();
                            this.startDrag(cardInfo, pos.x, pos.y);
                        }
                    }
                } catch (error) {
                    console.error('Error handling mouse down:', error);
                }
            }
            
            handleMouseMove(e) {
                try {
                    const pos = this.getMousePos(e);
                    
                    if (this.isDragging) {
                        this.dragCurrentPos.x = pos.x;
                        this.dragCurrentPos.y = pos.y;
                        this.game.renderer.render();
                    } else {
                        const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                        const newHoveredCard = cardInfo ? cardInfo.card : null;
                        if (this.game.state.hoveredCard !== newHoveredCard) {
                            this.game.state.hoveredCard = newHoveredCard;
                            this.updateCursor();
                            this.game.renderer.render();
                        }
                    }
                } catch (error) {
                    console.error('Error handling mouse move:', error);
                }
            }
            
            handleMouseUp(e) {
                if (!this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const dropZone = this.game.renderer.getDropZoneAt(pos.x, pos.y);
                    if (dropZone && this.isValidDrop(dropZone)) {
                        this.executeDrop(dropZone);
                    }
                    
                    this.resetDragState();
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling mouse up:', error);
                }
            }
            
            handleCanvasClick(e) {
                if (this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo && cardInfo.card.id === 'stock') {
                        this.game.ai.flipStock();
                    }
                } catch (error) {
                    console.error('Error handling canvas click:', error);
                }
            }
            
            handleCanvasDoubleClick(e) {
                if (this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo && cardInfo.card.faceUp && cardInfo.card.id !== 'stock') {
                        this.game.ai.attemptAutoMove(cardInfo.card);
                    }
                } catch (error) {
                    console.error('Error handling double click:', error);
                }
            }
            
            handleMouseLeave(e) {
                this.game.state.hoveredCard = null;
                this.updateCursor();
                if (!this.isDragging) {
                    this.game.renderer.render();
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                try {
                    const pos = this.getTouchPos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo) {
                        if (cardInfo.card.id === 'stock') {
                            this.game.haptics.cardFlip();
                            this.game.ai.flipStock();
                        } else if (cardInfo.card.faceUp) {
                            this.game.haptics.cardPlace();
                            this.startDrag(cardInfo, pos.x, pos.y);
                        }
                    }
                } catch (error) {
                    console.error('Error handling touch start:', error);
                }
            }
            
            handleTouchMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                
                try {
                    const pos = this.getTouchPos(e);
                    this.dragCurrentPos.x = pos.x;
                    this.dragCurrentPos.y = pos.y;
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling touch move:', error);
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                if (!this.isDragging) return;
                
                try {
                    const pos = this.getTouchPos(e);
                    const dropZone = this.game.renderer.getDropZoneAt(pos.x, pos.y);
                    if (dropZone && this.isValidDrop(dropZone)) {
                        this.game.haptics.cardPlace();
                        if (this.game.particles) {
                            this.game.particles.createCardPlaceEffect(pos.x, pos.y);
                        }
                        this.executeDrop(dropZone);
                    } else {
                        this.game.haptics.error();
                    }
                    
                    this.resetDragState();
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling touch end:', error);
                }
            }
            
            handleContextMenu(e) {
                e.preventDefault();
            }
            
            startDrag(cardInfo, mouseX, mouseY) {
                try {
                    const card = cardInfo.card;
                    this.dragOffset.x = mouseX - cardInfo.x;
                    this.dragOffset.y = mouseY - cardInfo.y;
                    this.dragCurrentPos.x = mouseX;
                    this.dragCurrentPos.y = mouseY;
                    
                    if (cardInfo.location === 'waste') {
                        if (this.game.state.waste.length > 0 && this.game.state.waste[this.game.state.waste.length - 1].id === card.id) {
                            this.dragSourceInfo = { type: 'waste' };
                            this.draggedCards = [card];
                        }
                    } else if (cardInfo.location === 'foundation') {
                        this.dragSourceInfo = { type: 'foundation', suit: cardInfo.suit };
                        this.draggedCards = [card];
                    } else if (cardInfo.location === 'tableau') {
                        const pile = this.game.state.tableau[cardInfo.pileIndex];
                        const cardIndex = cardInfo.cardIndex;
                        
                        this.dragSourceInfo = { type: 'tableau', pileIndex: cardInfo.pileIndex, cardIndex: cardIndex };
                        
                        if (pile[cardIndex].faceUp) {
                            this.draggedCards = pile.slice(cardIndex);
                        } else {
                            return;
                        }
                    }
                    
                    if (this.draggedCards.length > 0) {
                        this.isDragging = true;
                        this.updateCursor();
                        this.game.renderer.render();
                    }
                } catch (error) {
                    console.error('Error starting drag:', error);
                }
            }
            
            isValidDrop(dropZone) {
                try {
                    if (dropZone.type === 'foundation') {
                        return this.isValidFoundationDrop(dropZone.suit);
                    } else if (dropZone.type === 'tableau') {
                        return this.isValidTableauDrop(dropZone.pileIndex);
                    }
                    return false;
                } catch (error) {
                    console.error('Error validating drop:', error);
                    return false;
                }
            }
            
            isValidFoundationDrop(suit) {
                if (this.draggedCards.length !== 1) return false;
                const card = this.draggedCards[0];
                return card.suit === suit && this.game.rules.canPlaceOnFoundation(card);
            }
            
            isValidTableauDrop(pileIndex) {
                if (this.draggedCards.length === 0) return false;
                
                if (this.dragSourceInfo && this.dragSourceInfo.type === 'tableau' && 
                    this.dragSourceInfo.pileIndex === pileIndex) {
                    return false;
                }
                
                if (!this.game.rules.isValidSequence(this.draggedCards)) {
                    return false;
                }
                
                const topCard = this.draggedCards[0];
                return this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[pileIndex]);
            }
            
            executeDrop(dropZone) {
                try {
                    this.game.state.saveGameState();
                    this.game.state.gameStats.moves++;
                    this.game.sound.play('cardPlace');
                    
                    let moveType = '';
                    if (dropZone.type === 'foundation') {
                        moveType = 'foundation';
                    } else if (this.dragSourceInfo.type === 'waste') {
                        moveType = 'waste_to_tableau';
                    } else if (this.dragSourceInfo.type === 'foundation') {
                        moveType = 'foundation_to_tableau';
                    } else {
                        moveType = 'tableau_to_tableau';
                    }
                    
                    let willRevealCard = false;
                    if (this.dragSourceInfo.type === 'tableau') {
                        const sourcePile = this.game.state.tableau[this.dragSourceInfo.pileIndex];
                        const remainingCards = sourcePile.length - this.draggedCards.length;
                        if (remainingCards > 0 && !sourcePile[remainingCards - 1].faceUp) {
                            willRevealCard = true;
                        }
                    }
                    
                    if (this.dragSourceInfo.type === 'waste') {
                        this.game.state.waste.pop();
                    } else if (this.dragSourceInfo.type === 'foundation') {
                        this.game.state.foundations[this.dragSourceInfo.suit].pop();
                    } else if (this.dragSourceInfo.type === 'tableau') {
                        const sourcePile = this.game.state.tableau[this.dragSourceInfo.pileIndex];
                        sourcePile.splice(this.dragSourceInfo.cardIndex);
                        
                        if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                            sourcePile[sourcePile.length - 1].faceUp = true;
                        }
                    }
                    
                    if (dropZone.type === 'foundation') {
                        this.game.state.foundations[dropZone.suit].push(...this.draggedCards);
                    } else if (dropZone.type === 'tableau') {
                        this.game.state.tableau[dropZone.pileIndex].push(...this.draggedCards);
                    }
                    
                    this.game.state.updateScore(moveType);
                    if (willRevealCard) {
                        this.game.state.updateScore('reveal');
                    }
                    
                    this.game.state.hintCardId = null;
                    this.game.ui.updateUI();
                    
                    setTimeout(() => {
                        if (this.game.rules.checkAutoMoveToFoundation()) {
                            this.game.renderer.render();
                        }
                    }, 100);
                } catch (error) {
                    console.error('Error executing drop:', error);
                }
            }
        }

        // Render engine
        class RenderEngine {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.canvas = null;
                this.ctx = null;
                this.cardPositions = new Map();
                this.validDropZones = [];
            }
            
            init() {
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) return false;
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) return false;
                
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // Initialize particle system
                if (!this.game.particles) {
                    this.game.particles = new ParticleSystem(this.canvas);
                }
                
                return true;
            }
            
            render() {
                try {
                    if (!this.ctx) {
                        if (!this.init()) return;
                    }
                    
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.cardPositions.clear();
                    this.validDropZones = [];
                    
                    this.drawStock();
                    this.drawWaste();
                    this.drawFoundations();
                    this.drawTableau();
                    this.drawDraggedCards();
                    
                    // Update and render particle effects
                    if (this.game.particles) {
                        this.game.particles.update();
                        this.game.particles.render();
                    }
                } catch (error) {
                    console.error('Error rendering game:', error);
                }
            }
            
            drawStock() {
                const stockX = 50;
                const stockY = 50;
                
                if (this.game.state.stock.length > 0) {
                    const depth = Math.min(3, this.game.state.stock.length);
                    for (let i = 0; i < depth; i++) {
                        this.drawCard({ id: 'stock', faceUp: false }, stockX - i*2, stockY - i*2, false, 0.7 + i*0.1);
                    }
                    
                    const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === 'stock';
                    this.drawCard({ id: 'stock', faceUp: false }, stockX, stockY, false, 1, isHovered);
                } else {
                    this.ctx.strokeStyle = '#9ca3af';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(stockX, stockY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                    this.ctx.setLineDash([]);
                    
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('‚Üª', stockX + this.game.constants.CARD_WIDTH/2, stockY + this.game.constants.CARD_HEIGHT/2);
                }
                
                this.cardPositions.set('stock', { 
                    x: stockX, 
                    y: stockY, 
                    card: { id: 'stock', faceUp: false }, 
                    width: this.game.constants.CARD_WIDTH, 
                    height: this.game.constants.CARD_HEIGHT,
                    location: 'stock'
                });
            }
            
            drawWaste() {
                const wasteX = 50 + this.game.constants.CARD_WIDTH + 20;
                const wasteY = 50;
                const visibleWaste = this.game.state.waste.slice(-this.game.state.drawMode);
                
                visibleWaste.forEach((card, i) => {
                    const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === card.id);
                    const alpha = isDraggedCard ? 0.3 : 1;
                    const x = wasteX + i * this.game.constants.WASTE_CARD_OFFSET;
                    const y = wasteY;
                    const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === card.id;
                    
                    this.drawCard(card, x, y, card.id === this.game.state.hintCardId, alpha, isHovered);
                    
                    if (alpha >= 0.5) {
                        this.cardPositions.set(card.id, { 
                            x, 
                            y, 
                            card, 
                            width: this.game.constants.CARD_WIDTH, 
                            height: this.game.constants.CARD_HEIGHT,
                            location: 'waste',
                            stackIndex: i
                        });
                    }
                });
            }
            
            drawFoundations() {
                const foundationStartX = 50 + this.game.constants.CARD_WIDTH + 20 + this.game.constants.CARD_WIDTH + 80;
                
                this.game.constants.SUITS.forEach((suit, i) => {
                    const foundationX = foundationStartX + i * (this.game.constants.CARD_WIDTH + 10);
                    const foundationY = 50;
                    const pile = this.game.state.foundations[suit];
                    
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === topCard.id);
                        const alpha = isDraggedCard ? 0.3 : 1;
                        const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === topCard.id;
                        
                        this.drawCard(topCard, foundationX, foundationY, topCard.id === this.game.state.hintCardId, alpha, isHovered);
                        
                        if (alpha >= 0.5) {
                            this.cardPositions.set(topCard.id, { 
                                x: foundationX, 
                                y: foundationY, 
                                card: topCard, 
                                width: this.game.constants.CARD_WIDTH, 
                                height: this.game.constants.CARD_HEIGHT,
                                location: 'foundation',
                                suit: suit
                            });
                        }
                    } else {
                        const isValidDrop = this.game.input.isDragging && this.isValidFoundationDrop(suit);
                        this.ctx.strokeStyle = isValidDrop ? '#22c55e' : '#9ca3af';
                        this.ctx.lineWidth = isValidDrop ? 4 : 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.strokeRect(foundationX, foundationY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        this.ctx.setLineDash([]);
                        
                        if (isValidDrop) {
                            this.ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            this.ctx.fillRect(foundationX, foundationY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.fillStyle = isValidDrop ? '#22c55e' : '#9ca3af';
                        this.ctx.font = 'bold 32px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(suit, foundationX + this.game.constants.CARD_WIDTH/2, foundationY + this.game.constants.CARD_HEIGHT/2);
                    }
                    
                    this.validDropZones.push({
                        type: 'foundation',
                        suit: suit,
                        x: foundationX,
                        y: foundationY,
                        width: this.game.constants.CARD_WIDTH,
                        height: this.game.constants.CARD_HEIGHT
                    });
                });
            }
            
            drawTableau() {
                const tableauStartX = 50;
                const tableauY = 50 + this.game.constants.CARD_HEIGHT + 40;
                
                this.game.state.tableau.forEach((pile, pileIndex) => {
                    const pileX = tableauStartX + pileIndex * (this.game.constants.CARD_WIDTH + 15);
                    let maxY = tableauY;
                    
                    pile.forEach((card, cardIndex) => {
                        const cardY = tableauY + cardIndex * (card.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET);
                        const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === card.id);
                        const alpha = isDraggedCard ? 0.3 : 1;
                        const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === card.id;
                        
                        this.drawCard(card, pileX, cardY, card.id === this.game.state.hintCardId, alpha, isHovered);
                        maxY = cardY + this.game.constants.CARD_HEIGHT;
                        
                        if (alpha >= 0.5) {
                            this.cardPositions.set(card.id, { 
                                x: pileX, 
                                y: cardY, 
                                card, 
                                width: this.game.constants.CARD_WIDTH, 
                                height: this.game.constants.CARD_HEIGHT,
                                location: 'tableau',
                                pileIndex,
                                cardIndex
                            });
                        }
                    });
                    
                    if (pile.length === 0) {
                        const isValidDrop = this.game.input.isDragging && this.isValidTableauDrop(pileIndex);
                        this.ctx.strokeStyle = isValidDrop ? '#22c55e' : '#6b7280';
                        this.ctx.lineWidth = isValidDrop ? 4 : 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.strokeRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        this.ctx.setLineDash([]);
                        
                        if (isValidDrop) {
                            this.ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            this.ctx.fillRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.fillStyle = isValidDrop ? '#22c55e' : '#6b7280';
                        this.ctx.font = 'bold 24px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('K', pileX + this.game.constants.CARD_WIDTH/2, tableauY + this.game.constants.CARD_HEIGHT/2);
                        
                        maxY = tableauY + this.game.constants.CARD_HEIGHT;
                    }
                    
                    this.validDropZones.push({
                        type: 'tableau',
                        pileIndex: pileIndex,
                        x: pileX,
                        y: tableauY,
                        width: this.game.constants.CARD_WIDTH,
                        height: Math.max(this.game.constants.CARD_HEIGHT, maxY - tableauY)
                    });
                });
            }
            
            drawDraggedCards() {
                if (this.game.input.isDragging && this.game.input.draggedCards.length > 0) {
                    this.game.input.draggedCards.forEach((card, index) => {
                        const x = this.game.input.dragCurrentPos.x - this.game.input.dragOffset.x;
                        const y = this.game.input.dragCurrentPos.y - this.game.input.dragOffset.y + index * this.game.constants.FACE_UP_OFFSET;
                        this.drawCard(card, x, y, false, 0.9);
                    });
                }
            }
            
            drawCard(card, x, y, highlighted = false, alpha = 1, isHovered = false) {
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                
                const shadowOffset = isHovered ? 4 : 2;
                const shadowAlpha = isHovered ? 0.4 : 0.3;
                this.ctx.fillStyle = `rgba(0,0,0,${shadowAlpha})`;
                this.ctx.fillRect(x + shadowOffset, y + shadowOffset, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                
                if (highlighted) {
                    this.ctx.strokeStyle = '#ffd700';
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeRect(x - 2, y - 2, this.game.constants.CARD_WIDTH + 4, this.game.constants.CARD_HEIGHT + 4);
                }
                
                if (isHovered && !this.game.input.isDragging) {
                    this.ctx.strokeStyle = '#4ade80';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x - 1, y - 1, this.game.constants.CARD_WIDTH + 2, this.game.constants.CARD_HEIGHT + 2);
                }
                
                if (card.faceUp) {
                    const gradient = this.ctx.createLinearGradient(x, y, x, y + this.game.constants.CARD_HEIGHT);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.1, '#f8f9fa');
                    gradient.addColorStop(0.9, '#e9ecef');
                    gradient.addColorStop(1, '#dee2e6');
                    this.ctx.fillStyle = gradient;
                } else {
                    const gradient = this.ctx.createRadialGradient(
                        x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2, 0,
                        x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2, Math.max(this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT)/2
                    );
                    gradient.addColorStop(0, '#3b82f6');
                    gradient.addColorStop(0.7, '#2563eb');
                    gradient.addColorStop(1, '#1e40af');
                    this.ctx.fillStyle = gradient;
                }
                
                this.ctx.fillRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                
                this.ctx.strokeStyle = isHovered ? '#22c55e' : '#374151';
                this.ctx.lineWidth = isHovered ? 2.5 : 2;
                this.ctx.strokeRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                
                if (card.faceUp) {
                    const isRed = this.game.constants.RED_SUITS.has(card.suit);
                    this.ctx.fillStyle = isRed ? '#dc2626' : '#000000';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    
                    this.ctx.fillText(card.rank, x + 4, y + 4);
                    this.ctx.fillText(card.suit, x + 4, y + 20);
                    
                    this.ctx.save();
                    this.ctx.translate(x + this.game.constants.CARD_WIDTH - 4, y + this.game.constants.CARD_HEIGHT - 4);
                    this.ctx.rotate(Math.PI);
                    this.ctx.fillText(card.rank, 0, 0);
                    this.ctx.fillText(card.suit, 0, 16);
                    this.ctx.restore();
                    
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    this.ctx.fillText(card.suit, x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2);
                    
                } else {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.globalAlpha = 0.3 * alpha;
                    
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 6; j++) {
                            const patternX = x + 8 + i * 18;
                            const patternY = y + 8 + j * 18;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(patternX, patternY, 4, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            this.ctx.beginPath();
                            this.ctx.arc(patternX + 9, patternY + 9, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 0.4 * alpha;
                    this.ctx.strokeRect(x + 6, y + 6, this.game.constants.CARD_WIDTH - 12, this.game.constants.CARD_HEIGHT - 12);
                }
                
                this.ctx.restore();
            }
            
            getCardAt(x, y) {
                let bestCard = null;
                let bestZ = -1;
                
                for (const [cardId, info] of this.cardPositions.entries()) {
                    if (x >= info.x && x < info.x + info.width && 
                        y >= info.y && y < info.y + info.height) {
                        
                        let zOrder = 0;
                        
                        if (info.location === 'stock') {
                            zOrder = 1000;
                        } else if (info.location === 'waste') {
                            zOrder = 900 + (info.stackIndex || 0);
                        } else if (info.location === 'foundation') {
                            zOrder = 800;
                        } else if (info.location === 'tableau') {
                            if (!info.card.faceUp) continue;
                            
                            zOrder = 100 + info.cardIndex;
                            const pile = this.game.state.tableau[info.pileIndex];
                            const isTopCard = info.cardIndex === pile.length - 1;
                            
                            if (isTopCard) {
                                zOrder += 100;
                            } else {
                                const nextCard = pile[info.cardIndex + 1];
                                if (nextCard) {
                                    const visibleHeight = nextCard.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET;
                                    if (y > info.y + visibleHeight) {
                                        zOrder -= 20;
                                    }
                                }
                            }
                        }
                        
                        if (zOrder > bestZ) {
                            bestZ = zOrder;
                            bestCard = info;
                        }
                    }
                }
                
                return bestCard;
            }
            
            getDropZoneAt(x, y) {
                for (const zone of this.validDropZones) {
                    if (x >= zone.x && x < zone.x + zone.width &&
                        y >= zone.y && y < zone.y + zone.height) {
                        return zone;
                    }
                }
                return null;
            }
            
            isValidFoundationDrop(suit) {
                return this.game.input.isValidFoundationDrop(suit);
            }
            
            isValidTableauDrop(pileIndex) {
                return this.game.input.isValidTableauDrop(pileIndex);
            }
        }

        // Advanced Intelligent ML Manager with Complete Board Vision and Learning
        class MLManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.isInitialized = false;
                this.isDisposed = false;
                this.fallbackMode = false;
                
                class LearningDB {
                  constructor() {
                   this.dbPromise = new Promise((resolve, reject) => {
                      const req = indexedDB.open('KlondikeLearning', 1);
                      req.onupgradeneeded = (event) => {
                         const db = event.target.result;
                         if (!db.objectStoreNames.contains('games')) {
                           db.createObjectStore('games', { keyPath: 'timestamp' });
                     }
                 };
                 req.onsuccess = () => resolve(req.result);
                  req.onerror = () => reject(req.error);
                 });
             }

                  async saveGameRecord(gameRecord) {
                     const db = await this.dbPromise;
                     const tx = db.transaction('games', 'readwrite');
                      tx.objectStore('games').put(gameRecord);
                      return tx.complete;
                  }

                 async getAllGameRecords() {
                     const db = await this.dbPromise;
                     const tx = db.transaction('games', 'readonly');
                      return tx.objectStore('games').getAll();
                 }
            }


                // Advanced learning and memory systems
                this.gameMemory = {
                    winningGames: [], // Complete games that resulted in wins
                    losingGames: [], // Games that were lost or abandoned
                    moveOutcomes: new Map(), // Move -> success rate mapping
                    positionEvaluations: new Map(), // Game state -> win probability
                    sequencePatterns: new Map(), // Successful move sequences
                    cardMemory: new Map(), // Hidden card location tracking
                    stockDrawingPatterns: new Map() // Optimal stock drawing strategies
                };
                
                // Neural network simulation with weights
                this.neuralWeights = {
                    foundationValue: 10.0,
                    sequenceValue: 8.0,
                    revealValue: 7.0,
                    emptySpaceValue: 6.0,
                    kingPlacementValue: 5.0,
                    stockEfficiency: 4.0,
                    riskMitigation: 3.0
                };
                
                // Complete board vision tracking
                this.completeBoard = {
                    allCards: new Map(), // cardId -> current location and properties
                    hiddenCards: new Map(), // location -> card for face-down cards
                    stockOrder: [], // exact order of cards in stock
                    futureStockCards: [] // cards that will come up in stock
                };
                
                // Web AI integration capabilities
                this.webAIEnabled = false;
                this.lastWebAIQuery = 0;
                this.webAICache = new Map();
                
                this.initializeAdvancedAI();
            }
            
            async initializeAdvancedAI() {
                try {
                    this.isInitialized = true;
                    
                    // Load existing learning data
                    await this.loadLearningData();
                    
                    // Initialize complete board tracking
                    this.initializeCompleteBoard();
                    
                    // Check for web AI capabilities
                    this.checkWebAIAvailability();
                    
                    console.log('üß† Advanced AI System initialized with complete board vision and learning');
                    console.log(`üìö Loaded: ${this.gameMemory.winningGames.length} winning games, ${this.gameMemory.moveOutcomes.size} move patterns`);
                    
                    // Show initialization status
                    setTimeout(() => {
                        if (this.game.ui) {
                            this.game.ui.showNotification(
                                `üß† Advanced AI Online! Features: Complete board vision, learning from ${this.gameMemory.winningGames.length} wins, strategic analysis`,
                                'info', 4000
                            );
                        }
                    }, 2000);
                    
                } catch (error) {
                    console.warn('Advanced AI initialization failed, using enhanced mode:', error);
                    this.fallbackMode = true;
                    this.isInitialized = true;
                }
            }
            
            initializeCompleteBoard() {
                // Initialize tracking for all cards in the deck
                this.game.constants.SUITS.forEach(suit => {
                    this.game.constants.RANKS.forEach((rank, index) => {
                        const cardId = `${rank}${suit}`;
                        this.completeBoard.allCards.set(cardId, {
                            id: cardId,
                            suit: suit,
                            rank: rank,
                            value: index + 1,
                            location: 'unknown',
                            visible: false,
                            strategic_value: this.calculateCardStrategicValue(suit, index + 1)
                        });
                    });
                });
            }
            
            // Update complete board vision when game state changes
            updateCompleteBoard(gameState) {
                // Clear current tracking
                this.completeBoard.allCards.forEach(card => {
                    card.location = 'unknown';
                    card.visible = false;
                });
                
                // Track visible cards
                gameState.waste.forEach((card, index) => {
                    const cardInfo = this.completeBoard.allCards.get(card.id);
                    if (cardInfo) {
                        cardInfo.location = 'waste';
                        cardInfo.position = index;
                        cardInfo.visible = true;
                    }
                });
                
                Object.entries(gameState.foundations).forEach(([suit, pile]) => {
                    pile.forEach((card, index) => {
                        const cardInfo = this.completeBoard.allCards.get(card.id);
                        if (cardInfo) {
                            cardInfo.location = `foundation-${suit}`;
                            cardInfo.position = index;
                            cardInfo.visible = true;
                        }
                    });
                });
                
                gameState.tableau.forEach((pile, pileIndex) => {
                    pile.forEach((card, cardIndex) => {
                        const cardInfo = this.completeBoard.allCards.get(card.id);
                        if (cardInfo) {
                            cardInfo.location = `tableau-${pileIndex}`;
                            cardInfo.position = cardIndex;
                            cardInfo.visible = card.faceUp;
                            cardInfo.faceUp = card.faceUp;
                            
                            // AI can "see" face-down cards for strategic planning
                            if (!card.faceUp) {
                                this.completeBoard.hiddenCards.set(`tableau-${pileIndex}-${cardIndex}`, card);
                            }
                        }
                    });
                });
                
                // Track stock cards (AI knows the order)
                this.completeBoard.stockOrder = [...gameState.stock];
                this.completeBoard.futureStockCards = gameState.stock.slice(-6); // Next 6 cards
            }
            
            calculateCardStrategicValue(suit, value) {
                let strategicValue = value;
                
                // Aces are highly valuable
                if (value === 1) strategicValue += 10;
                
                // Kings are valuable for empty spaces
                if (value === 13) strategicValue += 5;
                
                // Face cards have higher value
                if (value >= 11) strategicValue += 3;
                
                // Red and black suit balance
                const isRed = this.game.constants.RED_SUITS.has(suit);
                strategicValue += isRed ? 1 : 2; // Slight preference for black cards
                
                return strategicValue;
            }
            
            // Advanced move evaluation with complete board knowledge
            async evaluateMove(move, gameState) {
                this.updateCompleteBoard(gameState);
                
                let score = 0;
                let confidence = 0.5;
                let strategicReasoning = [];
                
                // Base move value
                score += move.priority || 0;
                
                // Foundation moves are always valuable
                if (move.type === 'foundation') {
                    score += this.neuralWeights.foundationValue;
                    confidence += 0.3;
                    strategicReasoning.push('Foundation building increases win probability');
                    
                    // Bonus for balanced foundation building
                    const foundations = Object.values(gameState.foundations);
                    const heights = foundations.map(pile => pile.length);
                    const maxHeight = Math.max(...heights);
                    const minHeight = Math.min(...heights);
                    if (maxHeight - minHeight <= 2) {
                        score += 3;
                        strategicReasoning.push('Maintains balanced foundation building');
                    }
                }
                
                // Sequence building evaluation with lookahead
                if (move.type === 'tableau' || move.type === 'waste-to-tableau') {
                    const sequenceValue = this.evaluateSequenceBuilding(move, gameState);
                    score += sequenceValue * this.neuralWeights.sequenceValue;
                    if (sequenceValue > 0.5) {
                        confidence += 0.2;
                        strategicReasoning.push('Creates beneficial card sequences');
                    }
                }
                
                // Card reveal evaluation with hidden knowledge
                const revealValue = this.evaluateCardReveal(move, gameState);
                if (revealValue > 0) {
                    score += revealValue * this.neuralWeights.revealValue;
                    confidence += 0.15;
                    strategicReasoning.push(`Will reveal ${revealValue > 5 ? 'high-value' : 'useful'} hidden card`);
                }
                
                // Empty space utilization
                const emptySpaceValue = this.evaluateEmptySpaceUse(move, gameState);
                if (emptySpaceValue > 0) {
                    score += emptySpaceValue * this.neuralWeights.emptySpaceValue;
                    strategicReasoning.push('Optimizes empty space usage');
                }
                
                // Risk assessment with complete board vision
                const riskAssessment = this.assessMoveRisk(move, gameState);
                score -= riskAssessment.risk * this.neuralWeights.riskMitigation;
                if (riskAssessment.risk > 0.3) {
                    confidence -= 0.1;
                    strategicReasoning.push(`Risk: ${riskAssessment.reason}`);
                }
                
                // Learning from historical data
                const historicalValue = this.getHistoricalMoveValue(move, gameState);
                score += historicalValue * 2;
                if (historicalValue > 0.5) {
                    confidence += 0.1;
                    strategicReasoning.push('Historically successful move pattern');
                }
                
                // Future planning with stock knowledge
                const futureValue = this.evaluateFuturePlanning(move, gameState);
                score += futureValue;
                
                return {
                    ...move,
                    aiScore: Math.max(0, score),
                    confidence: Math.min(0.95, confidence),
                    strategicReasoning: strategicReasoning,
                    futureValue: futureValue,
                    riskAssessment: riskAssessment
                };
            }
            
            evaluateSequenceBuilding(move, gameState) {
                let value = 0;
                
                if (move.card) {
                    // Check if this move creates or extends valuable sequences
                    const cardValue = move.card.value;
                    const cardSuit = move.card.suit;
                    const isRed = this.game.constants.RED_SUITS.has(cardSuit);
                    
                    // Look for cards that can build on this move
                    for (const [cardId, cardInfo] of this.completeBoard.allCards.entries()) {
                        if (cardInfo.value === cardValue - 1 && 
                            this.game.constants.RED_SUITS.has(cardInfo.suit) !== isRed) {
                            if (cardInfo.visible || this.canRevealSoon(cardInfo)) {
                                value += 2;
                            }
                        }
                    }
                    
                    // Check for long sequence potential
                    let sequenceLength = 1;
                    for (let i = 1; i < 7; i++) {
                        const nextValue = cardValue - i;
                        if (nextValue < 1) break;
                        
                        const hasNextCard = Array.from(this.completeBoard.allCards.values()).some(card => 
                            card.value === nextValue && 
                            this.game.constants.RED_SUITS.has(card.suit) !== isRed &&
                            (card.visible || this.canRevealSoon(card))
                        );
                        
                        if (hasNextCard) {
                            sequenceLength++;
                            value += 1;
                        } else {
                            break;
                        }
                    }
                    
                    // Bonus for long sequences
                    if (sequenceLength >= 4) value += 3;
                    if (sequenceLength >= 6) value += 5;
                }
                
                return value;
            }
            
            evaluateCardReveal(move, gameState) {
                let value = 0;
                
                // Check if this move will reveal a hidden card
                if (move.type === 'tableau' || move.type === 'foundation') {
                    const cardLocation = this.game.cards.findCardLocation(move.card);
                    if (cardLocation && cardLocation.type === 'tableau') {
                        const pile = gameState.tableau[cardLocation.pileIndex];
                        const cardIndex = cardLocation.cardIndex;
                        
                        if (cardIndex > 0 && !pile[cardIndex - 1].faceUp) {
                            const hiddenCard = pile[cardIndex - 1];
                            
                            // AI knows what the hidden card is
                            value += hiddenCard.value; // Base value
                            
                            // Bonus for high-value cards
                            if (hiddenCard.value === 1) value += 8; // Aces
                            if (hiddenCard.value === 13) value += 6; // Kings
                            if (hiddenCard.value >= 11) value += 4; // Face cards
                            
                            // Check if revealed card will create immediate opportunities
                            const immediateUse = this.canUseCardImmediately(hiddenCard, gameState);
                            if (immediateUse) value += 5;
                        }
                    }
                }
                
                return value;
            }
            
            evaluateEmptySpaceUse(move, gameState) {
                let value = 0;
                
                if (move.type === 'tableau' && move.targetPileIndex !== undefined) {
                    const targetPile = gameState.tableau[move.targetPileIndex];
                    if (targetPile.length === 0 && move.card && move.card.value === 13) {
                        // King to empty space
                        value = 3;
                        
                        // Check if this king placement unlocks valuable cards
                        const sourceLocation = this.game.cards.findCardLocation(move.card);
                        if (sourceLocation && sourceLocation.type === 'tableau') {
                            const sourcePile = gameState.tableau[sourceLocation.pileIndex];
                            const unlockedCards = sourcePile.slice(0, sourceLocation.cardIndex);
                            value += unlockedCards.filter(card => !card.faceUp).length * 2;
                        }
                    }
                }
                
                return value;
            }
            
            assessMoveRisk(move, gameState) {
                let risk = 0;
                let reason = '';
                
                // Risk of moving from foundation
                if (move.type === 'foundation-to-tableau') {
                    risk += 0.4;
                    reason = 'Moving from foundation is risky';
                }
                
                // Risk of placing King on empty space without good reason
                if (move.card && move.card.value === 13 && move.type === 'tableau') {
                    const targetPile = gameState.tableau[move.targetPileIndex];
                    if (targetPile.length === 0) {
                        const emptySpaces = gameState.tableau.filter(pile => pile.length === 0).length;
                        if (emptySpaces === 1) { // Last empty space
                            risk += 0.3;
                            reason = 'Using last empty space without clear benefit';
                        }
                    }
                }
                
                // Risk assessment based on game progress
                const foundationProgress = Object.values(gameState.foundations).reduce((sum, pile) => sum + pile.length, 0) / 52;
                if (foundationProgress < 0.3 && move.type === 'foundation-to-tableau') {
                    risk += 0.5;
                    reason = 'Too early to move from foundation';
                }
                
                return { risk, reason };
            }
            
            getHistoricalMoveValue(move, gameState) {
                const gameStateHash = this.hashGameState(gameState);
                const movePattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                
                // Check if this move pattern has been successful before
                if (this.gameMemory.moveOutcomes.has(movePattern)) {
                    const outcome = this.gameMemory.moveOutcomes.get(movePattern);
                    return outcome.successRate || 0;
                }
                
                // Check similar game states
                for (const [stateHash, evaluation] of this.gameMemory.positionEvaluations.entries()) {
                    if (this.calculateStateSimilarity(gameStateHash, stateHash) > 0.8) {
                        return evaluation.bestMoveValue || 0;
                    }
                }
                
                return 0;
            }
            
            evaluateFuturePlanning(move, gameState) {
                let value = 0;
                
                // Use stock knowledge to plan ahead
                const upcomingCards = this.completeBoard.futureStockCards;
                
                upcomingCards.forEach((card, index) => {
                    // Check if this move sets up future opportunities
                    if (this.moveCreatesOpportunityFor(move, card)) {
                        value += (6 - index) * 0.5; // Earlier cards are more valuable
                    }
                });
                
                return value;
            }
            
            // Stock drawing recommendation system
            async recommendStockDrawing(gameState) {
                this.updateCompleteBoard(gameState);
                
                if (gameState.stock.length === 0) {
                    return {
                        shouldDraw: false,
                        reason: 'Stock is empty',
                        recommendation: 'Cycle through waste pile or focus on tableau moves'
                    };
                }
                
                const upcomingCards = this.completeBoard.futureStockCards;
                const currentMoves = this.game.ai.findAllPossibleMoves();
                
                // Analyze next few stock cards
                let drawValue = 0;
                let immediateUseCards = 0;
                let valuableCards = 0;
                
                upcomingCards.slice(0, gameState.drawMode).forEach(card => {
                    // Check if card can be used immediately
                    if (this.canUseCardImmediately(card, gameState)) {
                        immediateUseCards++;
                        drawValue += 5;
                    }
                    
                    // Check strategic value
                    if (card.value === 1 || card.value === 13 || card.value >= 11) {
                        valuableCards++;
                        drawValue += 2;
                    }
                    
                    // Check if card helps with foundation building
                    if (this.helpsFoundationBuilding(card, gameState)) {
                        drawValue += 3;
                    }
                });
                
                // Decision logic
                let shouldDraw = false;
                let reason = '';
                
                if (currentMoves.length === 0) {
                    shouldDraw = true;
                    reason = 'No current moves available';
                } else if (immediateUseCards > 0) {
                    shouldDraw = true;
                    reason = `${immediateUseCards} immediately useful card(s) coming up`;
                } else if (drawValue >= 5) {
                    shouldDraw = true;
                    reason = `${valuableCards} valuable card(s) in next draw`;
                } else if (currentMoves.length < 2 && drawValue >= 3) {
                    shouldDraw = true;
                    reason = 'Limited current options, decent cards coming';
                } else {
                    shouldDraw = false;
                    reason = 'Better to play current available moves first';
                }
                
                return {
                    shouldDraw,
                    reason,
                    drawValue,
                    immediateUseCards,
                    valuableCards,
                    upcomingCards: upcomingCards.slice(0, gameState.drawMode).map(card => `${card.rank}${card.suit}`),
                    recommendation: shouldDraw ? 
                        `Draw ${gameState.drawMode} card(s) from stock` : 
                        'Focus on tableau moves first'
                };
            }
            
            // Web AI integration for enhanced intelligence
            async consultWebAI(gameState, question) {
                if (!this.webAIEnabled || Date.now() - this.lastWebAIQuery < 5000) {
                    return null; // Rate limiting
                }
                
                try {
                    const cacheKey = this.hashGameState(gameState) + question;
                    if (this.webAICache.has(cacheKey)) {
                        return this.webAICache.get(cacheKey);
                    }
                    
                    // Prepare game state for web AI
                    const gameDescription = this.prepareGameStateForWebAI(gameState);
                    
                    // This would connect to external AI services
                    // For now, we'll simulate advanced analysis
                    const webAIResponse = await this.simulateWebAIResponse(gameDescription, question);
                    
                    this.webAICache.set(cacheKey, webAIResponse);
                    this.lastWebAIQuery = Date.now();
                    
                    return webAIResponse;
                } catch (error) {
                    console.warn('Web AI consultation failed:', error);
                    return null;
                }
            }
            
            prepareGameStateForWebAI(gameState) {
                return {
                    foundations: Object.entries(gameState.foundations).map(([suit, pile]) => ({
                        suit,
                        count: pile.length,
                        nextNeeded: pile.length + 1
                    })),
                    tableau: gameState.tableau.map((pile, index) => ({
                        pileIndex: index,
                        totalCards: pile.length,
                        faceUpCards: pile.filter(c => c.faceUp).length,
                        topCard: pile.length > 0 ? `${pile[pile.length - 1].rank}${pile[pile.length - 1].suit}` : null,
                        isEmpty: pile.length === 0
                    })),
                    stock: {
                        remaining: gameState.stock.length,
                        drawMode: gameState.drawMode
                    },
                    waste: {
                        count: gameState.waste.length,
                        topCard: gameState.waste.length > 0 ? 
                            `${gameState.waste[gameState.waste.length - 1].rank}${gameState.waste[gameState.waste.length - 1].suit}` : null
                    },
                    gameStats: gameState.gameStats
                };
            }
            
            async simulateWebAIResponse(gameDescription, question) {
                // Simulate advanced AI analysis
                await new Promise(resolve => setTimeout(resolve, 100));
                
                return {
                    confidence: 0.85,
                    recommendation: 'Focus on foundation building while maintaining tableau flexibility',
                    strategicInsights: [
                        'Prioritize revealing face-down cards',
                        'Maintain color balance in tableau sequences',
                        'Use empty spaces strategically for Kings'
                    ],
                    riskAssessment: 'Low risk - good position for steady progress'
                };
            }
            
            checkWebAIAvailability() {
                // Check if we can connect to external AI services
                this.webAIEnabled = false; // Disabled by default for privacy
                
                // Could enable this if user opts in and API keys are available
                if (localStorage.getItem('enableWebAI') === 'true') {
                    this.webAIEnabled = true;
                    console.log('üåê Web AI integration enabled');
                }
            }
            
            // Learning system - record game outcomes
            recordGameOutcome(gameState, moves, won) {
                const gameRecord = {
                    gameState: this.cloneGameState(gameState),
                    moves: [...moves],
                    won: won,
                    timestamp: Date.now(),
                    difficulty: this.calculateGameDifficulty(gameState),
                    finalScore: gameState.gameStats.score,
                    totalTime: gameState.gameStats.time,
                    totalMoves: gameState.gameStats.moves
                };
                
                if (won) {
                    this.gameMemory.winningGames.push(gameRecord);
                    
                    // Update neural weights based on successful strategies
                    this.updateNeuralWeights(gameRecord);
                    
                    // Record successful move patterns
                    this.recordSuccessfulMoves(moves);
                    
                    // Limit memory size
                    if (this.gameMemory.winningGames.length > 100) {
                        this.gameMemory.winningGames.shift();
                    }
                } else {
                    this.gameMemory.losingGames.push(gameRecord);
                    
                    // Learn from failures too
                    this.recordFailedMoves(moves);
                    
                    if (this.gameMemory.losingGames.length > 50) {
                        this.gameMemory.losingGames.shift();
                    }
                }
                
                // Save learning data
                this.saveLearningData();
                
                console.log(`üß† Recorded ${won ? 'winning' : 'losing'} game. Total learning data: ${this.gameMemory.winningGames.length} wins, ${this.gameMemory.moveOutcomes.size} move patterns`);
            }
            
            updateNeuralWeights(winningGame) {
                // Analyze successful game for weight adjustments
                const moves = winningGame.moves;
                const foundationMoves = moves.filter(m => m.type === 'foundation').length;
                const sequenceMoves = moves.filter(m => m.type === 'tableau').length;
                const revealMoves = moves.filter(m => m.willReveal).length;
                
                // Adjust weights based on successful strategies
                if (foundationMoves / moves.length > 0.4) {
                    this.neuralWeights.foundationValue *= 1.05;
                }
                if (sequenceMoves / moves.length > 0.3) {
                    this.neuralWeights.sequenceValue *= 1.03;
                }
                if (revealMoves / moves.length > 0.2) {
                    this.neuralWeights.revealValue *= 1.02;
                }
                
                // Normalize weights to prevent runaway growth
                const totalWeight = Object.values(this.neuralWeights).reduce((sum, w) => sum + w, 0);
                if (totalWeight > 60) {
                    Object.keys(this.neuralWeights).forEach(key => {
                        this.neuralWeights[key] *= 0.95;
                    });
                }
            }
            
            recordSuccessfulMoves(moves) {
                moves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    
                    if (!this.gameMemory.moveOutcomes.has(pattern)) {
                        this.gameMemory.moveOutcomes.set(pattern, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    outcome.successes++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                    
                    // Record move sequences
                    if (moves.length >= 3) {
                        const sequence = moves.slice(0, 3).map(m => `${m.type}-${m.card?.value}`).join('->');
                        if (!this.gameMemory.sequencePatterns.has(sequence)) {
                            this.gameMemory.sequencePatterns.set(sequence, 0);
                        }
                        this.gameMemory.sequencePatterns.set(sequence, this.gameMemory.sequencePatterns.get(sequence) + 1);
                    }
                });
            }
            
            recordFailedMoves(moves) {
                moves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    
                    if (!this.gameMemory.moveOutcomes.has(pattern)) {
                        this.gameMemory.moveOutcomes.set(pattern, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    outcome.failures++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            // Enhanced game analysis with complete intelligence
            async getGameAnalysis(gameState) {
                try {
                    this.updateCompleteBoard(gameState);
                    
                    // Multi-layered analysis
                    const basicAnalysis = this.performBasicAnalysis(gameState);
                    const strategicAnalysis = this.performStrategicAnalysis(gameState);
                    const learningAnalysis = this.performLearningAnalysis(gameState);
                    const stockAnalysis = await this.recommendStockDrawing(gameState);
                    
                    // Web AI consultation if enabled
                    let webAIInsights = null;
                    if (this.webAIEnabled) {
                        webAIInsights = await this.consultWebAI(gameState, 'strategic_analysis');
                    }
                    
                    return {
                        winProbability: this.calculateWinProbability(gameState, strategicAnalysis),
                        difficulty: strategicAnalysis.difficulty,
                        recommendation: this.generateAdvancedRecommendation(basicAnalysis, strategicAnalysis, learningAnalysis),
                        stockRecommendation: stockAnalysis,
                        strategicInsights: strategicAnalysis.insights,
                        hiddenCardInsights: this.analyzeHiddenCards(gameState),
                        learningInsights: learningAnalysis,
                        webAIInsights: webAIInsights,
                        neuralWeights: { ...this.neuralWeights }
                    };
                } catch (error) {
                    console.error('Advanced game analysis error:', error);
                    return this.getFallbackAnalysis(gameState);
                }
            }
            
            performBasicAnalysis(gameState) {
                const foundationCards = Object.values(gameState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                const foundationProgress = foundationCards / 52;
                const faceUpCards = gameState.tableau.reduce((sum, pile) => sum + pile.filter(c => c.faceUp).length, 0);
                const emptySpaces = gameState.tableau.filter(pile => pile.length === 0).length;
                const blockedCards = gameState.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0);
                
                return {
                    foundationProgress,
                    faceUpCards,
                    emptySpaces,
                    blockedCards,
                    stockRemaining: gameState.stock.length,
                    wasteSize: gameState.waste.length
                };
            }
            
            performStrategicAnalysis(gameState) {
                const insights = [];
                let difficulty = 'medium';
                let strategicValue = 0;
                
                // Analyze foundation balance
                const foundations = Object.values(gameState.foundations).map(pile => pile.length);
                const maxFoundation = Math.max(...foundations);
                const minFoundation = Math.min(...foundations);
                const foundationGap = maxFoundation - minFoundation;
                
                if (foundationGap <= 1) {
                    insights.push('Excellent foundation balance maintained');
                    strategicValue += 3;
                } else if (foundationGap >= 4) {
                    insights.push('Foundation imbalance detected - focus on lagging suits');
                    strategicValue -= 2;
                }
                
                // Analyze sequence opportunities with complete board vision
                let longSequences = 0;
                gameState.tableau.forEach(pile => {
                    let currentSequence = 0;
                    for (let i = pile.length - 1; i > 0; i--) {
                        if (pile[i].faceUp && pile[i-1].faceUp &&
                            pile[i-1].value === pile[i].value + 1 &&
                            this.game.constants.RED_SUITS.has(pile[i-1].suit) !== this.game.constants.RED_SUITS.has(pile[i].suit)) {
                            currentSequence++;
                        } else {
                            break;
                        }
                    }
                    if (currentSequence >= 3) longSequences++;
                });
                
                if (longSequences >= 2) {
                    insights.push('Multiple long sequences available for strategic moves');
                    strategicValue += 2;
                }
                
                // Analyze hidden card potential
                const hiddenHighValue = this.countHiddenHighValueCards(gameState);
                if (hiddenHighValue.aces > 0) {
                    insights.push(`${hiddenHighValue.aces} hidden Ace(s) - prioritize revealing them`);
                }
                if (hiddenHighValue.kings > 0 && gameState.tableau.filter(pile => pile.length === 0).length > 0) {
                    insights.push(`${hiddenHighValue.kings} hidden King(s) available for empty spaces`);
                }
                
                // Calculate difficulty
                const complexityScore = (
                    gameState.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0) * 0.1 +
                    foundationGap * 0.2 +
                    (24 - gameState.stock.length) * 0.05
                );
                
                if (complexityScore < 2) difficulty = 'easy';
                else if (complexityScore < 4) difficulty = 'medium';
                else if (complexityScore < 6) difficulty = 'hard';
                else difficulty = 'expert';
                
                return {
                    insights,
                    difficulty,
                    strategicValue,
                    foundationGap,
                    longSequences,
                    complexityScore
                };
            }
            
            performLearningAnalysis(gameState) {
                const insights = [];
                let confidenceBoost = 0;
                
                // Check against successful game patterns
                const currentStateHash = this.hashGameState(gameState);
                let similarWinningGames = 0;
                
                this.gameMemory.winningGames.forEach(game => {
                    const similarity = this.calculateStateSimilarity(currentStateHash, this.hashGameState(game.gameState));
                    if (similarity > 0.7) {
                        similarWinningGames++;
                    }
                });
                
                if (similarWinningGames > 0) {
                    insights.push(`Similar to ${similarWinningGames} previously won game(s)`);
                    confidenceBoost += 0.2;
                }
                
                // Check move success patterns
                const availableMoves = this.game.ai.findAllPossibleMoves();
                let historicallySuccessfulMoves = 0;
                
                availableMoves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    if (outcome && outcome.successRate > 0.6) {
                        historicallySuccessfulMoves++;
                    }
                });
                
                if (historicallySuccessfulMoves > 0) {
                    insights.push(`${historicallySuccessfulMoves} historically successful move(s) available`);
                    confidenceBoost += 0.1;
                }
                
                return {
                    insights,
                    confidenceBoost,
                    similarWinningGames,
                    historicallySuccessfulMoves,
                    totalLearningData: this.gameMemory.winningGames.length
                };
            }
            
            calculateWinProbability(gameState, strategicAnalysis) {
                const basic = this.performBasicAnalysis(gameState);
                
                let winProb = 0.3; // Base probability
                
                // Foundation progress (40% weight)
                winProb += basic.foundationProgress * 0.4;
                
                // Face-up card ratio (20% weight)
                winProb += (basic.faceUpCards / 28) * 0.2;
                
                // Strategic factors (25% weight)
                winProb += Math.max(0, strategicAnalysis.strategicValue / 10) * 0.25;
                
                // Learning boost (10% weight)
                const learningAnalysis = this.performLearningAnalysis(gameState);
                winProb += learningAnalysis.confidenceBoost * 0.1;
                
                // Stock efficiency (5% weight)
                winProb += (1 - basic.stockRemaining / 24) * 0.05;
                
                return Math.min(0.95, Math.max(0.05, winProb));
            }
            
            generateAdvancedRecommendation(basicAnalysis, strategicAnalysis, learningAnalysis) {
                const foundationProgress = basicAnalysis.foundationProgress;
                const insights = [...strategicAnalysis.insights, ...learningAnalysis.insights];
                
                if (foundationProgress > 0.8) {
                    return `üèÜ Victory is near! ${insights[0] || 'Focus on final foundation moves.'}`;
                } else if (foundationProgress > 0.6) {
                    return `üí™ Strong position! ${insights[0] || 'Maintain strategic pressure on foundations.'}`;
                } else if (foundationProgress > 0.4) {
                    return `üéØ Good progress! ${insights[0] || 'Continue revealing cards and building sequences.'}`;
                } else if (strategicAnalysis.longSequences > 0) {
                    return `üîÑ Strategic opportunity! ${insights[0] || 'Use long sequences to create foundation opportunities.'}`;
                } else {
                    return `üß† Challenging position! ${insights[0] || 'Focus on revealing hidden cards and creating space.'}`;
                }
            }
            
            analyzeHiddenCards(gameState) {
                const hiddenInsights = [];
                let totalHiddenValue = 0;
                
                gameState.tableau.forEach((pile, pileIndex) => {
                    pile.forEach((card, cardIndex) => {
                        if (!card.faceUp) {
                            const strategicValue = this.calculateCardStrategicValue(card.suit, card.value);
                            totalHiddenValue += strategicValue;
                            
                            // AI knows what the hidden cards are
                            if (card.value === 1) {
                                hiddenInsights.push(`Hidden Ace of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            } else if (card.value === 13) {
                                hiddenInsights.push(`Hidden King of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            } else if (card.value >= 11) {
                                hiddenInsights.push(`Hidden ${card.rank} of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            }
                        }
                    });
                });
                
                return {
                    insights: hiddenInsights,
                    totalValue: totalHiddenValue,
                    count: hiddenInsights.length
                };
            }
            
            // Helper methods
            canRevealSoon(cardInfo) {
                if (cardInfo.location.startsWith('tableau-')) {
                    const pileIndex = parseInt(cardInfo.location.split('-')[1]);
                    const pile = this.game.state.tableau[pileIndex];
                    return cardInfo.position >= pile.length - 3; // Within 3 moves of top
                }
                return false;
            }
            
            canUseCardImmediately(card, gameState) {
                // Check if card can go to foundation
                if (this.game.rules.canPlaceOnFoundation(card)) {
                    return true;
                }
                
                // Check if card can go to tableau
                for (const pile of gameState.tableau) {
                    if (this.game.rules.canPlaceOnTableau(card, pile)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            helpsFoundationBuilding(card, gameState) {
                const foundationPile = gameState.foundations[card.suit];
                const nextNeeded = foundationPile.length + 1;
                return card.value === nextNeeded;
            }
            
            moveCreatesOpportunityFor(move, futureCard) {
                // Check if the current move creates space or sequences for future card
                if (move.type === 'foundation' && futureCard.value === 1) {
                    return true; // Foundation moves create space for Aces
                }
                
                if (move.type === 'tableau' && move.card && futureCard.value === move.card.value - 1) {
                    const moveCardIsRed = this.game.constants.RED_SUITS.has(move.card.suit);
                    const futureCardIsRed = this.game.constants.RED_SUITS.has(futureCard.suit);
                    return moveCardIsRed !== futureCardIsRed; // Alternating colors
                }
                
                return false;
            }
            
            countHiddenHighValueCards(gameState) {
                let aces = 0, kings = 0, faces = 0;
                
                gameState.tableau.forEach(pile => {
                    pile.forEach(card => {
                        if (!card.faceUp) {
                            if (card.value === 1) aces++;
                            else if (card.value === 13) kings++;
                            else if (card.value >= 11) faces++;
                        }
                    });
                });
                
                return { aces, kings, faces };
            }
            
            cloneGameState(gameState) {
             // Only include the deck arrays, foundations, and gameStats‚Äîomit 'game' and other managers
                 return {
                     stock: gameState.stock.map(card => ({ id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp })),
                     waste: gameState.waste.map(card => ({ id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp })),
                      tableau: gameState.tableau.map(pile =>
                       pile.map(card => ({ id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp }))
                     ),
                     foundations: Object.fromEntries(
                      Object.entries(gameState.foundations).map(([suit, pile]) =>
                       [suit, pile.map(card => ({ id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp }))]
                    )
                ),
                gameStats: { moves: gameState.gameStats.moves, time: gameState.gameStats.time, score: gameState.gameStats.score }
             };
            }
            
            hashGameState(gameState) {
                const state = {
                    foundations: Object.entries(gameState.foundations).map(([suit, pile]) => `${suit}:${pile.length}`),
                    tableau: gameState.tableau.map(pile => pile.length),
                    stock: gameState.stock.length,
                    waste: gameState.waste.length
                };
                return JSON.stringify(state);
            }
            
            calculateStateSimilarity(state1Hash, state2Hash) {
                // Simple similarity calculation - could be more sophisticated
                return state1Hash === state2Hash ? 1.0 : 0.5;
            }
            
            calculateGameDifficulty(gameState) {
                const hiddenCards = gameState.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0);
                const foundationProgress = Object.values(gameState.foundations).reduce((sum, pile) => sum + pile.length, 0) / 52;
                
                if (hiddenCards <= 5 && foundationProgress > 0.5) return 'easy';
                if (hiddenCards <= 15 && foundationProgress > 0.2) return 'medium';
                if (hiddenCards <= 21) return 'hard';
                return 'expert';
            }
            
            getFallbackAnalysis(gameState) {
                const basic = this.performBasicAnalysis(gameState);
                return {
                    winProbability: basic.foundationProgress * 0.6 + 0.3,
                    difficulty: 'medium',
                    recommendation: 'Continue playing strategically',
                    stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                };
            }
            
            // Data persistence
            async saveLearningData() {
                try {
                    const learningData = {
                        gameMemory: {
                            winningGames: this.gameMemory.winningGames.slice(-50), // Keep last 50
                            moveOutcomes: Array.from(this.gameMemory.moveOutcomes.entries()),
                            sequencePatterns: Array.from(this.gameMemory.sequencePatterns.entries())
                        },
                        neuralWeights: this.neuralWeights,
                        version: '2.0',
                        timestamp: Date.now()
                    };
                    
                    this.game.storage.set('advanced_ml_learning_data', learningData);
                } catch (error) {
                    console.warn('Failed to save learning data:', error);
                }
            }
            
            async loadLearningData() {
                try {
                    const saved = this.game.storage.get('advanced_ml_learning_data');
                    if (saved && saved.version === '2.0') {
                        this.gameMemory.winningGames = saved.gameMemory.winningGames || [];
                        this.gameMemory.moveOutcomes = new Map(saved.gameMemory.moveOutcomes || []);
                        this.gameMemory.sequencePatterns = new Map(saved.gameMemory.sequencePatterns || []);
                        this.neuralWeights = { ...this.neuralWeights, ...saved.neuralWeights };
                        
                        console.log(`üß† Loaded learning data: ${this.gameMemory.winningGames.length} games, ${this.gameMemory.moveOutcomes.size} patterns`);
                    }
                } catch (error) {
                    console.warn('Failed to load learning data:', error);
                }
            }
            
            dispose() {
                this.saveLearningData();
                this.isDisposed = true;
                this.isInitialized = false;
                console.log('üß† Advanced ML resources cleaned up and learning data saved');
            }
        }

        // Initialize the game with better error handling
        let game = null;
        
        function safeGameCall(methodPath, ...args) {
            try {
                if (!window.game) {
                    console.error('Game not initialized');
                    return false;
                }
                
                const pathParts = methodPath.split('.');
                let current = window.game;
                
                for (let i = 0; i < pathParts.length - 1; i++) {
                    if (!current[pathParts[i]]) {
                        console.error(`Game component ${pathParts[i]} not ready`);
                        return false;
                    }
                    current = current[pathParts[i]];
                }
                
                const method = current[pathParts[pathParts.length - 1]];
                if (typeof method !== 'function') {
                    console.error(`Method ${methodPath} not found`);
                    return false;
                }
                
                return method.apply(current, args);
            } catch (error) {
                console.error(`Error calling ${methodPath}:`, error);
                return false;
            }
        }
        
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('üîß SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('‚ùå SW registration failed: ', registrationError);
                    });
            });
        }

        function initializeGame() {
            try {
                console.log('üéÆ Starting game initialization...');
                
                if (typeof KlondikeSolitaire === 'undefined') {
                    throw new Error('KlondikeSolitaire class is not defined');
                }
                
                game = new KlondikeSolitaire();
                window.game = game;
                
                console.log('‚úÖ Klondike Solitaire initialized successfully');
                
                if (game && game.ui && typeof game.ui.showNotification === 'function') {
                    setTimeout(() => {
                        try {
                            game.ui.showNotification('üéÆ Game loaded successfully! Click "AI Hint" to test the enhanced hint system.', 'info', 4000);
                        } catch (notifError) {
                            console.error('Notification test failed:', notifError);
                        }
                    }, 1500);
                }
                
            } catch (error) {
                console.error('‚ùå Failed to initialize game:', error);
                
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #ef4444;
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 400px;
                `;
                errorDiv.innerHTML = `
                    <h3>‚ö†Ô∏è Game Initialization Failed</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #ef4444; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                        üîÑ Refresh Page
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
    </script>
</body>
</html>