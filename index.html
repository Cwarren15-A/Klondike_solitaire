<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Klondike Solitaire - AI Enhanced</title>
    <!-- Cache buster: 2024-12-19-16:00 -->
    <!-- Enhanced graphics deployed - cache refresh required -->
    <meta name="description" content="Play Klondike Solitaire with AI-powered hints, analysis, and adaptive difficulty. Advanced machine learning provides intelligent gameplay assistance.">
    
    <!-- Social Media Meta Tags -->
    <meta property="og:title" content="Klondike Solitaire - AI Enhanced">
    <meta property="og:description" content="Advanced Klondike Solitaire with AI-powered hints, complete board analysis, and machine learning assistance.">
    <meta property="og:image" content="https://raw.githubusercontent.com/yourusername/klondike-solitaire-ai/main/preview.png">
    <meta property="og:url" content="https://yourusername.github.io/klondike-solitaire-ai/">
    <meta property="og:type" content="website">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Klondike Solitaire - AI Enhanced">
    <meta name="twitter:description" content="Advanced Klondike Solitaire with AI-powered hints and machine learning assistance.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/yourusername/klondike-solitaire-ai/main/preview.png">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1e5128">
    <meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Solitaire AI">
    <link rel="apple-touch-icon" href="./public/icons/icon-192.png">
    <link rel="manifest" href="./public/manifest.json">
    
    <!-- Performance and SEO -->
    <meta name="robots" content="index, follow">
    <meta name="author" content="Your Name">
    <meta name="keywords" content="solitaire, klondike, card game, AI, machine learning, hints, analysis, free game">
    <link rel="canonical" href="https://yourusername.github.io/klondike-solitaire-ai/">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.15.0/tf.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-primary, #1e5128), var(--bg-secondary, #2d5016));
            font-family: 'Arial', sans-serif;
            color: var(--text-color, white);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: auto;
            touch-action: none;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        /* Default theme */
        body {
            --bg-primary: #1e5128;
            --bg-secondary: #2d5016;
            --card-color: #ffffff;
            --text-color: white;
        }
        
        .dark-theme {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1a2e;
            --card-color: #ffffff;
            --text-color: white;
        }
        
        .light-theme {
            --bg-primary: #e3f2fd;
            --bg-secondary: #bbdefb;
            --card-color: #333333;
            --text-color: #333333;
        }
        
        .blue-theme {
            --bg-primary: #1e3a8a;
            --bg-secondary: #1e40af;
            --card-color: #ffffff;
            --text-color: white;
        }
        
        /* Phase 2: Performance Monitor Styles */
        .performance-monitor {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #00ff00;
            z-index: 10000;
            display: none;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }
        
        .performance-monitor h4 {
            margin: 0 0 10px 0;
            color: #00ffff;
            text-align: center;
            font-size: 14px;
        }
        
        .performance-metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 2px 0;
        }
        
        .performance-value {
            color: #ffff00;
            font-weight: bold;
        }
        
        .performance-good { color: #00ff00; }
        .performance-warning { color: #ffaa00; }
        .performance-bad { color: #ff0000; }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1000px;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: bold;
            flex-wrap: wrap;
            gap: 10px;
            animation: slideInDown 0.5s ease-out;
        }
        
        @keyframes slideInDown {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideInUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .stats {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 8px;
            min-width: 80px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .stat-label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 14px;
        }
        
        button:focus-visible {
            outline: 2px solid #4ade80;
            outline-offset: 2px;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .btn-blue { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: white; }
        .btn-yellow { background: linear-gradient(135deg, #d97706, #b45309); color: white; }
        .btn-purple { background: linear-gradient(135deg, #7c3aed, #6d28d9); color: white; }
        .btn-green { background: linear-gradient(135deg, #059669, #047857); color: white; }
        .btn-orange { background: linear-gradient(145deg, #f97316, #ea580c); color: white; }
        .btn-red { background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; }
        .btn-gold { background: linear-gradient(135deg, #f59e0b, #fbbf24); color: white; font-weight: bold; }
        .btn-gold:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 8px 20px rgba(245, 158, 11, 0.4); }
        .btn-info { background: linear-gradient(135deg, #0ea5e9, #0284c7); color: white; }
        .btn-info:hover { transform: translateY(-2px) scale(1.05); box-shadow: 0 8px 20px rgba(14, 165, 233, 0.4); }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        #gameCanvas {
            border: 3px solid #4ade80;
            border-radius: 15px;
            background: radial-gradient(ellipse at center, #166534 0%, #14532d 100%);
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            cursor: default;
            display: block;
            animation: slideInUp 0.5s ease-out;
            transition: all 0.3s ease;
            width: 1000px;
            height: 600px;
        }
        
        #gameCanvas:hover {
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        
        .menu {
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            animation: slideInUp 0.6s ease-out;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .menu h1 {
            font-size: clamp(24px, 5vw, 48px);
            margin-bottom: 30px;
            color: #4ade80;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }
        
        .menu button {
            display: block;
            width: min(250px, 80vw);
            margin: 10px auto;
            padding: 15px;
            font-size: 18px;
            transform: translateY(20px);
            animation: slideInUp 0.6s ease-out forwards;
        }
        
        .menu button:nth-child(2) { animation-delay: 0.1s; }
        .menu button:nth-child(3) { animation-delay: 0.2s; }
        .menu button:nth-child(4) { animation-delay: 0.3s; }
        .menu button:nth-child(5) { animation-delay: 0.4s; }
        .menu button:nth-child(6) { animation-delay: 0.5s; }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
            z-index: 2000;
            animation: notificationPop 2s ease-out;
            max-width: 95vw;
            text-align: center;
        }
        
        @keyframes notificationPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
            50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }
        
        .theme-toggle, .sound-toggle {
            position: fixed;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        .theme-toggle {
            top: 20px;
        }
        
        .sound-toggle {
            top: 80px;
            font-size: 20px;
        }
        
        .theme-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(180deg);
        }
        
        .sound-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s ease;
            z-index: 1001;
        }
        
        .difficulty-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            text-transform: uppercase;
        }
        
        .diff-easy { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .diff-medium { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
        .diff-hard { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .diff-expert { background: linear-gradient(135deg, #7c3aed, #6d28d9); color: white; }
        
        /* Deadlock analysis styles */
        .deadlock-analysis {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }
        
        .analysis-item {
            margin: 8px 0;
            font-size: 13px;
        }
        
        .analysis-item.suggestion {
            color: #a78bfa;
            font-style: italic;
            background: rgba(167, 139, 250, 0.1);
            padding: 6px;
            border-radius: 4px;
        }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .game-header {
                font-size: 14px;
                gap: 5px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            .controls {
                gap: 5px;
            }
            
            #gameCanvas {
                border-width: 2px;
                border-radius: 10px;
            }
            
            .theme-toggle, .sound-toggle {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .sound-toggle {
                top: 70px;
            }
            
            .menu {
                padding: 20px;
            }
            
            .stat-item {
                min-width: 60px;
                padding: 6px 8px;
            }
            
            /* Mobile-friendly AI Analysis */
            .hint-notification {
                min-width: auto !important;
                max-width: 95vw !important;
                max-height: 90vh !important;
                padding: 15px 35px 15px 15px !important;
                font-size: 12px !important;
                overflow-y: auto !important;
                top: 5% !important;
                transform: translateX(-50%) !important;
                left: 50% !important;
            }
            
            /* Ensure close button is always visible and clickable */
            .hint-notification .close-btn,
            .notification .close-btn {
                pointer-events: all !important;
                touch-action: manipulation !important;
                z-index: 9999 !important;
                position: absolute !important;
                top: 8px !important;
                right: 8px !important;
                min-width: 32px !important;
                min-height: 32px !important;
            }
        }
        
        .btn-orange:hover:not(:disabled) {
            background: linear-gradient(145deg, #ea580c, #dc2626);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="safeGameCall('ui.toggleTheme')" title="Toggle theme" aria-label="Toggle color theme">🌓</button>
    <button class="sound-toggle" onclick="safeGameCall('ui.toggleSound')" title="Toggle sound" aria-label="Toggle sound effects">🔊</button>
    <div class="progress-bar" id="progressBar"></div>
    
    <div id="menu" class="menu">
        <h1>🃏 Klondike Solitaire</h1>
        <div style="margin-bottom: 20px; font-size: 14px; color: #a78bfa;">
            Enhanced with AI/Machine Learning 🧠
        </div>
        <button class="btn-green" onclick="game.ui.showDailyChallenge()">🏆 Daily Challenge</button>
        <button class="btn-blue" onclick="game.startGame(1)">🎯 Draw 1 Card</button>
        <button class="btn-blue" onclick="game.startGame(3)">🎮 Draw 3 Cards</button>
        <button class="btn-purple" onclick="game.ui.showSettings()">⚙️ Settings</button>
        <button class="btn-yellow" onclick="game.ui.showStats()">📊 Statistics</button>
        <button class="btn-red" onclick="game.ui.showAchievements()">🏅 Achievements</button>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 12px; opacity: 0.7; line-height: 1.4;">
            <strong>🧠 AI Features:</strong><br>
            • Neural network-powered move analysis<br>
            • Intelligent game state evaluation<br>
            • Adaptive difficulty recommendations<br>
            • Works on all devices (CPU-optimized)<br>
            • Learning from your gameplay patterns
        </div>
    </div>
    
    <div id="gameArea" style="display: none;">
        <div class="game-header">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Moves</div>
                    <div class="stat-value" id="moves">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="time">0:00</div>
                </div>
                <div class="stat-item" id="scoreDisplay" style="display: none;">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item" id="winProbDisplay" style="display: none;">
                    <div class="stat-label">Win %</div>
                    <div class="stat-value" id="winProb">0%</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn-blue" onclick="safeGameCall('newGame')" title="Start new game (N)" aria-label="Start new game">🎲 New Game</button>
                <button class="btn-yellow" id="undoBtn" onclick="safeGameCall('undo')" title="Undo last move (U)" aria-label="Undo last move">↶ Undo</button>
                <button class="btn-orange" id="redoBtn" onclick="safeGameCall('redo')" title="Redo last undone move (R)" aria-label="Redo last undone move">↷ Redo</button>
                <button class="btn-purple" onclick="safeGameCall('ai.showHint')" title="Show AI hint (H)" aria-label="Show AI move hint">🧠 AI Hint</button>
                                        <button class="btn-gold" onclick="safeGameCall('ai.autoCompleteGame')" title="AI automatically plays the game to completion" aria-label="Auto-play game">🤖 Auto-Play</button>
                <button class="btn-orange" onclick="safeGameCall('ui.showMLAnalysis')" title="Show ML analysis" aria-label="Show machine learning analysis">📊 AI Analysis</button>
                <button class="btn-green" onclick="safeGameCall('storage.quickSave')" title="Quick save (S)" aria-label="Quick save game">💾 Save</button>
                <!-- Phase 2: Performance Monitor Button -->
                <button class="btn-info" onclick="togglePerformanceMonitor()" title="Show Phase 2 performance metrics" aria-label="Toggle performance monitor">⚡ Performance</button>
                <button class="btn-red" onclick="debugRender()" title="Debug render">🔍 Debug Render</button>
            </div>
        </div>
        <canvas id="gameCanvas" width="1000" height="600" role="application" aria-label="Klondike Solitaire Game Board" tabindex="0"></canvas>
    </div>

    <!-- Phase 2: Performance Monitor -->
    <div id="performanceMonitor" class="performance-monitor">
        <h4>⚡ Phase 2 Performance</h4>
        <div class="performance-metric">
            <span>FPS:</span>
            <span id="fps-value" class="performance-value">60</span>
        </div>
        <div class="performance-metric">
            <span>Render Time:</span>
            <span id="render-time" class="performance-value">0ms</span>
        </div>
        <div class="performance-metric">
            <span>Memory Usage:</span>
            <span id="memory-usage" class="performance-value">0MB</span>
        </div>
        <div class="performance-metric">
            <span>AI Worker:</span>
            <span id="ai-worker-status" class="performance-value">Ready</span>
        </div>
        <div class="performance-metric">
            <span>Animations:</span>
            <span id="animation-count" class="performance-value">0</span>
        </div>
        <div class="performance-metric">
            <span>Cache Size:</span>
            <span id="cache-size" class="performance-value">0</span>
        </div>
    </div>
    
    <!-- Additional menu screens -->
    <div id="dailyChallenge" class="menu" style="display: none;">
        <h1>🏆 Daily Challenge</h1>
        <div id="challengeInfo" style="margin-bottom: 20px; font-size: 16px; line-height: 1.5;"></div>
        <button class="btn-green" id="playDailyBtn" onclick="safeGameCall('startDailyChallenge')">Play Today's Challenge</button>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
    </div>
    
    <div id="settings" class="menu" style="display: none;">
        <h1>⚙️ Settings</h1>
        <div style="text-align: left; max-width: 300px; margin: 0 auto;">
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold;" for="difficultySelect">Difficulty Level:</label>
                <select id="difficultySelect" onchange="safeGameCall('settings.updateDifficulty')" style="width: 100%; padding: 8px; border-radius: 6px; border: 2px solid #374151; font-size: 16px; color: #333;">
                    <option value="easy">Easy - Draw 1</option>
                    <option value="medium">Medium - Draw 3</option>
                    <option value="hard">Hard - Draw 3, Vegas Scoring</option>
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="autoMoveToFoundation" onchange="safeGameCall('settings.updateAutoMove')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Auto-move cards to foundation</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="showMoveHints" onchange="safeGameCall('settings.updateShowHints')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Show valid move hints</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="enableMLAnalysis" onchange="safeGameCall('settings.updateMLAnalysis')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Enable AI/ML analysis 🧠</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="adaptiveDifficulty" onchange="safeGameCall('settings.updateAdaptiveDifficulty')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Adaptive difficulty (AI-powered)</span>
                </label>
            </div>
        </div>
        
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
        <button class="btn-orange" onclick="safeGameCall('settings.resetSettings')">Reset to Defaults</button>
    </div>
    
    <div id="stats" class="menu" style="display: none;">
        <h1>📊 Statistics</h1>
        <div id="statsContent" style="text-align: left; max-width: 400px; margin: 0 auto; font-size: 16px; line-height: 1.6;"></div>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
        <button class="btn-yellow" onclick="safeGameCall('stats.resetStats')">Reset Statistics</button>
    </div>
    
    <div id="achievements" class="menu" style="display: none;">
        <h1>🏅 Achievements</h1>
        <div id="achievementsList" style="text-align: left; max-width: 500px; margin: 0 auto; font-size: 16px;"></div>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
    </div>

    <script>
        'use strict';

        // Main game class
        class KlondikeSolitaire {
            constructor() {
                this.constants = new GameConstants();
                            this.storage = new StorageManager();
            this.memory = new MemoryManager();
            this.persistentLearning = new PersistentLearningManager(this); // Memory optimization system
                this.settings = new SettingsManager(this);
                this.stats = new StatisticsManager(this);
                this.achievements = new AchievementManager(this);
                this.sound = new SoundManager(this);
                this.ui = new UIManager(this);
                this.cards = new CardManager(this);
                this.input = new InputManager(this);
                // Phase 2: Use high-performance renderer, with fallback
                try {
                    this.renderer = new PerformanceRenderer(this);
                    console.log('🎨 PerformanceRenderer created');
                } catch (error) {
                    console.error('Failed to create PerformanceRenderer, using basic RenderEngine:', error);
                    this.renderer = new RenderEngine(this);
                    if (this.renderer.init()) {
                        console.log('✅ Basic RenderEngine initialized successfully');
                    } else {
                        console.error('❌ Failed to initialize basic RenderEngine');
                    }
                }
                this.rules = new GameRules(this);
                this.state = new GameState(this);
                this.ai = new AIHintSystem(this);
                // Phase 2: Enhanced AI Worker Manager for non-blocking operations
                this.aiWorkerManager = new AIWorkerManager(this);
                this.daily = new DailyChallenge(this);
                this.ml = new MLManager(this);
                this.timer = null;
                this.gameWon = false;
                this.currentGameMode = 'standard';
                this.currentDifficulty = 'medium';
                this.gameHistory = [];
                this.redoHistory = [];
                this.haptics = HapticManager;
            }
            
            undo() {
                if (!this.gameHistory || this.gameHistory.length === 0) {
                    console.log('No moves to undo');
                    return;
                }
                
                const prevState = this.gameHistory.pop();
                if (!prevState) return;
                
                // Save current state to redo history before undoing
                this.redoHistory.push({
                    stock: this.state.stock.map(card => ({ ...card })),
                    waste: this.state.waste.map(card => ({ ...card })),
                    tableau: this.state.tableau.map(pile => pile.map(card => ({ ...card }))),
                    foundations: Object.fromEntries(
                        Object.entries(this.state.foundations).map(([suit, pile]) => 
                            [suit, pile.map(card => ({ ...card }))]
                        )
                    ),
                    gameStats: { ...this.state.gameStats }
                });
                
                // Restore previous state
                this.state.stock = prevState.stock;
                this.state.waste = prevState.waste;
                this.state.tableau = prevState.tableau;
                this.state.foundations = prevState.foundations;
                this.state.gameStats = { ...prevState.gameStats };
                this.state.hintCardId = null;
                this.state.hoveredCard = null;
                this.input.resetDragState();
                
                this.ui.updateUI();
                this.renderer.render();
            }
            
            startGame(drawMode) {
                try {
                    this.currentGameMode = 'normal';
                    this.state.drawMode = drawMode;
                    this.currentDifficulty = this.settings.data.difficulty;
                    
                    this.ui.hideAllMenus();
                    this.ui.showElement('gameArea');
                    this.input.initCanvas();
                    this.state.initializeGame();
                    
                    // Ensure renderer is working
                    setTimeout(() => {
                        console.log('🎨 Checking renderer after game start...');
                        if (!this.renderer.canvas || !this.renderer.ctx) {
                            console.log('🎨 Renderer not initialized, attempting to initialize...');
                            if (this.renderer.init && this.renderer.init()) {
                                console.log('✅ Renderer initialized successfully');
                            } else {
                                console.error('❌ Failed to initialize renderer');
                            }
                        }
                        this.renderer.render();
                    }, 100);
                } catch (error) {
                    console.error('Error starting game:', error);
                }
            }
            
            startDailyChallenge() {
                try {
                    this.currentGameMode = 'daily';
                    const difficulty = this.daily.getDailyDifficulty();
                    const diffSettings = this.daily.getDifficultySettings(difficulty);
                    
                    this.state.drawMode = diffSettings.drawMode;
                    this.settings.data.scoringMode = diffSettings.scoringMode;
                    this.currentDifficulty = difficulty;
                    
                    this.ui.hideElement('dailyChallenge');
                    this.ui.showElement('gameArea');
                    this.input.initCanvas();
                    this.state.initializeGame();
                } catch (error) {
                    console.error('Error starting daily challenge:', error);
                }
            }
            
            newGame() {
                try {
                    if (confirm('Start a new game? Current progress will be lost.')) {
                        this.state.resetAllGameState();
                        this.state.initializeGame();
                    }
                } catch (error) {
                    console.error('Error starting new game:', error);
                }
            }
            
            redo() {
                if (!this.redoHistory || this.redoHistory.length === 0) {
                    console.log('No moves to redo');
                    return;
                }
                
                const nextState = this.redoHistory.pop();
                if (!nextState) return;
                
                // Save current state to undo history before redoing
                this.state.saveGameState();
                
                // Restore next state
                this.state.stock = nextState.stock;
                this.state.waste = nextState.waste;
                this.state.tableau = nextState.tableau;
                this.state.foundations = nextState.foundations;
                this.state.gameStats = { ...nextState.gameStats };
                this.state.hintCardId = null;
                this.state.hoveredCard = null;
                this.input.resetDragState();
                
                this.ui.updateUI();
                this.renderer.render();
            }
            
            cleanup() {
                try {
                    this.input.cleanup();
                    if (this.timer) clearInterval(this.timer);
                    if (this.ml && !this.ml.isDisposed) {
                        this.ml.dispose();
                    }
                    // Phase 2: Cleanup performance renderer
                    if (this.renderer && this.renderer.destroy) {
                        this.renderer.destroy();
                        console.log('🎨 Performance Renderer cleaned up');
                    }
                    // Phase 2: Cleanup AI Worker Manager
                    if (this.aiWorkerManager && this.aiWorkerManager.worker) {
                        this.aiWorkerManager.worker.terminate();
                        console.log('🤖 AI Worker Manager terminated');
                    }
                    // Cleanup legacy AI worker
                    if (this.ai && this.ai.worker) {
                        this.ai.worker.terminate();
                        console.log('🤖 Legacy AI Worker terminated');
                    }
                } catch (error) {
                    console.error('Cleanup error:', error);
                }
            }
        }

        // Game constants
        class GameConstants {
            constructor() {
                this.SUITS = ['♠', '♥', '♦', '♣'];
                this.RED_SUITS = new Set(['♥', '♦']);
                this.RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
                this.CARD_WIDTH = 80;
                this.CARD_HEIGHT = 120;
                this.FACE_DOWN_OFFSET = 8;
                this.FACE_UP_OFFSET = 20;
                this.WASTE_CARD_OFFSET = 25;
                this.MAX_HISTORY_SIZE = 50;
            }
        }

        // Storage manager
        class StorageManager {
            constructor() {
                this.available = this.checkStorageAvailability();
            }
            
            checkStorageAvailability() {
                try {
                    const test = '__storage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    return false;
                }
            }
            
            set(key, value) {
                if (!this.available) return false;
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (e) {
                    console.warn('Storage quota exceeded:', e);
                    return false;
                }
            }
            
            get(key) {
                if (!this.available) return null;
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : null;
                } catch (e) {
                    console.warn('Storage parse error:', e);
                    return null;
                }
            }
            
            quickSave() {
                try {
                    game.state.saveToLocalStorage();
                    game.sound.play('cardPlace');
                    game.ui.showNotification('💾 Game Saved!', 'success');
                } catch (error) {
                    console.error('Quick save error:', error);
                }
            }
        }

        // Settings manager
        class SettingsManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.data = this.getDefaultSettings();
            }
            
            getDefaultSettings() {
                return {
                    difficulty: 'medium',
                    autoMoveToFoundation: true,
                    showMoveHints: true,
                    enableMLAnalysis: true,
                    adaptiveDifficulty: false,
                    drawMode: 3,
                    scoringMode: 'standard',
                    theme: 'green',
                    soundEnabled: true
                };
            }
            
            loadSettings() {
                try {
                    const saved = this.game.storage.get('klondike_settings');
                    if (saved) {
                        this.data = { ...this.data, ...saved };
                    }
                    this.applySettings();
                } catch (error) {
                    console.error('Error loading settings:', error);
                    this.applySettings();
                }
            }
            
            saveSettings() {
                try {
                    this.game.storage.set('klondike_settings', this.data);
                } catch (error) {
                    console.error('Error saving settings:', error);
                }
            }
            
            applySettings() {
                if (this.game.currentGameMode === 'normal') {
                    const diffSettings = this.game.daily.getDifficultySettings(this.data.difficulty);
                    this.data.drawMode = diffSettings.drawMode;
                    this.data.scoringMode = diffSettings.scoringMode;
                }
            }
            
            updateDifficulty() {
                const select = document.getElementById('difficultySelect');
                this.data.difficulty = select.value;
                this.applySettings();
                this.saveSettings();
            }
            
            updateAutoMove() {
                const checkbox = document.getElementById('autoMoveToFoundation');
                this.data.autoMoveToFoundation = checkbox.checked;
                this.saveSettings();
            }
            
            updateShowHints() {
                const checkbox = document.getElementById('showMoveHints');
                this.data.showMoveHints = checkbox.checked;
                this.saveSettings();
            }
            
            updateMLAnalysis() {
                const checkbox = document.getElementById('enableMLAnalysis');
                this.data.enableMLAnalysis = checkbox.checked;
                this.saveSettings();
                
                if (this.data.enableMLAnalysis) {
                    this.game.ui.showNotification('🧠 AI analysis enabled! Enhanced hints and game analysis now available.', 'info', 3000);
                } else {
                    this.game.ui.showNotification('🧠 AI analysis disabled. Using basic heuristics only.', 'info', 2000);
                }
            }
            
            updateAdaptiveDifficulty() {
                const checkbox = document.getElementById('adaptiveDifficulty');
                this.data.adaptiveDifficulty = checkbox.checked;
                this.saveSettings();
                
                if (this.data.adaptiveDifficulty) {
                    this.game.ui.showNotification('🎯 Adaptive difficulty enabled! AI will suggest optimal challenge level.', 'info', 3000);
                } else {
                    this.game.ui.showNotification('🎯 Adaptive difficulty disabled.', 'info', 2000);
                }
            }
            
            resetSettings() {
                if (confirm('Reset all settings to defaults?')) {
                    this.data = this.getDefaultSettings();
                    this.applySettings();
                    this.game.ui.updateSettingsUI();
                    this.saveSettings();
                }
            }
        }

        // Statistics manager
        class StatisticsManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.data = this.getDefaultStats();
            }
            
            getDefaultStats() {
                return {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    totalTime: 0,
                    totalMoves: 0,
                    bestTime: null,
                    bestScore: 0,
                    currentStreak: 0,
                    longestStreak: 0,
                    dailyChallenges: {}
                };
            }
            
            loadStatistics() {
                try {
                    const saved = this.game.storage.get('klondike_statistics');
                    if (saved) {
                        this.data = { ...this.data, ...saved };
                    }
                } catch (error) {
                    console.error('Error loading statistics:', error);
                }
            }
            
            saveStatistics() {
                try {
                    this.game.storage.set('klondike_statistics', this.data);
                } catch (error) {
                    console.error('Error saving statistics:', error);
                }
            }
            
            updateGameStatistics(won) {
                try {
                    if (won) {
                        this.data.gamesWon++;
                        this.data.totalTime += this.game.state.gameStats.time;
                        this.data.totalMoves += this.game.state.gameStats.moves;
                        this.data.currentStreak++;
                        this.data.longestStreak = Math.max(this.data.longestStreak, this.data.currentStreak);
                        
                        if (!this.data.bestTime || this.game.state.gameStats.time < this.data.bestTime) {
                            this.data.bestTime = this.game.state.gameStats.time;
                        }
                        if (this.game.state.gameStats.score > this.data.bestScore) {
                            this.data.bestScore = this.game.state.gameStats.score;
                        }
                    } else {
                        this.data.currentStreak = 0;
                    }
                    
                    if (this.game.currentGameMode === 'daily' && won) {
                        const today = new Date().toISOString().split('T')[0];
                        this.data.dailyChallenges[today] = {
                            completed: true,
                            score: this.game.state.gameStats.score,
                            time: this.game.state.gameStats.time,
                            moves: this.game.state.gameStats.moves
                        };
                    }
                    
                    this.saveStatistics();
                    
                    if (won) {
                        setTimeout(() => {
                            if (this.game.achievements && typeof this.game.achievements.checkAchievements === 'function') {
                                this.game.achievements.checkAchievements();
                            } else {
                                console.warn('Achievements system not available');
                            }
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error updating statistics:', error);
                }
            }
            
            resetStats() {
                if (confirm('Reset all statistics? This cannot be undone.')) {
                    this.data = this.getDefaultStats();
                    this.saveStatistics();
                    this.game.ui.updateStatsUI();
                }
            }
        }

        // Achievement manager
        class AchievementManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.achievements = {
                    firstWin: { name: "First Victory", description: "Win your first game", unlocked: false, icon: "🎉" },
                    speedDemon: { name: "Speed Demon", description: "Win a game in under 3 minutes", unlocked: false, icon: "⚡" },
                    perfectGame: { name: "Perfect Game", description: "Win without using undo", unlocked: false, icon: "💎" },
                    streakMaster: { name: "Streak Master", description: "Win 5 games in a row", unlocked: false, icon: "🔥" },
                    cardShark: { name: "Card Shark", description: "Win 100 games", unlocked: false, icon: "🦈" }
                };
            }
            
            loadAchievements() {
                try {
                    const saved = this.game.storage.get('klondike_achievements');
                    if (saved) {
                        Object.keys(this.achievements).forEach(key => {
                            if (saved[key]) {
                                this.achievements[key] = { ...this.achievements[key], ...saved[key] };
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading achievements:', error);
                }
            }
            
            saveAchievements() {
                try {
                    this.game.storage.set('klondike_achievements', this.achievements);
                } catch (error) {
                    console.error('Error saving achievements:', error);
                }
            }
            
            checkAchievements() {
                try {
                    const stats = this.game.stats.data;
                    
                    if (!this.achievements.firstWin.unlocked && stats.gamesWon >= 1) {
                        this.unlockAchievement('firstWin');
                    }
                    
                    if (!this.achievements.speedDemon.unlocked && 
                        this.game.state.gameStats.time <= 180 && this.game.gameWon) {
                        this.unlockAchievement('speedDemon');
                    }
                    
                    if (!this.achievements.perfectGame.unlocked && 
                        this.game.gameWon && 
                        this.game.state.gameHistory && this.game.state.gameHistory.length === 0) {
                        this.unlockAchievement('perfectGame');
                    }
                    
                    if (!this.achievements.streakMaster.unlocked && stats.currentStreak >= 5) {
                        this.unlockAchievement('streakMaster');
                    }
                    
                    if (!this.achievements.cardShark.unlocked && stats.gamesWon >= 100) {
                        this.unlockAchievement('cardShark');
                    }
                } catch (error) {
                    console.error('Error checking achievements:', error);
                }
            }
            
            unlockAchievement(achievementId) {
                try {
                    this.achievements[achievementId].unlocked = true;
                    this.game.ui.showAchievementNotification(achievementId);
                    this.game.sound.play('achievement');
                    this.saveAchievements();
                } catch (error) {
                    console.error('Error unlocking achievement:', error);
                }
            }
        }

        // Daily challenge system
        class DailyChallenge {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.difficulties = ['easy', 'medium', 'hard'];
            }
            
            getDailyDifficulty() {
                const dayOfWeek = new Date().getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) return 'easy';
                if (dayOfWeek <= 2) return 'medium';
                return 'hard';
            }
            
            getDifficultySettings(difficulty) {
                const settings = {
                    easy: { drawMode: 1, scoringMode: 'standard' },
                    medium: { drawMode: 3, scoringMode: 'standard' },
                    hard: { drawMode: 3, scoringMode: 'vegas' }
                };
                return settings[difficulty] || settings.medium;
            }
        }

        // Sound manager
        class SoundManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.audioContext = null;
                this.sounds = {
                    cardFlip: () => this.playTone(400, 100),
                    cardPlace: () => this.playTone(600, 150),
                    victory: () => this.playVictorySound(),
                    achievement: () => this.playAchievementSound(),
                    error: () => this.playTone(200, 200)
                };
                this.initAudioContext();
            }
            
            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }
            
            play(soundName) {
                if (!this.game.settings.data.soundEnabled || !this.sounds[soundName]) return;
                try {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    this.sounds[soundName]();
                } catch (error) {
                    console.warn('Sound playback error:', error);
                }
            }
            
            playTone(frequency, duration) {
                if (!this.audioContext) return;
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (error) {
                    console.warn('Tone generation error:', error);
                }
            }
            
            playVictorySound() {
                const notes = [523, 659, 784, 1047];
                notes.forEach((note, index) => {
                    setTimeout(() => this.playTone(note, 200), index * 150);
                });
            }
            
            playAchievementSound() {
                const notes = [784, 1047, 1319];
                notes.forEach((note, index) => {
                    setTimeout(() => this.playTone(note, 300), index * 100);
                });
            }
        }

        // UI manager
        class UIManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.currentTheme = 'green';
            }
            
            showElement(id) {
                const element = document.getElementById(id);
                if (element) element.style.display = 'block';
            }
            
            hideElement(id) {
                const element = document.getElementById(id);
                if (element) element.style.display = 'none';
            }
            
            hideAllMenus() {
                ['menu', 'achievements', 'dailyChallenge', 'settings', 'stats'].forEach(id => {
                    this.hideElement(id);
                });
            }
            
            showNotification(message, type = 'info', duration = 2000) {
                try {
                    const notification = document.createElement('div');
                    
                    // Create close button
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '×';
                    closeButton.className = 'close-btn';
                    closeButton.style.cssText = `
                        position: absolute !important;
                        top: 8px !important;
                        right: 8px !important;
                        background: rgba(255, 255, 255, 0.8) !important;
                        border: 2px solid rgba(0, 0, 0, 0.2) !important;
                        border-radius: 50% !important;
                        width: 32px !important;
                        height: 32px !important;
                        color: #333 !important;
                        font-size: 18px !important;
                        font-weight: bold !important;
                        cursor: pointer !important;
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                        transition: all 0.2s ease !important;
                        z-index: 9999 !important;
                        pointer-events: all !important;
                        touch-action: manipulation !important;
                    `;
                    
                    closeButton.addEventListener('mouseenter', () => {
                        closeButton.style.background = 'rgba(255, 99, 99, 0.9) !important';
                        closeButton.style.color = 'white !important';
                        closeButton.style.transform = 'scale(1.1) !important';
                    });
                    
                    closeButton.addEventListener('mouseleave', () => {
                        closeButton.style.background = 'rgba(255, 255, 255, 0.8) !important';
                        closeButton.style.color = '#333 !important';
                        closeButton.style.transform = 'scale(1) !important';
                    });
                    
                    if (type === 'error') {
                        notification.className = 'error-message';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            left: 50%;
                            transform: translateX(-50%) scale(1);
                            background: linear-gradient(135deg, #ef4444, #dc2626);
                            color: white;
                            padding: 15px 35px 15px 25px;
                            border-radius: 10px;
                            font-weight: bold;
                            z-index: 2000;
                            box-shadow: 0 10px 25px rgba(239,68,68,0.4);
                            max-width: 90vw;
                            text-align: center;
                            animation: shake 0.5s ease-in-out;
                        `;
                    } else if (type === 'hint') {
                        notification.className = 'hint-notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 5%;
                            left: 50%;
                            transform: translateX(-50%) scale(1);
                            background: linear-gradient(135deg, #1f2937, #374151);
                            color: white;
                            padding: 20px 40px 20px 20px;
                            border-radius: 15px;
                            font-weight: normal;
                            font-size: 14px;
                            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
                            z-index: 2000;
                            max-width: 95vw;
                            max-height: 90vh;
                            width: auto;
                            min-width: 300px;
                            border: 2px solid #4ade80;
                            animation: notificationPop 0.5s ease-out;
                            overflow-y: auto;
                        `;
                    } else {
                        notification.className = 'notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%) scale(1);
                            background: linear-gradient(135deg, #ffd700, #ffed4e);
                            color: #333;
                            padding: 20px 40px 20px 30px;
                            border-radius: 15px;
                            font-weight: bold;
                            font-size: 18px;
                            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
                            z-index: 2000;
                            max-width: 90vw;
                            text-align: center;
                            animation: notificationPop 0.5s ease-out;
                        `;
                    }
                    
                    // Create content wrapper
                    const contentDiv = document.createElement('div');
                    contentDiv.innerHTML = message;
                    
                    // Function to close notification
                    const closeNotification = () => {
                        try {
                            if (notification && notification.parentNode) {
                                notification.style.transform = notification.style.transform.replace('scale(1)', 'scale(0)');
                                
                                // Also fade out backdrop if it exists
                                if (notification.backdrop && notification.backdrop.parentNode) {
                                    notification.backdrop.style.opacity = '0';
                                }
                                
                                setTimeout(() => {
                                    if (notification && notification.parentNode) {
                                        document.body.removeChild(notification);
                                    }
                                    if (notification.backdrop && notification.backdrop.parentNode) {
                                        document.body.removeChild(notification.backdrop);
                                    }
                                }, 300);
                            }
                        } catch (removeError) {
                            console.warn('Error removing notification:', removeError);
                        }
                    };
                    
                    closeButton.addEventListener('click', closeNotification);
                    
                    // Add backdrop for modal-like notifications
                    if (type === 'hint' || type === 'achievement') {
                        const backdrop = document.createElement('div');
                        backdrop.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0, 0, 0, 0.5);
                            z-index: 1999;
                        `;
                        backdrop.addEventListener('click', closeNotification);
                        document.body.appendChild(backdrop);
                        
                        // Store backdrop reference for cleanup
                        notification.backdrop = backdrop;
                    }
                    
                    // Assemble notification
                    notification.appendChild(closeButton);
                    notification.appendChild(contentDiv);
                    document.body.appendChild(notification);
                    notification.offsetHeight;
                    
                    // Auto-close timer
                    const autoCloseTimer = setTimeout(closeNotification, duration);
                    
                    // Cancel auto-close if user closes manually
                    closeButton.addEventListener('click', () => {
                        clearTimeout(autoCloseTimer);
                    });
                    
                } catch (error) {
                    console.error('Error showing notification:', error);
                    alert(message.replace(/<[^>]*>/g, ''));
                }
            }
            
            showAchievementNotification(achievementId) {
                const achievement = this.game.achievements.achievements[achievementId];
                this.showNotification(`
                    <div style="font-size: 24px; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-size: 18px; font-weight: bold;">Achievement Unlocked!</div>
                    <div style="font-size: 16px;">${achievement.name}</div>
                    <div style="font-size: 14px; opacity: 0.8;">${achievement.description}</div>
                `, 'achievement', 4000);
            }
            
            toggleTheme() {
                const themes = ['green', 'blue', 'dark', 'light'];
                const currentIndex = themes.indexOf(this.currentTheme);
                this.currentTheme = themes[(currentIndex + 1) % themes.length];
                this.game.settings.data.theme = this.currentTheme;
                this.applyTheme();
                this.game.settings.saveSettings();
                this.game.sound.play('cardFlip');
            }
            
            applyTheme() {
                this.currentTheme = this.game.settings.data.theme;
                const body = document.body;
                
                // Remove all theme classes
                body.className = '';
                
                switch(this.currentTheme) {
                    case 'dark':
                        body.classList.add('dark-theme');
                        document.querySelector('.theme-toggle').textContent = '🌙';
                        break;
                    case 'light':
                        body.classList.add('light-theme');
                        document.querySelector('.theme-toggle').textContent = '☀️';
                        break;
                    case 'blue':
                        body.classList.add('blue-theme');
                        document.querySelector('.theme-toggle').textContent = '🌊';
                        break;
                    default:
                        document.querySelector('.theme-toggle').textContent = '🌓';
                        break;
                }
                
                this.currentTheme = this.game.settings.data.theme;
            }
            
            toggleSound() {
                this.game.settings.data.soundEnabled = !this.game.settings.data.soundEnabled;
                const soundBtn = document.querySelector('.sound-toggle');
                soundBtn.textContent = this.game.settings.data.soundEnabled ? '🔊' : '🔇';
                this.game.settings.saveSettings();
                if (this.game.settings.data.soundEnabled) this.game.sound.play('cardPlace');
            }
            
            updateProgressBar() {
                const foundationCards = Object.values(this.game.state.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                const progress = (foundationCards / 52) * 100;
                
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                }
            }
            
            updateWinProbability() {
                const winProbElement = document.getElementById('winProb');
                const winProbDisplay = document.getElementById('winProbDisplay');
                
                if (!winProbElement || !winProbDisplay) return;
                
                if (this.game.ml && this.game.ml.isInitialized) {
                    // Use ML analysis for win probability
                    this.game.ml.getGameAnalysis(this.game.state).then(analysis => {
                        if (analysis.winProbability) {
                            const prob = Math.round(analysis.winProbability * 100);
                            winProbElement.textContent = `${prob}%`;
                            winProbDisplay.style.display = 'block';
                        }
                    }).catch(err => {
                        console.warn('Error getting ML analysis for win probability:', err);
                    });
                } else {
                    // Basic heuristic calculation
                    const foundationCards = Object.values(this.game.state.foundations)
                        .reduce((sum, pile) => sum + pile.length, 0);
                    const foundationProgress = foundationCards / 52;
                    const faceUpCards = this.game.state.tableau.reduce((sum, pile) => 
                        sum + pile.filter(c => c.faceUp).length, 0);
                    const faceUpRatio = faceUpCards / 28;
                    const moves = this.game.ai.findAllPossibleMoves().length;
                    const movesFactor = Math.min(moves / 10, 1);
                    
                    const winProb = Math.min(
                        (foundationProgress * 0.5) + 
                        (faceUpRatio * 0.3) + 
                        (movesFactor * 0.2), 
                        0.95
                    );
                    const prob = Math.round(winProb * 100);
                    
                    winProbElement.textContent = `${prob}%`;
                    winProbDisplay.style.display = 'block';
                }
            }
            
            updateUI() {
                try {
                    document.getElementById('moves').textContent = this.game.state.gameStats.moves;
                    const minutes = Math.floor(this.game.state.gameStats.time / 60);
                    const seconds = this.game.state.gameStats.time % 60;
                    document.getElementById('time').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    document.getElementById('score').textContent = this.game.state.gameStats.score;
                    document.getElementById('undoBtn').disabled = this.game.gameHistory.length === 0;
                    document.getElementById('redoBtn').disabled = this.game.redoHistory.length === 0;
                    
                    this.updateProgressBar();
                    this.updateWinProbability();
                    
                    const scoreDisplay = document.getElementById('scoreDisplay');
                    if (this.game.state.gameStats.score !== 0 || 
                        this.game.settings.data.scoringMode === 'vegas' || 
                        this.game.currentGameMode === 'daily') {
                        scoreDisplay.style.display = 'block';
                    }
                    
                    this.game.state.checkWinCondition();
                } catch (error) {
                    console.error('Error updating UI:', error);
                }
            }
            
            showWinModal() {
                const minutes = Math.floor(this.game.state.gameStats.time / 60);
                const seconds = this.game.state.gameStats.time % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                this.showNotification(`
                    <h2>🎉 Congratulations! 🎉</h2>
                    <p>You won in <strong>${this.game.state.gameStats.moves}</strong> moves and <strong>${timeStr}</strong>!</p>
                    <p>Final Score: <strong>${this.game.state.gameStats.score}</strong> points</p>
                    <button class="btn-green" onclick="if(window.game && game.ui) game.ui.backToMenu(); else location.reload();" style="margin-top: 15px; padding: 10px 20px;">Play Again</button>
                `, 'win', 10000);
                
                this.game.sound.play('victory');
            }
            
            showDeadlockModal() {
                const minutes = Math.floor(this.game.state.gameStats.time / 60);
                const seconds = this.game.state.gameStats.time % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Get deadlock analysis if available
                let analysisContent = '';
                if (this.game.ml && this.game.ml.lastDeadlockAnalysis) {
                    const analysis = this.game.ml.lastDeadlockAnalysis;
                    analysisContent = `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; margin: 10px 0; text-align: left;">
                            <h4 style="margin: 0 0 8px 0; color: #fbbf24;">🔍 AI Analysis</h4>
                            <div style="margin-bottom: 6px;"><strong>Primary Cause:</strong> ${this.formatDeadlockCause(analysis.primaryCause)}</div>
                            <div style="color: #a78bfa; font-style: italic; font-size: 13px;">💡 ${analysis.suggestion}</div>
                            ${analysis.criticalMovePoint ? `<div style="font-size: 12px; color: #ef4444; margin-top: 4px;">⚠️ Critical point around move ${analysis.criticalMovePoint}</div>` : ''}
                            ${analysis.stockCycles > 2 ? `<div style="font-size: 12px; color: #f59e0b; margin-top: 4px;">🔄 Stock cycled ${analysis.stockCycles} times</div>` : ''}
                        </div>
                    `;
                }
                
                this.showNotification(`
                    <h2>🚫 Game Deadlocked</h2>
                    <p>No more moves are available. Your game has been recorded for AI learning.</p>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                        <strong>Final Stats:</strong><br>
                        Time: ${timeStr} | Moves: ${this.game.state.gameStats.moves} | Score: ${this.game.state.gameStats.score}
                    </div>
                    ${analysisContent}
                    <button class="btn-green" onclick="if(window.game && game.ui) game.ui.backToMenu(); else location.reload();" style="margin-top: 15px; padding: 10px 20px;">New Game</button>
                `, 'error', 15000);
                
                console.log('🧠 Deadlock recorded for AI learning');
            }
            
            formatDeadlockCause(cause) {
                const causes = {
                    'excessive_stock_cycling': 'Too many stock cycles',
                    'suboptimal_mid_game_decisions': 'Poor mid-game decisions', 
                    'unfavorable_initial_deal': 'Challenging initial deal',
                    'analysis_error': 'Could not analyze'
                };
                return causes[cause] || cause;
            }
            
            showDailyChallenge() {
                this.hideElement('menu');
                this.showElement('dailyChallenge');
                this.updateDailyChallengeInfo();
            }
            
            showSettings() {
                this.hideElement('menu');
                this.showElement('settings');
                this.updateSettingsUI();
            }
            
            showStats() {
                this.hideElement('menu');
                this.showElement('stats');
                this.updateStatsUI();
            }
            
            showAchievements() {
                this.hideElement('menu');
                this.showElement('achievements');
                this.updateAchievementsUI();
            }
            
            backToMainMenu() {
                this.hideAllMenus();
                this.showElement('menu');
            }
            
            backToMenu() {
                this.hideElement('gameArea');
                
                if (this.game.currentGameMode === 'daily') {
                    this.showElement('dailyChallenge');
                    this.updateDailyChallengeInfo();
                } else {
                    this.showElement('menu');
                }
                
                this.game.cleanup();
                this.game.currentGameMode = 'normal';
                this.game.state.drawMode = null;
                this.game.input.resetDragState();
            }
            
            updateDailyChallengeInfo() {
                const today = new Date().toISOString().split('T')[0];
                const difficulty = this.game.daily.getDailyDifficulty();
                const isCompleted = this.game.stats.data.dailyChallenges[today]?.completed || false;
                
                document.getElementById('challengeInfo').innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 12px;">
                        <strong>Today's Challenge</strong>
                        <span class="difficulty-indicator diff-${difficulty}">${difficulty.toUpperCase()}</span>
                        <br><br>
                        <strong>Status:</strong> 
                        <span style="color: ${isCompleted ? '#10b981' : '#f59e0b'};">
                            ${isCompleted ? '✅ Completed' : '🎯 Available'}
                        </span>
                        ${isCompleted ? `<br><br><strong>Your Score:</strong> ${this.game.stats.data.dailyChallenges[today]?.score || 0}` : ''}
                    </div>
                `;
            }
            
            updateSettingsUI() {
                document.getElementById('difficultySelect').value = this.game.settings.data.difficulty;
                document.getElementById('autoMoveToFoundation').checked = this.game.settings.data.autoMoveToFoundation;
                document.getElementById('showMoveHints').checked = this.game.settings.data.showMoveHints;
                
                const enableMLCheckbox = document.getElementById('enableMLAnalysis');
                const adaptiveDifficultyCheckbox = document.getElementById('adaptiveDifficulty');
                
                if (enableMLCheckbox) {
                    enableMLCheckbox.checked = this.game.settings.data.enableMLAnalysis;
                }
                if (adaptiveDifficultyCheckbox) {
                    adaptiveDifficultyCheckbox.checked = this.game.settings.data.adaptiveDifficulty;
                }
            }
            
            updateStatsUI() {
                const stats = this.game.stats.data;
                const winRate = stats.gamesPlayed > 0 ? 
                    Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
                const avgTime = stats.gamesWon > 0 ? 
                    Math.round(stats.totalTime / stats.gamesWon) : 0;
                const avgMoves = stats.gamesWon > 0 ? 
                    Math.round(stats.totalMoves / stats.gamesWon) : 0;
                
                document.getElementById('statsContent').innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h3 style="margin-top: 0; color: #4ade80;">Overall Statistics</h3>
                        <strong>Games Won:</strong> ${stats.gamesWon} / ${stats.gamesPlayed} (${winRate}%)<br>
                        <strong>Current Streak:</strong> ${stats.currentStreak}<br>
                        <strong>Longest Streak:</strong> ${stats.longestStreak}<br>
                        <strong>Best Score:</strong> ${stats.bestScore}<br>
                        <strong>Best Time:</strong> ${stats.bestTime ? this.formatTime(stats.bestTime) : 'N/A'}<br>
                        <strong>Average Time:</strong> ${avgTime > 0 ? this.formatTime(avgTime) : 'N/A'}<br>
                        <strong>Average Moves:</strong> ${avgMoves || 'N/A'}
                    </div>
                `;
            }
            
            updateAchievementsUI() {
                const achievementsList = document.getElementById('achievementsList');
                let html = '';
                
                Object.entries(this.game.achievements.achievements).forEach(([id, achievement]) => {
                    const unlocked = achievement.unlocked;
                    html += `
                        <div style="display: flex; align-items: center; margin: 15px 0; padding: 15px; background: rgba(255,255,255,${unlocked ? '0.2' : '0.05'}); border-radius: 10px; ${unlocked ? '' : 'opacity: 0.6;'}">
                            <div style="font-size: 24px; margin-right: 15px;">${unlocked ? achievement.icon : '🔒'}</div>
                            <div>
                                <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                                <div style="font-size: 14px; opacity: 0.8;">${achievement.description}</div>
                                ${unlocked ? '<div style="color: #4ade80; font-size: 12px; margin-top: 3px;">✅ Unlocked</div>' : ''}
                            </div>
                        </div>
                    `;
                });
                
                achievementsList.innerHTML = html;
            }
            
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
            
            async showMLAnalysis() {
                try {
                    let analysis, moves;
                    let mlAvailable = false;
                    
                    if (this.game.ml && this.game.ml.isInitialized) {
                        try {
                            // Get comprehensive analysis from advanced AI
                            analysis = await this.game.ml.getGameAnalysis(this.game.state);
                            moves = this.game.ai.findAllPossibleMoves();
                            
                            // Evaluate moves with advanced AI
                            const evaluatedMoves = [];
                            for (const move of moves.slice(0, 5)) { // Analyze top 5 moves
                                const evaluation = await this.game.ml.evaluateMove(move, this.game.state);
                                evaluatedMoves.push(evaluation);
                            }
                            
                            moves = evaluatedMoves.sort((a, b) => b.aiScore - a.aiScore);
                            mlAvailable = true;
                        } catch (mlError) {
                            console.warn('Advanced ML analysis failed, using fallback:', mlError);
                        }
                    }
                    
                    if (!analysis) {
                        moves = this.game.ai.findAllPossibleMoves();
                        
                        const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                        const foundationProgress = foundationCards / 52;
                        const faceUpCards = this.game.state.tableau.reduce((sum, pile) => 
                            sum + pile.filter(c => c.faceUp).length, 0);
                        const faceUpRatio = faceUpCards / 28;
                        
                        const winProb = Math.min((foundationProgress * 0.6) + (faceUpRatio * 0.3) + 0.1, 0.95);
                        
                        analysis = {
                            winProbability: winProb,
                            difficulty: winProb > 0.7 ? 'easy' : winProb > 0.5 ? 'medium' : winProb > 0.3 ? 'hard' : 'expert',
                            recommendation: winProb > 0.6 ? 'You\'re doing great! 🎯' : 
                                          winProb > 0.3 ? 'Stay focused and think ahead! 🤔' : 
                                          'This is challenging - consider your moves carefully! 😬',
                            stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                        };
                    }
                    
                    // Prepare move analysis
                    let moveAnalysis = '';
                    if (moves && moves.length > 0) {
                        const top5 = moves.slice(0, 5);
                        moveAnalysis = top5.map((move, i) => {
                            let scoreDisplay = '';
                            if (move.aiScore !== undefined) {
                                scoreDisplay = `${Math.round(move.aiScore)}pts`;
                            } else {
                                scoreDisplay = `${Math.round((move.priority / 20) * 100)}%`;
                            }
                            
                            let confidence = '';
                            if (move.confidence !== undefined) {
                                confidence = ` (${Math.round(move.confidence * 100)}% confidence)`;
                            }
                            
                            let reasoning = '';
                            if (move.strategicReasoning && move.strategicReasoning.length > 0) {
                                reasoning = `<br><small style="opacity: 0.8;">• ${move.strategicReasoning[0]}</small>`;
                            }
                            
                            return `${i + 1}. ${move.description} - ${scoreDisplay}${confidence}${reasoning}`;
                        }).join('<br><br>');
                    } else {
                        moveAnalysis = 'No immediate moves available - check stock drawing recommendation';
                    }
                    
                    // Stock drawing analysis
                    let stockAnalysis = '';
                    if (analysis.stockRecommendation) {
                        const stock = analysis.stockRecommendation;
                        stockAnalysis = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>📚 Stock Drawing Strategy</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <span style="color: ${stock.shouldDraw ? '#4ade80' : '#f59e0b'}; font-weight: bold;">
                                        ${stock.shouldDraw ? '✅ Recommended: Draw from stock' : '⏸️ Wait: Focus on tableau moves first'}
                                    </span><br>
                                    <strong>Reason:</strong> ${stock.reason}<br>
                                    ${stock.upcomingCards ? `<strong>Next cards:</strong> ${stock.upcomingCards.join(', ')}<br>` : ''}
                                    ${stock.immediateUseCards ? `<strong>Immediately useful:</strong> ${stock.immediateUseCards} card(s)<br>` : ''}
                                    ${stock.valuableCards ? `<strong>High-value cards:</strong> ${stock.valuableCards} card(s)<br>` : ''}
                                    ${stock.drawValue ? `<strong>Draw value score:</strong> ${stock.drawValue}` : ''}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Hidden card insights
                    let hiddenCardAnalysis = '';
                    if (analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0) {
                        const insights = analysis.hiddenCardInsights;
                        hiddenCardAnalysis = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🔍 Complete Board Vision (Hidden Cards)</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <strong>Total hidden cards:</strong> ${insights.count}<br>
                                    <strong>Strategic value:</strong> ${insights.totalValue}<br><br>
                                    ${insights.insights.slice(0, 5).map(insight => `• ${insight}`).join('<br>')}
                                    ${insights.insights.length > 5 ? `<br>• ...and ${insights.insights.length - 5} more` : ''}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Learning insights
                    let learningProgress = '';
                    if (analysis.learningInsights) {
                        const learning = analysis.learningInsights;
                        learningProgress = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🧠 AI Learning Progress</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    • Learning database: ${learning.totalLearningData} winning games<br>
                                    • Similar winning positions: ${learning.similarWinningGames}<br>
                                    • Historically successful moves available: ${learning.historicallySuccessfulMoves}<br>
                                    • Confidence boost from learning: +${Math.round(learning.confidenceBoost * 100)}%<br><br>
                                    ${learning.insights.length > 0 ? learning.insights.map(insight => `• ${insight}`).join('<br>') : '• Building learning database from your gameplay'}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Strategic insights
                    let strategicInsights = '';
                    if (analysis.strategicInsights && analysis.strategicInsights.length > 0) {
                        strategicInsights = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🎯 Strategic Insights</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    ${analysis.strategicInsights.map(insight => `• ${insight}`).join('<br>')}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Web AI insights (if available)
                    let webAIInsights = '';
                    if (analysis.webAIInsights) {
                        const webAI = analysis.webAIInsights;
                        webAIInsights = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🌐 External AI Consultation</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <strong>Confidence:</strong> ${Math.round(webAI.confidence * 100)}%<br>
                                    <strong>Recommendation:</strong> ${webAI.recommendation}<br>
                                    <strong>Risk Assessment:</strong> ${webAI.riskAssessment}<br><br>
                                    ${webAI.strategicInsights.map(insight => `• ${insight}`).join('<br>')}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Neural network weights (for advanced users)
                    let neuralWeights = '';
                    if (analysis.neuralWeights && mlAvailable) {
                        const weights = analysis.neuralWeights;
                        neuralWeights = `
                            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; margin-bottom: 15px;">
                                <strong>🧮 Neural Network Weights</strong><br>
                                <div style="margin-top: 5px; font-size: 11px; line-height: 1.3; opacity: 0.8;">
                                    Foundation: ${weights.foundationValue.toFixed(1)} | Sequence: ${weights.sequenceValue.toFixed(1)} | 
                                    Reveal: ${weights.revealValue.toFixed(1)} | Space: ${weights.emptySpaceValue.toFixed(1)} | 
                                    King: ${weights.kingPlacementValue.toFixed(1)} | Stock: ${weights.stockEfficiency.toFixed(1)}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Determine AI mode display
                    const aiMode = mlAvailable ? 'Advanced Neural Networks + Complete Board Vision + Learning' : 'Enhanced Heuristics';
                    const aiIcon = mlAvailable ? '🧠' : '🎯';
                    const aiStatus = mlAvailable ? 
                        'Full AI system with neural networks, complete board analysis, learning algorithms, and strategic planning' :
                        'Using mathematical analysis and pattern recognition';
                    
                    // Game metrics
                    const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    const blockedCards = this.game.state.tableau.reduce((sum, pile) => 
                        sum + pile.filter(card => !card.faceUp).length, 0);
                    const emptySpaces = this.game.state.tableau.filter(pile => pile.length === 0).length;
                    const moveEfficiency = this.game.state.gameStats.moves > 0 ? 
                        Math.round((foundationCards / this.game.state.gameStats.moves) * 100) : 0;
                    
                    const message = `
                        <div style="text-align: left; line-height: 1.5; font-size: 13px; max-width: 700px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div style="grid-column: 1 / -1; font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                                ${aiIcon} AI Complete Analysis
                            </div>
                            
                            <!-- Left Column -->
                            <div>
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🎯 Win Probability: ${Math.round(analysis.winProbability * 100)}%</strong><br>
                                    <div style="background: #374151; border-radius: 8px; height: 16px; margin-top: 6px; position: relative;">
                                        <div style="background: linear-gradient(90deg, #ef4444, #f59e0b, #4ade80); width: ${Math.round(analysis.winProbability * 100)}%; height: 100%; border-radius: 8px;"></div>
                                    </div>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>📊 Game Metrics</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        Progress: ${foundationCards}/52 (${Math.round((foundationCards/52)*100)}%) | Hidden: ${blockedCards}<br>
                                        Empty spaces: ${emptySpaces} | Efficiency: ${moveEfficiency}%<br>
                                        Difficulty: <span class="difficulty-indicator diff-${analysis.difficulty}">${analysis.difficulty.toUpperCase()}</span>
                                    </div>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🎯 Top Moves</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px; line-height: 1.3;">
                                        ${moves && moves.length > 0 ? moves.slice(0, 3).map((move, i) => {
                                            const score = move.aiScore !== undefined ? Math.round(move.aiScore) : Math.round((move.priority / 20) * 100);
                                            return `${i + 1}. ${move.description} (${score}${move.aiScore !== undefined ? 'pts' : '%'})`;
                                        }).join('<br>') : 'No immediate moves - check stock'}
                                    </div>
                                </div>
                                
                                ${analysis.stockRecommendation ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px;">
                                    <strong>📚 Stock Strategy</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        <span style="color: ${analysis.stockRecommendation.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                            ${analysis.stockRecommendation.shouldDraw ? '✅ Draw' : '⏸️ Wait'}
                                        </span> - ${analysis.stockRecommendation.reason}<br>
                                        ${analysis.stockRecommendation.upcomingCards ? `Next: ${analysis.stockRecommendation.upcomingCards.slice(0,3).join(', ')}` : ''}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <!-- Right Column -->
                            <div>
                                ${analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0 ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🔍 Hidden Cards (${analysis.hiddenCardInsights.count})</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px; line-height: 1.3;">
                                        Value: ${analysis.hiddenCardInsights.totalValue}<br>
                                        ${analysis.hiddenCardInsights.insights.slice(0, 3).map(insight => `• ${insight}`).join('<br>')}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.learningInsights ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🧠 AI Learning</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        Database: ${analysis.learningInsights.totalLearningData} wins<br>
                                        Similar positions: ${analysis.learningInsights.similarWinningGames}<br>
                                        Confidence boost: +${Math.round(analysis.learningInsights.confidenceBoost * 100)}%
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.strategicInsights && analysis.strategicInsights.length > 0 ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🎯 Strategic Insights</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px; line-height: 1.3;">
                                        ${analysis.strategicInsights.slice(0, 3).map(insight => `• ${insight}`).join('<br>')}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.webAIInsights ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🌐 External AI</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        Confidence: ${Math.round(analysis.webAIInsights.confidence * 100)}%<br>
                                        Risk: ${analysis.webAIInsights.riskAssessment}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.neuralWeights && mlAvailable ? `
                                <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px;">
                                    <strong>🧮 Neural Weights</strong><br>
                                    <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">
                                        F:${analysis.neuralWeights.foundationValue.toFixed(1)} S:${analysis.neuralWeights.sequenceValue.toFixed(1)} 
                                        R:${analysis.neuralWeights.revealValue.toFixed(1)} E:${analysis.neuralWeights.emptySpaceValue.toFixed(1)}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <div style="grid-column: 1 / -1; background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-top: 8px;">
                                <strong>💭 AI Recommendation:</strong><br>
                                <span style="color: #a78bfa; font-style: italic;">${analysis.recommendation}</span>
                            </div>
                            
                            <div style="grid-column: 1 / -1; text-align: center; font-size: 11px; opacity: 0.7; margin-top: 8px;">
                                <strong>Powered by:</strong> ${aiMode}
                            </div>
                        </div>
                    `;
                    
                    this.showNotification(message, 'hint', 25000);
                    
                } catch (error) {
                    console.error('Enhanced analysis error:', error);
                    
                    const moves = this.game.ai.findAllPossibleMoves();
                    const moveCount = moves.length;
                    const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    const progress = Math.round((foundationCards / 52) * 100);
                    
                    this.showNotification(`
                        <div style="text-align: center;">
                            <h3>🎯 Quick Analysis</h3>
                            <p><strong>Game Progress:</strong> ${progress}%</p>
                            <p><strong>Available Moves:</strong> ${moveCount}</p>
                            <p><strong>Status:</strong> ${moveCount > 0 ? 'Keep playing! 🎮' : 'Try drawing from stock 📚'}</p>
                            <p><small>Advanced AI analysis temporarily unavailable</small></p>
                        </div>
                    `, 'hint', 5000);
                }
            }
        }

        // Card manager
        class CardManager {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            createDeck() {
                return this.game.constants.SUITS.flatMap(suit =>
                    this.game.constants.RANKS.map((rank, index) => ({
                        id: `${rank}${suit}`,
                        suit,
                        rank,
                        value: index + 1,
                        faceUp: false
                    }))
                );
            }
            
            shuffle(deck) {
                const shuffled = [...deck];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            findCardLocation(card) {
                // Check waste pile
                for (let i = 0; i < this.game.state.waste.length; i++) {
                    if (this.game.state.waste[i].id === card.id) {
                        return { type: 'waste', index: i };
                    }
                }
                
                // Check foundation piles
                for (const [suit, pile] of Object.entries(this.game.state.foundations)) {
                    for (let i = 0; i < pile.length; i++) {
                        if (pile[i].id === card.id) {
                            return { type: 'foundation', suit: suit, index: i };
                        }
                    }
                }
                
                // Check tableau piles
                for (let pileIndex = 0; pileIndex < this.game.state.tableau.length; pileIndex++) {
                    const pile = this.game.state.tableau[pileIndex];
                    for (let cardIndex = 0; cardIndex < pile.length; cardIndex++) {
                        if (pile[cardIndex].id === card.id) {
                            return { type: 'tableau', pileIndex: pileIndex, cardIndex: cardIndex };
                        }
                    }
                }
                
                return null;
            }
        }

        // Game state
        class GameState {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.drawMode = null;
                this.stock = [];
                this.waste = [];
                this.tableau = Array.from({ length: 7 }, () => []);
                this.foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                this.gameStats = { moves: 0, time: 0, score: 0 };
                this.hintCardId = null;
                this.hoveredCard = null;
            }
            
            canMoveToFoundation(card) {
                // Check if card is face up
                if (!card.faceUp) return false;
                
                // Get the foundation pile for this card's suit
                const foundationPile = this.foundations[card.suit];
                if (!foundationPile) return false;
                
                // If foundation is empty, only Ace can be placed
                if (foundationPile.length === 0) {
                    return card.value === 1;
                }
                
                // Get the top card of the foundation pile
                const topCard = foundationPile[foundationPile.length - 1];
                
                // Card must be one rank higher than the top card
                return card.value === topCard.value + 1;
            }
            
            saveGameState() {
                if (!this.game.gameHistory) {
                    this.game.gameHistory = [];
                }
                
                // Create a deep copy of the current state
                const currentState = {
                    stock: this.stock.map(card => ({ ...card })),
                    waste: this.waste.map(card => ({ ...card })),
                    tableau: this.tableau.map(pile => pile.map(card => ({ ...card }))),
                    foundations: Object.fromEntries(
                        Object.entries(this.foundations).map(([suit, pile]) => 
                            [suit, pile.map(card => ({ ...card }))]
                        )
                    ),
                    gameStats: { ...this.gameStats }
                };
                
                // Add to history
                this.game.gameHistory.push(currentState);
                
                // Limit history size
                if (this.game.gameHistory.length > this.game.constants.MAX_HISTORY_SIZE) {
                    this.game.gameHistory.shift();
                }
            }
            
            initializeGame() {
                try {
                    this.gameStats = { moves: 0, time: 0, score: 0 };
                    this.hintCardId = null;
                    this.game.gameWon = false;
                    this.hoveredCard = null;
                    this.game.input.resetDragState();
                    
                    if (this.game.timer) clearInterval(this.game.timer);
                    
                    const deck = this.game.cards.shuffle(this.game.cards.createDeck());
                    
                    this.tableau = Array.from({ length: 7 }, () => []);
                    for (let col = 0; col < 7; col++) {
                        for (let row = 0; row <= col; row++) {
                            const card = deck.pop();
                            card.faceUp = row === col;
                            this.tableau[col].push(card);
                        }
                    }
                    
                    this.stock = deck;
                    this.waste = [];
                    this.foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                    
                    // Clear game history when starting a new game
                    this.game.gameHistory = [];
                    this.game.redoHistory = [];
                    
                    if (this.game.settings.data.scoringMode === 'vegas') {
                        this.gameStats.score = -52;
                    }
                    
                    this.saveGameState(); // Save initial state
                } catch (error) {
                    console.error('Error initializing game:', error);
                }
            }
            
            startTimer() {
                this.game.timer = setInterval(() => {
                    this.gameStats.time++;
                    
                    if (this.game.settings.data.scoringMode === 'vegas' && this.gameStats.time % 10 === 0) {
                        this.gameStats.score = Math.max(-999, this.gameStats.score - 2);
                    }
                    
                    this.game.ui.updateUI();
                }, 1000);
            }
            
            updateScore(action) {
                const isVegas = this.game.settings.data.scoringMode === 'vegas';
                
                switch(action) {
                    case 'foundation':
                        this.gameStats.score += isVegas ? 5 : 10;
                        break;
                    case 'reveal':
                        this.gameStats.score += 5;
                        break;
                    case 'waste_to_tableau':
                        this.gameStats.score += isVegas ? 0 : 5;
                        break;
                    case 'tableau_to_tableau':
                        this.gameStats.score += isVegas ? 0 : 3;
                        break;
                    case 'foundation_to_tableau':
                        this.gameStats.score -= isVegas ? 5 : 15;
                        break;
                    case 'win_bonus':
                        if (isVegas) {
                            this.gameStats.score += 500;
                        } else {
                            const timeBonus = Math.max(0, 1000 - this.gameStats.time);
                            const moveBonus = Math.max(0, 500 - this.gameStats.moves);
                            this.gameStats.score += timeBonus + moveBonus;
                        }
                        break;
                }
                
                if (isVegas) {
                    this.gameStats.score = Math.max(-999, Math.min(9999, this.gameStats.score));
                } else {
                    this.gameStats.score = Math.max(0, this.gameStats.score);
                }
            }
            
            checkWinCondition() {
                const totalFoundationCards = Object.values(this.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                
                if (totalFoundationCards === 52 && !this.game.gameWon) {
                    this.game.gameWon = true;
                    if (this.game.timer) clearInterval(this.game.timer);
                    
                    // Victory effects
                    this.game.haptics.victory();
                    if (this.game.particles) {
                        // Create victory particles across the screen
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                const x = Math.random() * 1000;
                                const y = Math.random() * 600;
                                this.game.particles.createVictoryEffect(x, y);
                            }, i * 200);
                        }
                    }
                    
                    this.updateScore('win_bonus');
                    
                    // Record game completion for advanced ML learning
                    if (this.game.ml && !this.game.ml.isDisposed) {
                        try {
                            const allMoves = this.game.gameHistory.map(state => ({
                                type: 'game_state',
                                gameStats: state.gameStats,
                                timestamp: Date.now()
                            }));
                            
                            // Record the winning game for learning
                            this.game.ml.recordGameOutcome(this, allMoves, true);
                            
                            console.log('🧠 Recorded winning game for AI learning');
                        } catch (mlError) {
                            console.warn('Error recording game completion for ML:', mlError);
                        }
                    }
                    
                    // Record win in persistent learning system
                    if (this.game.persistentLearning && this.game.persistentLearning.isInitialized) {
                        const winningGameData = {
                            won: true,
                            moves: this.moves,
                            timeElapsed: performance.now() - this.game.startTime,
                            finalState: {
                                foundations: { ...this.foundations },
                                tableau: this.tableau.map(pile => [...pile]),
                                waste: [...this.waste],
                                stock: [...this.stock]
                            },
                            moveSequence: this.game.gameHistory.map(state => ({
                                type: state.action?.type || 'unknown',
                                timestamp: state.timestamp
                            })),
                            strategyUsed: this.game.lastStrategyUsed || 'manual',
                            aiAssisted: this.game.aiHintUsed || false
                        };
                        
                        this.game.persistentLearning.recordGameResult(winningGameData);
                    }
                    
                    this.game.stats.updateGameStatistics(true);
                    
                    setTimeout(() => {
                        this.game.ui.showWinModal();
                    }, 500);
                    
                    this.game.ui.updateUI();
                } else {
                    // Check for deadlock condition
                    this.checkDeadlockCondition();
                }
            }
            
            checkDeadlockCondition() {
                if (this.game.gameWon) return; // Already won, no need to check
                
                // Get all possible moves
                const possibleMoves = this.game.ai.findAllPossibleMoves();
                
                console.log(`🔍 Deadlock Check: Found ${possibleMoves.length} possible moves`);
                if (possibleMoves.length > 0) {
                    console.log(`🔍 Available moves: ${possibleMoves.map(m => m.description).join(', ')}`);
                }
                
                // True deadlock: no moves available at all (including stock moves)
                if (possibleMoves.length === 0) {
                    console.log('🚫 No moves available - immediate deadlock!');
                    this.handleDeadlock();
                    return;
                }
                
                // Enhanced deadlock detection
                const progressiveMoves = this.identifyProgressiveMoves(possibleMoves);
                const nonStockMoves = possibleMoves.filter(move => 
                    move.type !== 'stock-draw' && move.type !== 'stock-reset'
                );
                
                console.log(`🔍 Progressive moves: ${progressiveMoves.length}, Non-stock moves: ${nonStockMoves.length}`);
                
                // Case 1: Only stock moves available - check for cycling
                if (nonStockMoves.length === 0 && possibleMoves.length > 0) {
                    if (this.detectStockCycling()) {
                        console.log('🚫 Detected stock cycling deadlock!');
                        this.handleDeadlock();
                        return;
                    }
                }
                
                // Case 2: No progressive moves available - check for lateral move deadlock
                if (progressiveMoves.length === 0) {
                    if (this.detectLateralMoveDeadlock(possibleMoves)) {
                        console.log('🚫 Detected lateral move deadlock - no progressive moves available!');
                        this.handleDeadlock();
                        return;
                    }
                }
                
                // Case 2.5: Very few progressive moves with mostly stock cycling
                if (progressiveMoves.length <= 1 && possibleMoves.length > 1) {
                    const stockMoves = possibleMoves.filter(move => 
                        move.type === 'stock-draw' || move.type === 'stock-reset'
                    );
                    // If >75% of moves are stock moves, likely deadlocked
                    if (stockMoves.length / possibleMoves.length > 0.75) {
                        if (this.detectStockCycling()) {
                            console.log('🚫 Detected stock-heavy deadlock with minimal progress!');
                            this.handleDeadlock();
                            return;
                        }
                    }
                }
                
                // Case 3: Check for repeated game states (cycling through same positions)
                if (this.detectGameStateCycling()) {
                    console.log('🚫 Detected game state cycling deadlock!');
                    this.handleDeadlock();
                    return;
                }
                
                // Case 4: Check for stagnation - very few progressive moves over time
                if (this.detectProgressStagnation(progressiveMoves, possibleMoves)) {
                    console.log('🚫 Detected progress stagnation deadlock!');
                    this.handleDeadlock();
                    return;
                }
                
                // Phase 2: Advanced pattern recognition deadlock detection
                if (this.checkAdvancedDeadlockPatterns()) {
                    console.log('🧠 Advanced pattern analysis detected deadlock!');
                    this.handleDeadlock();
                    return;
                }
                
                // Phase 2: Predictive deadlock warning (early detection)
                const deadlockRisk = this.assessDeadlockRisk(progressiveMoves, possibleMoves);
                if (deadlockRisk.level === 'critical' && deadlockRisk.confidence > 0.85) {
                    console.log(`⚠️ Critical deadlock risk detected: ${deadlockRisk.reason} (confidence: ${(deadlockRisk.confidence * 100).toFixed(1)}%)`);
                    this.handleDeadlock();
                    return;
                } else if (deadlockRisk.level === 'high') {
                    console.log(`⚠️ High deadlock risk: ${deadlockRisk.reason} (confidence: ${(deadlockRisk.confidence * 100).toFixed(1)}%)`);
                }
            }
            
            identifyProgressiveMoves(possibleMoves) {
                const progressiveMoves = [];
                
                for (const move of possibleMoves) {
                    if (this.isMoveProgressive(move)) {
                        progressiveMoves.push(move);
                    }
                }
                
                return progressiveMoves;
            }
            
            isMoveProgressive(move) {
                // Foundation moves are always progressive
                if (move.type === 'foundation') {
                    return true;
                }
                
                // Moving Kings to empty spaces is progressive
                if (move.card && move.card.value === 13 && 
                    move.description && move.description.includes('empty space')) {
                    return true;
                }
                
                // Moves that reveal hidden cards are progressive
                if (move.description && move.description.includes('reveals card')) {
                    return true;
                }
                
                // Check if tableau move creates new opportunities
                if (move.type === 'tableau' || move.type === 'waste-to-tableau') {
                    return this.doesMoveCreateOpportunities(move);
                }
                
                // Stock moves can be progressive if they reveal useful cards
                if (move.type === 'stock-draw' || move.type === 'stock-reset') {
                    return this.canStockMoveRevealUsefulCards();
                }
                
                return false;
            }
            
            doesMoveCreateOpportunities(move) {
                if (!move.card) return false;
                
                // Simulate the move and check if it creates new foundation opportunities
                // or reveals cards that could lead to foundation moves
                
                // For now, use heuristics:
                // 1. Moving lower value cards (2-5) is often progressive, but be more selective
                if (move.card.value <= 5) {
                    return true;
                }
                
                // 2. Moving 6s and 7s is only progressive if it reveals cards or creates foundation opportunities
                if (move.card.value <= 7) {
                    // Check if this move would create a foundation opportunity
                    const nextFoundationValue = this.game.state.foundations[move.card.suit].length + 1;
                    if (move.card.value === nextFoundationValue) {
                        return true; // This card can go to foundation after the move
                    }
                }
                
                // 2. Moving cards that could uncover hidden cards
                const cardLocation = this.game.cards.findCardLocation(move.card);
                if (cardLocation && cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    const cardIndex = cardLocation.cardIndex;
                    // If there are hidden cards below this card, moving it could be progressive
                    if (cardIndex > 0 && pile[cardIndex - 1] && !pile[cardIndex - 1].faceUp) {
                        return true;
                    }
                }
                
                return false;
            }
            
            canStockMoveRevealUsefulCards() {
                // Check if cycling through stock could reveal cards that can go to foundation
                // This is a simplified check - in a real implementation, we'd analyze the stock contents
                
                // If foundations are not full, stock moves might be useful
                const foundationCounts = Object.values(this.game.state.foundations).map(pile => pile.length);
                const totalFoundationCards = foundationCounts.reduce((sum, count) => sum + count, 0);
                
                // Be more conservative - if we've placed a good number of cards, stock moves are less likely to help
                // Also check if we have stock cards left to cycle through
                const hasStockCards = this.game.state.stock.length > 0 || this.game.state.waste.length > 0;
                
                // Stock moves are progressive if:
                // 1. We haven't placed many cards on foundations yet (early game)
                // 2. OR we have very few foundation cards (stuck early)
                // 3. AND we actually have cards to cycle through
                return hasStockCards && (totalFoundationCards < 20 || totalFoundationCards < 8);
            }
            
            detectLateralMoveDeadlock(possibleMoves) {
                // Check if we're in a state where only lateral moves are available
                // and we've been cycling through them
                
                if (!this.lateralMoveHistory) {
                    this.lateralMoveHistory = [];
                }
                
                // Identify lateral moves (moves that don't make progress)
                const lateralMoves = possibleMoves.filter(move => !this.isMoveProgressive(move));
                
                // If all non-stock moves are lateral, we might be in a deadlock
                const nonStockMoves = possibleMoves.filter(move => 
                    move.type !== 'stock-draw' && move.type !== 'stock-reset'
                );
                
                                 // Track lateral move patterns regardless of whether all moves are lateral
                 const currentState = this.createGameStateSignature();
                 this.lateralMoveHistory.push({
                     state: currentState,
                     timestamp: Date.now(),
                     moveCount: this.moves,
                     lateralMoveCount: lateralMoves.length,
                     totalMoveCount: possibleMoves.length
                 });
                 
                 // Keep only recent history
                 if (this.lateralMoveHistory.length > 20) {
                     this.lateralMoveHistory.shift();
                 }
                 
                 // Check for lateral deadlock patterns
                 if (nonStockMoves.length > 0) {
                     // Case 1: All non-stock moves are lateral
                     if (lateralMoves.length === nonStockMoves.length) {
                         const recentStates = this.lateralMoveHistory.slice(-6);
                         const stateCount = {};
                         
                         recentStates.forEach(entry => {
                             stateCount[entry.state] = (stateCount[entry.state] || 0) + 1;
                         });
                         
                         const maxRepeats = Math.max(...Object.values(stateCount));
                         if (maxRepeats >= 3) {
                             console.log(`🔍 Lateral deadlock detected: all moves lateral, state repeated ${maxRepeats} times`);
                             return true;
                         }
                     }
                     
                     // Case 2: High proportion of lateral moves over time
                     if (this.lateralMoveHistory.length >= 10) {
                         const recentEntries = this.lateralMoveHistory.slice(-10);
                         const totalLateralMoves = recentEntries.reduce((sum, entry) => sum + entry.lateralMoveCount, 0);
                         const totalMoves = recentEntries.reduce((sum, entry) => sum + entry.totalMoveCount, 0);
                         
                         // If >65% of recent moves are lateral, we might be in a deadlock (reduced from 70%)
                         if (totalMoves > 0 && (totalLateralMoves / totalMoves) > 0.65) {
                             console.log(`🔍 Lateral deadlock detected: ${Math.round(totalLateralMoves/totalMoves*100)}% lateral moves`);
                             return true;
                         }
                     }
                     
                     // Case 3: Many moves without progress
                     if (this.lateralMoveHistory.length >= 12) {
                         const oldestEntry = this.lateralMoveHistory[0];
                         const newestEntry = this.lateralMoveHistory[this.lateralMoveHistory.length - 1];
                         const movesMade = newestEntry.moveCount - oldestEntry.moveCount;
                         
                         // If we've made 12+ moves and returned to a similar state (reduced from 15)
                         if (movesMade >= 12) {
                             const statesSimilar = this.areStatesSimilar(oldestEntry.state, newestEntry.state);
                             if (statesSimilar) {
                                 console.log(`🔍 Lateral deadlock detected: ${movesMade} moves with minimal progress`);
                                 return true;
                             }
                         }
                     }
                 }
                
                return false;
            }
            
            areStatesSimilar(state1, state2) {
                // Compare two game state signatures to see if they're similar
                // (not necessarily identical, but close enough to indicate lack of progress)
                
                if (state1 === state2) return true;
                
                // Parse the states to compare components
                const parseState = (state) => {
                    const parts = state.split('|');
                    const result = {};
                    parts.forEach(part => {
                        const [key, value] = part.split(':');
                        result[key] = value;
                    });
                    return result;
                };
                
                try {
                    const parsed1 = parseState(state1);
                    const parsed2 = parseState(state2);
                    
                    // Compare foundation progress (most important)
                    if (parsed1.F !== parsed2.F) {
                        return false; // Foundation progress changed, states are different
                    }
                    
                    // Compare tableau structure (allow some variation)
                    const tableau1 = parsed1.T ? parsed1.T.split(',') : [];
                    const tableau2 = parsed2.T ? parsed2.T.split(',') : [];
                    
                    if (tableau1.length !== tableau2.length) return false;
                    
                    // Count how many tableau positions are identical
                    let identicalPositions = 0;
                    for (let i = 0; i < tableau1.length; i++) {
                        if (tableau1[i] === tableau2[i]) {
                            identicalPositions++;
                        }
                    }
                    
                    // If >75% of tableau positions are identical and foundations are same, states are similar
                    const similarityThreshold = tableau1.length * 0.75;
                    return identicalPositions >= similarityThreshold;
                    
                } catch (error) {
                    // If parsing fails, fall back to exact comparison
                    return state1 === state2;
                }
            }
            
            detectProgressStagnation(progressiveMoves, allMoves) {
                // Check if we're making very little progress over time
                if (!this.progressHistory) {
                    this.progressHistory = [];
                }
                
                const foundationCounts = Object.values(this.game.state.foundations).map(pile => pile.length);
                const totalFoundationCards = foundationCounts.reduce((sum, count) => sum + count, 0);
                
                this.progressHistory.push({
                    foundationCards: totalFoundationCards,
                    progressiveMoves: progressiveMoves.length,
                    totalMoves: allMoves.length,
                    timestamp: Date.now(),
                    moveCount: this.moves
                });
                
                // Keep only recent history
                if (this.progressHistory.length > 20) {
                    this.progressHistory.shift();
                }
                
                // Need at least 10 entries to detect stagnation
                if (this.progressHistory.length < 10) {
                    return false;
                }
                
                const recentEntries = this.progressHistory.slice(-10);
                const oldestEntry = recentEntries[0];
                const newestEntry = recentEntries[recentEntries.length - 1];
                
                // Check for foundation progress stagnation
                const foundationProgress = newestEntry.foundationCards - oldestEntry.foundationCards;
                const movesMade = newestEntry.moveCount - oldestEntry.moveCount;
                
                // If we've made 8+ moves with no foundation progress and very few progressive moves
                if (movesMade >= 8 && foundationProgress === 0) {
                    const avgProgressiveMoves = recentEntries.reduce((sum, entry) => sum + entry.progressiveMoves, 0) / recentEntries.length;
                    
                    // If average progressive moves per check is very low (< 1.2), we're likely stuck
                    if (avgProgressiveMoves < 1.2) {
                        console.log(`🔍 Progress stagnation: ${movesMade} moves, ${foundationProgress} foundation progress, avg ${avgProgressiveMoves.toFixed(1)} progressive moves`);
                        return true;
                    }
                }
                
                // Also check for minimal foundation progress over longer periods
                if (movesMade >= 15 && foundationProgress <= 2) {
                    console.log(`🔍 Progress stagnation: ${movesMade} moves with only ${foundationProgress} foundation progress`);
                    return true;
                }
                
                // Also check for very slow foundation progress
                if (movesMade >= 20 && foundationProgress <= 1) {
                    console.log(`🔍 Progress stagnation: ${movesMade} moves with only ${foundationProgress} foundation progress`);
                    return true;
                }
                
                return false;
            }
            
            // Phase 2: Advanced Pattern Recognition System
            initializeAdvancedPatternRecognition() {
                if (!this.patternRecognition) {
                    this.patternRecognition = {
                        cardBlockingPatterns: new Map(),
                        sequenceDeadlocks: new Map(),
                        foundationBottlenecks: new Map(),
                        stockExhaustionPatterns: new Map(),
                        multiMoveDeadlocks: new Map(),
                        historicalDeadlocks: []
                    };
                }
            }

            analyzeCardBlockingPatterns() {
                // Detect when key cards are blocked by unfavorable sequences
                const blockingPatterns = [];
                
                this.game.state.tableau.forEach((pile, pileIndex) => {
                    if (pile.length === 0) return;
                    
                    // Look for buried aces and low cards
                    pile.forEach((card, cardIndex) => {
                        if (!card.faceUp) return;
                        
                        // Check if this card is blocking important cards below
                        const cardsBelow = pile.slice(0, cardIndex);
                        const hiddenBelow = cardsBelow.filter(c => !c.faceUp);
                        
                        if (hiddenBelow.length > 0) {
                            // Estimate what might be hidden based on what's already visible
                            const visibleCards = this.getAllVisibleCards();
                            const missingLowCards = this.findMissingLowValueCards(visibleCards);
                            
                            if (missingLowCards.length > 0) {
                                blockingPatterns.push({
                                    type: 'potential_low_card_blocking',
                                    blockingCard: card,
                                    pileIndex: pileIndex,
                                    hiddenCount: hiddenBelow.length,
                                    potentiallyBlocked: missingLowCards,
                                    severity: this.calculateBlockingSeverity(card, hiddenBelow.length, missingLowCards)
                                });
                            }
                        }
                    });
                });
                
                return blockingPatterns;
            }

            findMissingLowValueCards(visibleCards) {
                const visibleSet = new Set(visibleCards.map(c => `${c.value}${c.suit}`));
                const missingLowCards = [];
                
                ['♠', '♥', '♦', '♣'].forEach(suit => {
                    for (let value = 1; value <= 4; value++) { // Focus on Aces through 4s
                        const cardKey = `${value}${suit}`;
                        if (!visibleSet.has(cardKey)) {
                            missingLowCards.push({ value, suit });
                        }
                    }
                });
                
                return missingLowCards;
            }

            calculateBlockingSeverity(blockingCard, hiddenCount, potentiallyBlocked) {
                let severity = 0;
                
                // Higher severity for blocking high-value cards when low cards might be hidden
                if (blockingCard.value >= 10) severity += 2;
                if (blockingCard.value >= 7) severity += 1;
                
                // More hidden cards = higher severity
                severity += hiddenCount * 0.5;
                
                // More potentially blocked low cards = higher severity
                severity += potentiallyBlocked.length * 1.5;
                
                return Math.min(10, severity); // Cap at 10
            }

            analyzeSequenceDeadlocks() {
                // Detect when tableau sequences prevent necessary moves
                const sequenceIssues = [];
                
                this.game.state.tableau.forEach((pile, pileIndex) => {
                    if (pile.length < 2) return;
                    
                    const faceUpCards = pile.filter(c => c.faceUp);
                    if (faceUpCards.length < 2) return;
                    
                    // Check for problematic sequences
                    for (let i = 0; i < faceUpCards.length - 1; i++) {
                        const currentCard = faceUpCards[i];
                        const nextCard = faceUpCards[i + 1];
                        
                        // Look for sequences that block foundation building
                        if (this.isFoundationReady(currentCard) && !this.canMoveToFoundation(currentCard)) {
                            const blockingReason = this.analyzeFoundationBlocking(currentCard, nextCard, faceUpCards.slice(i + 1));
                            
                            if (blockingReason) {
                                sequenceIssues.push({
                                    type: 'foundation_blocking_sequence',
                                    blockedCard: currentCard,
                                    blockingCards: faceUpCards.slice(i + 1),
                                    pileIndex: pileIndex,
                                    reason: blockingReason,
                                    severity: this.calculateSequenceBlockingSeverity(currentCard, faceUpCards.slice(i + 1))
                                });
                            }
                        }
                    }
                });
                
                return sequenceIssues;
            }

            isFoundationReady(card) {
                const foundationPile = this.game.state.foundations[card.suit];
                if (!foundationPile || foundationPile.length === 0) {
                    return card.value === 1; // Ace
                }
                
                const topFoundationCard = foundationPile[foundationPile.length - 1];
                return card.value === topFoundationCard.value + 1;
            }

            analyzeFoundationBlocking(targetCard, nextCard, blockingSequence) {
                // Analyze why a foundation-ready card can't be moved
                if (blockingSequence.length === 0) return null;
                
                // Check if the blocking sequence can be moved elsewhere
                const canMoveSequence = this.canMoveSequenceElsewhere(blockingSequence);
                
                if (!canMoveSequence) {
                    return {
                        type: 'unmovable_sequence',
                        description: `${blockingSequence.length} cards blocking foundation move`,
                        canResolve: false
                    };
                }
                
                // Check if moving the sequence would help
                const wouldRevealCards = this.wouldSequenceMoveRevealCards(blockingSequence);
                
                return {
                    type: 'movable_but_complex',
                    description: `Sequence can be moved but requires ${this.calculateMovesToResolve(blockingSequence)} moves`,
                    canResolve: true,
                    wouldRevealCards: wouldRevealCards,
                    movesRequired: this.calculateMovesToResolve(blockingSequence)
                };
            }

            canMoveSequenceElsewhere(sequence) {
                if (sequence.length === 0) return true;
                
                const topCard = sequence[0];
                
                // Check each tableau pile
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    
                    if (pile.length === 0) {
                        // Can move King to empty space
                        return topCard.value === 13;
                    } else {
                        const topPileCard = pile[pile.length - 1];
                        if (topPileCard.faceUp && this.canPlaceOnTableau(topCard, topPileCard)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }

            calculateMovesToResolve(blockingSequence) {
                // Estimate how many moves it would take to resolve this blocking sequence
                let moves = 1; // At least one move to move the sequence
                
                // Add complexity for longer sequences
                moves += Math.floor(blockingSequence.length / 3);
                
                // Add complexity if no obvious destination
                if (!this.canMoveSequenceElsewhere(blockingSequence)) {
                    moves += 3; // Need to create space first
                }
                
                return moves;
            }

            calculateSequenceBlockingSeverity(blockedCard, blockingCards) {
                let severity = 0;
                
                // Higher severity for blocked Aces and low cards
                if (blockedCard.value === 1) severity += 5; // Ace
                if (blockedCard.value <= 3) severity += 3; // 2s and 3s
                if (blockedCard.value <= 5) severity += 1; // 4s and 5s
                
                // More blocking cards = higher severity
                severity += blockingCards.length * 0.5;
                
                // Check if blocking cards are high value (harder to move)
                const highValueBlocking = blockingCards.filter(c => c.value >= 10).length;
                severity += highValueBlocking * 1.5;
                
                return Math.min(10, severity);
            }

            wouldSequenceMoveRevealCards(sequence) {
                // This would need to check the actual pile structure
                // For now, assume any sequence move might reveal cards
                return sequence.length > 0;
            }

            getAllVisibleCards() {
                const visibleCards = [];
                
                // Tableau cards
                this.game.state.tableau.forEach(pile => {
                    pile.forEach(card => {
                        if (card.faceUp) {
                            visibleCards.push(card);
                        }
                    });
                });
                
                // Foundation cards
                Object.values(this.game.state.foundations).forEach(pile => {
                    visibleCards.push(...pile);
                });
                
                // Waste cards
                visibleCards.push(...this.game.state.waste);
                
                return visibleCards;
            }

            // Enhanced deadlock detection with Phase 2 pattern recognition
            checkAdvancedDeadlockPatterns() {
                try {
                    this.initializeAdvancedPatternRecognition();
                    
                    const patterns = {
                        cardBlocking: this.analyzeCardBlockingPatterns(),
                        sequenceDeadlocks: this.analyzeSequenceDeadlocks(),
                        foundationBottlenecks: this.analyzeFoundationBottlenecks(),
                        stockExhaustion: this.analyzeStockExhaustionPatterns()
                    };
                    
                    // Calculate overall deadlock probability based on patterns
                    const deadlockProbability = this.calculateDeadlockProbability(patterns);
                    
                    if (deadlockProbability > 0.8) {
                        console.log('🧠 Advanced pattern analysis indicates high deadlock probability:', deadlockProbability.toFixed(2));
                        console.log('🔍 Detected patterns:', patterns);
                        return true;
                    }
                    
                    // Store patterns for learning
                    this.storePatternAnalysis(patterns, deadlockProbability);
                    
                    return false;
                } catch (error) {
                    console.warn('Error in advanced pattern recognition:', error);
                    return false;
                }
            }

            analyzeFoundationBottlenecks() {
                const bottlenecks = [];
                
                Object.entries(this.game.state.foundations).forEach(([suit, pile]) => {
                    const nextNeeded = pile.length + 1;
                    
                    if (nextNeeded <= 13) {
                        // Find where the next needed card is
                        const location = this.findCardLocation(nextNeeded, suit);
                        
                        if (location && location.accessibility === 'blocked') {
                            bottlenecks.push({
                                suit: suit,
                                neededCard: { value: nextNeeded, suit: suit },
                                location: location,
                                severity: this.calculateBottleneckSeverity(nextNeeded, location)
                            });
                        }
                    }
                });
                
                return bottlenecks;
            }

            findCardLocation(value, suit) {
                // Check tableau
                for (let pileIndex = 0; pileIndex < this.game.state.tableau.length; pileIndex++) {
                    const pile = this.game.state.tableau[pileIndex];
                    for (let cardIndex = 0; cardIndex < pile.length; cardIndex++) {
                        const card = pile[cardIndex];
                        if (card.value === value && card.suit === suit) {
                            return {
                                type: 'tableau',
                                pileIndex: pileIndex,
                                cardIndex: cardIndex,
                                accessibility: card.faceUp ? 
                                    (cardIndex === pile.length - 1 ? 'accessible' : 'sequence') : 
                                    'blocked'
                            };
                        }
                    }
                }
                
                // Check waste
                for (let i = 0; i < this.game.state.waste.length; i++) {
                    const card = this.game.state.waste[i];
                    if (card.value === value && card.suit === suit) {
                        return {
                            type: 'waste',
                            index: i,
                            accessibility: i === this.game.state.waste.length - 1 ? 'accessible' : 'buried'
                        };
                    }
                }
                
                // Check stock (hidden)
                for (let i = 0; i < this.game.state.stock.length; i++) {
                    const card = this.game.state.stock[i];
                    if (card.value === value && card.suit === suit) {
                        return {
                            type: 'stock',
                            index: i,
                            accessibility: 'stock'
                        };
                    }
                }
                
                return null;
            }

            calculateBottleneckSeverity(cardValue, location) {
                let severity = 0;
                
                // Lower value cards are more critical
                severity += (6 - Math.min(5, cardValue)) * 2;
                
                // Accessibility affects severity
                switch (location.accessibility) {
                    case 'blocked': severity += 5; break;
                    case 'sequence': severity += 3; break;
                    case 'buried': severity += 4; break;
                    case 'stock': severity += 2; break;
                    case 'accessible': severity += 0; break;
                }
                
                return Math.min(10, severity);
            }

            analyzeStockExhaustionPatterns() {
                const stockCards = this.game.state.stock.length;
                const wasteCards = this.game.state.waste.length;
                const totalStockWaste = stockCards + wasteCards;
                
                if (totalStockWaste === 0) {
                    return {
                        type: 'stock_exhausted',
                        severity: 10,
                        description: 'Stock and waste are empty'
                    };
                }
                
                // Analyze if remaining stock/waste cards can help
                const usefulStockCards = this.countUsefulStockCards();
                const usefulRatio = totalStockWaste > 0 ? usefulStockCards / totalStockWaste : 0;
                
                if (usefulRatio < 0.2 && totalStockWaste < 10) {
                    return {
                        type: 'low_utility_stock',
                        severity: 7,
                        description: `Only ${usefulStockCards} useful cards in ${totalStockWaste} remaining stock/waste`,
                        usefulRatio: usefulRatio
                    };
                }
                
                return null;
            }

            countUsefulStockCards() {
                let useful = 0;
                
                // Check stock cards
                this.game.state.stock.forEach(card => {
                    if (this.isCardUseful(card)) useful++;
                });
                
                // Check waste cards
                this.game.state.waste.forEach(card => {
                    if (this.isCardUseful(card)) useful++;
                });
                
                return useful;
            }

            isCardUseful(card) {
                // Check if card can go to foundation
                if (this.canMoveToFoundation(card)) return true;
                
                // Check if card can be placed on tableau
                for (let pile of this.game.state.tableau) {
                    if (pile.length === 0 && card.value === 13) return true; // King to empty
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.canPlaceOnTableau(card, topCard)) return true;
                    }
                }
                
                return false;
            }

            calculateDeadlockProbability(patterns) {
                let probability = 0;
                
                // Card blocking patterns
                if (patterns.cardBlocking.length > 0) {
                    const avgBlockingSeverity = patterns.cardBlocking.reduce((sum, p) => sum + p.severity, 0) / patterns.cardBlocking.length;
                    probability += (avgBlockingSeverity / 10) * 0.3;
                }
                
                // Sequence deadlocks
                if (patterns.sequenceDeadlocks.length > 0) {
                    const avgSequenceSeverity = patterns.sequenceDeadlocks.reduce((sum, p) => sum + p.severity, 0) / patterns.sequenceDeadlocks.length;
                    probability += (avgSequenceSeverity / 10) * 0.25;
                }
                
                // Foundation bottlenecks
                if (patterns.foundationBottlenecks.length > 0) {
                    const avgBottleneckSeverity = patterns.foundationBottlenecks.reduce((sum, p) => sum + p.severity, 0) / patterns.foundationBottlenecks.length;
                    probability += (avgBottleneckSeverity / 10) * 0.25;
                }
                
                // Stock exhaustion
                if (patterns.stockExhaustion) {
                    probability += (patterns.stockExhaustion.severity / 10) * 0.2;
                }
                
                return Math.min(1.0, probability);
            }

            storePatternAnalysis(patterns, probability) {
                if (!this.patternRecognition) return;
                
                this.patternRecognition.historicalDeadlocks.push({
                    timestamp: Date.now(),
                    patterns: patterns,
                    probability: probability,
                    gameState: this.createGameStateSignature()
                });
                
                // Keep only recent history
                if (this.patternRecognition.historicalDeadlocks.length > 50) {
                    this.patternRecognition.historicalDeadlocks.shift();
                }
            }

            detectGameStateCycling() {
                // Enhanced version of detectStockCycling that works for all game states
                if (!this.gameStateCycleHistory) {
                    this.gameStateCycleHistory = [];
                }
                
                // Create a detailed signature of the current game state
                const currentSignature = this.createDetailedGameStateSignature();
                
                // Add current state to history
                this.gameStateCycleHistory.push({
                    signature: currentSignature,
                    timestamp: Date.now(),
                    moveCount: this.moves
                });
                
                // Keep only recent history (last 25 states)
                if (this.gameStateCycleHistory.length > 25) {
                    this.gameStateCycleHistory.shift();
                }
                
                // Check for repeated states (indicating cycling)
                const recentStates = this.gameStateCycleHistory.slice(-12); // Check last 12 states
                const signatureCount = {};
                
                recentStates.forEach(state => {
                    signatureCount[state.signature] = (signatureCount[state.signature] || 0) + 1;
                });
                
                // If any state signature appears 4+ times in recent history, it's cycling
                const maxRepeats = Math.max(...Object.values(signatureCount));
                if (maxRepeats >= 4) {
                    console.log(`🔍 Game state cycling detected: state repeated ${maxRepeats} times`);
                    return true;
                }
                
                return false;
            }
            
            detectStockCycling() {
                // Track recent game states to detect cycling
                if (!this.cycleDetectionHistory) {
                    this.cycleDetectionHistory = [];
                }
                
                // Create a signature of the current game state (simplified)
                const currentSignature = this.createGameStateSignature();
                
                // Add current state to history
                this.cycleDetectionHistory.push({
                    signature: currentSignature,
                    timestamp: Date.now()
                });
                
                // Keep only recent history (last 20 states)
                if (this.cycleDetectionHistory.length > 20) {
                    this.cycleDetectionHistory.shift();
                }
                
                // Check for repeated states (indicating cycling)
                const recentStates = this.cycleDetectionHistory.slice(-10); // Check last 10 states
                const signatureCount = {};
                
                recentStates.forEach(state => {
                    signatureCount[state.signature] = (signatureCount[state.signature] || 0) + 1;
                });
                
                // If any state signature appears 3+ times in recent history, it's likely cycling
                const maxRepeats = Math.max(...Object.values(signatureCount));
                return maxRepeats >= 3;
            }
            
            createGameStateSignature() {
                // Create a simplified signature of the game state to detect cycles
                const tableauTops = this.tableau.map(pile => {
                    if (pile.length === 0) return 'empty';
                    const topCard = pile[pile.length - 1];
                    return topCard.faceUp ? `${topCard.value}${topCard.suit}` : 'hidden';
                });
                
                const wasteTop = this.waste.length > 0 ? 
                    `${this.waste[this.waste.length - 1].value}${this.waste[this.waste.length - 1].suit}` : 'empty';
                
                const foundationLengths = Object.values(this.foundations).map(pile => pile.length);
                
                return `T:${tableauTops.join(',')}|W:${wasteTop}|F:${foundationLengths.join(',')}|S:${this.stock.length}`;
            }
            
            createDetailedGameStateSignature() {
                // Create a more detailed signature that includes more game state information
                const tableauSignature = this.tableau.map((pile, index) => {
                    if (pile.length === 0) return `${index}:empty`;
                    
                    // Include top 2-3 visible cards and hidden card count
                    const visibleCards = pile.filter(card => card.faceUp);
                    const hiddenCount = pile.length - visibleCards.length;
                    const topCards = visibleCards.slice(-3).map(card => `${card.value}${card.suit}`);
                    
                    return `${index}:h${hiddenCount}:${topCards.join('-')}`;
                }).join('|');
                
                const wasteSignature = this.waste.length > 0 ? 
                    `${this.waste[this.waste.length - 1].value}${this.waste[this.waste.length - 1].suit}` : 'empty';
                
                const foundationSignature = Object.entries(this.foundations).map(([suit, pile]) => 
                    `${suit}:${pile.length}`
                ).join(',');
                
                // Include stock position information
                const stockInfo = `${this.stock.length}`;
                
                return `T:${tableauSignature}|W:${wasteSignature}|F:${foundationSignature}|S:${stockInfo}`;
            }

            // Phase 2: Predictive Deadlock Risk Assessment
            assessDeadlockRisk(progressiveMoves, allMoves) {
                const riskFactors = [];
                let totalRisk = 0;
                let confidence = 0;
                
                // Factor 1: Progressive move ratio
                const progressiveRatio = progressiveMoves.length / Math.max(1, allMoves.length);
                if (progressiveRatio < 0.3) {
                    const risk = (0.3 - progressiveRatio) * 2; // 0-0.6 risk
                    riskFactors.push({
                        type: 'low_progressive_ratio',
                        risk: risk,
                        description: `Only ${(progressiveRatio * 100).toFixed(1)}% of moves are progressive`
                    });
                    totalRisk += risk;
                }
                
                // Factor 2: Foundation progress rate
                const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                const expectedFoundationCards = Math.max(1, this.moves * 0.15); // Expect ~15% of moves to add to foundation
                if (foundationCards < expectedFoundationCards * 0.6) {
                    const risk = 0.4;
                    riskFactors.push({
                        type: 'slow_foundation_progress',
                        risk: risk,
                        description: `Foundation progress (${foundationCards}) below expected (${expectedFoundationCards.toFixed(1)})`
                    });
                    totalRisk += risk;
                }
                
                // Factor 3: Hidden card accessibility
                const hiddenCardRisk = this.assessHiddenCardRisk();
                if (hiddenCardRisk > 0) {
                    riskFactors.push({
                        type: 'hidden_card_blocking',
                        risk: hiddenCardRisk,
                        description: 'Critical cards likely buried under high-value cards'
                    });
                    totalRisk += hiddenCardRisk;
                }
                
                // Factor 4: Stock utility declining
                const stockUtilityRisk = this.assessStockUtilityRisk();
                if (stockUtilityRisk > 0) {
                    riskFactors.push({
                        type: 'declining_stock_utility',
                        risk: stockUtilityRisk,
                        description: 'Remaining stock cards have low utility'
                    });
                    totalRisk += stockUtilityRisk;
                }
                
                // Factor 5: Tableau congestion
                const congestionRisk = this.assessTableauCongestion();
                if (congestionRisk > 0) {
                    riskFactors.push({
                        type: 'tableau_congestion',
                        risk: congestionRisk,
                        description: 'Tableau piles are congested with limited mobility'
                    });
                    totalRisk += congestionRisk;
                }
                
                // Calculate confidence based on number of risk factors and game progress
                const moveProgress = Math.min(1.0, (this.moves || 0) / 100);
                const factorConfidence = Math.min(1.0, riskFactors.length * 0.2);
                confidence = Math.min(1.0, factorConfidence + moveProgress);
                
                // Ensure confidence is never NaN
                if (isNaN(confidence) || confidence < 0) {
                    confidence = 0.5; // Default confidence
                }
                
                // Determine risk level
                let level = 'low';
                let reason = 'Game appears winnable';
                
                if (totalRisk > 1.5) {
                    level = 'critical';
                    reason = riskFactors.map(f => f.description).join('; ');
                } else if (totalRisk > 1.0) {
                    level = 'high';
                    reason = riskFactors.map(f => f.description).join('; ');
                } else if (totalRisk > 0.5) {
                    level = 'medium';
                    reason = riskFactors.map(f => f.description).join('; ');
                }
                
                return {
                    level: level,
                    totalRisk: totalRisk,
                    confidence: confidence,
                    reason: reason,
                    factors: riskFactors
                };
            }

            assessHiddenCardRisk() {
                let risk = 0;
                const visibleCards = this.getAllVisibleCards();
                const missingLowCards = this.findMissingLowValueCards(visibleCards);
                
                // Check each tableau pile for potential blocking
                this.game.state.tableau.forEach(pile => {
                    if (pile.length <= 1) return;
                    
                    const hiddenCards = pile.filter(c => !c.faceUp);
                    const topVisibleCard = pile.find(c => c.faceUp);
                    
                    if (hiddenCards.length > 0 && topVisibleCard) {
                        // High risk if high-value card is on top of many hidden cards
                        if (topVisibleCard.value >= 10 && hiddenCards.length >= 3) {
                            risk += 0.3;
                        }
                        
                        // Extra risk if we need low cards and they might be buried
                        if (missingLowCards.length > 0 && hiddenCards.length >= 2) {
                            risk += 0.2;
                        }
                    }
                });
                
                return Math.min(0.8, risk);
            }

            assessStockUtilityRisk() {
                const totalStockWaste = this.game.state.stock.length + this.game.state.waste.length;
                if (totalStockWaste === 0) return 0.6; // High risk if no stock left
                
                const usefulCards = this.countUsefulStockCards();
                const utilityRatio = usefulCards / totalStockWaste;
                
                if (utilityRatio < 0.2 && totalStockWaste < 15) {
                    return 0.4; // High risk if few useful cards left
                } else if (utilityRatio < 0.3) {
                    return 0.2; // Medium risk
                }
                
                return 0;
            }

            assessTableauCongestion() {
                let congestionScore = 0;
                let emptySpaces = 0;
                
                this.game.state.tableau.forEach(pile => {
                    if (pile.length === 0) {
                        emptySpaces++;
                    } else {
                        const faceUpCards = pile.filter(c => c.faceUp);
                        const topCard = pile[pile.length - 1];
                        
                        // Congestion if long sequences with no good moves
                        if (faceUpCards.length > 4 && topCard.faceUp) {
                            let canMove = false;
                            
                            // Check if top card can move anywhere
                            if (this.canMoveToFoundation(topCard)) {
                                canMove = true;
                            } else {
                                // Check if can move to other tableau piles
                                for (let otherPile of this.game.state.tableau) {
                                    if (otherPile !== pile) {
                                        if (otherPile.length === 0 && topCard.value === 13) {
                                            canMove = true;
                                            break;
                                        } else if (otherPile.length > 0) {
                                            const otherTop = otherPile[otherPile.length - 1];
                                            if (otherTop.faceUp && this.canPlaceOnTableau(topCard, otherTop)) {
                                                canMove = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            if (!canMove) {
                                congestionScore += 0.15;
                            }
                        }
                    }
                });
                
                // Less risk if there are empty spaces
                if (emptySpaces === 0) {
                    congestionScore += 0.2;
                } else if (emptySpaces === 1) {
                    congestionScore += 0.1;
                }
                
                return Math.min(0.6, congestionScore);
            }

            // Helper methods for Phase 2 pattern recognition
            // Note: canMoveToFoundation method is defined earlier in the class

            canPlaceOnTableau(card, targetCard) {
                if (!card || !targetCard) return false;
                
                // Must be opposite color and one value lower
                const cardColor = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                const targetColor = (targetCard.suit === '♥' || targetCard.suit === '♦') ? 'red' : 'black';
                
                return cardColor !== targetColor && card.value === targetCard.value - 1;
            }
            
            handleDeadlock() {
                console.log('🚫 Deadlock detected!');
                
                if (this.game.timer) clearInterval(this.game.timer);
                
                // Record deadlock for ML learning
                if (this.game.ml && !this.game.ml.isDisposed) {
                    try {
                        const gameHistory = this.game.gameHistory.map(state => ({
                            type: 'game_state',
                            gameStats: state.gameStats,
                            timestamp: Date.now()
                        }));
                        
                        // Analyze where the user went wrong
                        const analysis = this.analyzeDeadlockCause(gameHistory);
                        
                        // Record the deadlock as a loss for learning
                        this.game.ml.recordGameOutcome(this, gameHistory, false, {
                            reason: 'deadlock',
                            analysis: analysis,
                            finalState: {
                                foundationCards: Object.values(this.foundations).reduce((sum, pile) => sum + pile.length, 0),
                                hiddenCards: this.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0),
                                stockRemaining: this.stock.length,
                                wasteCards: this.waste.length
                            }
                        });
                        
                        console.log('🧠 Recorded deadlock for AI learning with analysis:', analysis);
                    } catch (mlError) {
                        console.warn('Error recording deadlock for ML:', mlError);
                    }
                }
                
                // Record loss in persistent learning system
                if (this.game.persistentLearning && this.game.persistentLearning.isInitialized) {
                    const lossGameData = {
                        won: false,
                        moves: this.moves,
                        timeElapsed: performance.now() - this.game.startTime,
                        finalState: {
                            foundations: { ...this.foundations },
                            tableau: this.tableau.map(pile => [...pile]),
                            waste: [...this.waste],
                            stock: [...this.stock]
                        },
                        moveSequence: this.game.gameHistory.map(state => ({
                            type: state.action?.type || 'unknown',
                            timestamp: state.timestamp
                        })),
                        strategyUsed: this.game.lastStrategyUsed || 'manual',
                        aiAssisted: this.game.aiHintUsed || false,
                        lossReason: 'deadlock'
                    };
                    
                    this.game.persistentLearning.recordGameResult(lossGameData);
                }
                
                // Update statistics
                this.game.stats.updateGameStatistics(false);
                
                // Show deadlock notification
                setTimeout(() => {
                    this.game.ui.showDeadlockModal();
                }, 500);
            }
            
            analyzeDeadlockCause(gameHistory) {
                try {
                    const analysis = {
                        criticalMovePoint: null,
                        missedOpportunities: [],
                        suboptimalMoves: [],
                        stockCycles: 0,
                        foundationMissedMoves: 0
                    };
                    
                    // Analyze game history to find critical decisions
                    for (let i = 0; i < gameHistory.length; i++) {
                        const state = gameHistory[i];
                        
                        // Count stock cycles (going through waste pile)
                        if (i > 0 && state.gameStats.moves > gameHistory[i-1].gameStats.moves) {
                            // This was a move, check if it was drawing from empty stock
                            if (gameHistory[i-1].stock && gameHistory[i-1].stock.length === 0 && 
                                state.stock && state.stock.length > 0) {
                                analysis.stockCycles++;
                            }
                        }
                        
                        // Look for missed foundation opportunities
                        // (This would require more complex analysis of what cards were available)
                        
                        // Identify potential critical decision points
                        // Points where multiple high-value moves were available
                        if (i > 2 && i < gameHistory.length - 5) {
                            // This is a potential critical decision point
                            const progressBefore = this.calculateGameProgress(gameHistory[i-1]);
                            const progressAfter = this.calculateGameProgress(gameHistory[i+3]);
                            
                            if (progressAfter - progressBefore < 0.1) { // Low progress made
                                analysis.criticalMovePoint = i;
                            }
                        }
                    }
                    
                    // Determine primary cause
                    if (analysis.stockCycles > 3) {
                        analysis.primaryCause = 'excessive_stock_cycling';
                        analysis.suggestion = 'Try to focus on tableau moves and foundation building before cycling through the stock multiple times.';
                    } else if (analysis.criticalMovePoint) {
                        analysis.primaryCause = 'suboptimal_mid_game_decisions';
                        analysis.suggestion = `Critical decisions around move ${gameHistory[analysis.criticalMovePoint].gameStats.moves} may have limited future options.`;
                    } else {
                        analysis.primaryCause = 'unfavorable_initial_deal';
                        analysis.suggestion = 'This deal may have been particularly challenging. Focus on uncovering hidden cards early.';
                    }
                    
                    return analysis;
                } catch (error) {
                    console.warn('Error analyzing deadlock cause:', error);
                    return { primaryCause: 'analysis_error', suggestion: 'Unable to analyze the cause of deadlock.' };
                }
            }
            
            calculateGameProgress(state) {
                if (!state || !state.gameStats) return 0;
                
                // Simple progress metric based on foundations and exposed cards
                const foundationProgress = Object.values(state.foundations || {})
                    .reduce((sum, pile) => sum + pile.length, 0) / 52;
                const moveEfficiency = Math.min(state.gameStats.score / (state.gameStats.moves || 1), 1);
                
                return foundationProgress * 0.7 + moveEfficiency * 0.3;
            }
            
            saveToLocalStorage() {
                try {
                    const gameState = {
                        drawMode: this.drawMode,
                        currentGameMode: this.game.currentGameMode,
                        currentDifficulty: this.game.currentDifficulty,
                        stock: this.stock.map(card => ({ ...card })),
                        waste: this.waste.map(card => ({ ...card })),
                        tableau: this.tableau.map(pile => pile.map(card => ({ ...card }))),
                        foundations: Object.fromEntries(
                            Object.entries(this.foundations).map(([suit, pile]) => 
                                [suit, pile.map(card => ({ ...card }))]
                            )
                        ),
                        gameStats: { ...this.gameStats },
                        timestamp: Date.now()
                    };
                    
                    this.game.storage.set('klondike_save', gameState);
                } catch (error) {
                    console.error('Error saving game:', error);
                }
            }
            
            resetAllGameState() {
                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }
                
                this.stock = [];
                this.waste = [];
                this.tableau = Array.from({ length: 7 }, () => []);
                this.foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                this.gameStats = { moves: 0, time: 0, score: 0 };
                this.gameHistory = [];
                this.hintCardId = null;
                this.game.gameWon = false;
                this.hoveredCard = null;
                
                this.game.input.resetDragState();
                
                if (this.game.renderer.cardPositions) {
                    this.game.renderer.cardPositions.clear();
                }
            }
        }

        // Game rules
        class GameRules {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            canPlaceOnFoundation(card) {
                const pile = this.game.state.foundations[card.suit];
                const topCard = pile[pile.length - 1];
                return (card.value === 1 && pile.length === 0) || 
                       (topCard && card.value === topCard.value + 1);
            }
            
            canPlaceOnTableau(card, targetPile) {
                if (targetPile.length === 0) {
                    return card.value === 13;
                }
                const topCard = targetPile[targetPile.length - 1];
                return topCard.faceUp && 
                       topCard.value === card.value + 1 && 
                       this.game.constants.RED_SUITS.has(topCard.suit) !== this.game.constants.RED_SUITS.has(card.suit);
            }
            
            isValidSequence(cards) {
                if (cards.length <= 1) return true;
                
                for (let i = 1; i < cards.length; i++) {
                    const prevCard = cards[i - 1];
                    const currCard = cards[i];
                    
                    if (prevCard.value !== currCard.value + 1 ||
                        this.game.constants.RED_SUITS.has(prevCard.suit) === this.game.constants.RED_SUITS.has(currCard.suit)) {
                        return false;
                    }
                }
                return true;
            }
            
            isSafeToAutoMove(card) {
                if (card.value <= 2) return true;
                
                const oppositeColors = this.game.constants.RED_SUITS.has(card.suit) ? ['♠', '♣'] : ['♥', '♦'];
                const requiredValue = card.value - 1;
                
                return oppositeColors.every(suit => {
                    const pile = this.game.state.foundations[suit];
                    return pile.length >= requiredValue;
                });
            }
            
            checkAutoMoveToFoundation() {
                if (!this.game.settings.data.autoMoveToFoundation) return false;
                
                let moved = false;
                
                if (this.game.state.waste.length > 0) {
                    const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (this.canPlaceOnFoundation(topCard) && this.isSafeToAutoMove(topCard)) {
                        this.game.ai.moveCardToFoundation(topCard);
                        moved = true;
                    }
                }
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.canPlaceOnFoundation(topCard) && this.isSafeToAutoMove(topCard)) {
                            this.game.ai.moveCardToFoundation(topCard);
                            moved = true;
                            break;
                        }
                    }
                }
                
                return moved;
            }
        }

                    /*
             * ===== AI/ML SYSTEM UPGRADES (v2024.12.19.19.00) =====
             * 
             * CRITICAL FIXES IMPLEMENTED:
             * 
             * 1. DEADLOCK PATTERN RECORDING FIX:
             *    - Fixed TypeError in recordDeadlockPatterns() where stockCycleThresholds was undefined
             *    - Added proper array initialization and validation
             *    - Enhanced error handling with proper logging
             * 
             * 2. CONFIDENCE CALCULATION FIX:
             *    - Fixed NaN confidence values in deadlock risk assessment
             *    - Added proper null checks and fallback values
             *    - Improved mathematical stability in risk calculations
             * 
             * 3. AUTO-PLAY CYCLING PREVENTION:
             *    - Added game state signature tracking to detect cycles
             *    - Implemented filterCyclicMoves() to prevent infinite loops
             *    - Added cycle detection counter with automatic stock draw fallback
             *    - Enhanced move selection with anti-cycling bias
             * 
             * 4. MEMORY CACHE OPTIMIZATION:
             *    - Added prewarmPools() method to initialize object pools
             *    - Improved cache hit rates through better pool management
             *    - Enhanced memory monitoring and cleanup routines
             * 
             * 5. PERFORMANCE IMPROVEMENTS:
             *    - Better error handling throughout AI systems
             *    - Optimized game state compression/decompression
             *    - Enhanced pattern recognition and storage
             * 
             * These fixes address the major issues:
             * - TypeError crashes in deadlock recording
             * - NaN confidence percentages
             * - Infinite auto-play cycling
             * - 0% memory cache hit rates
             * - Performance degradation over time
             */

            // AI hint system with Auto-Complete capabilities
        class AIHintSystem {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.autoSolveDepth = 150; // Maximum moves to look ahead
                this.winningPaths = new Map(); // Cache of winning sequences
                
                // Web Worker for background AI processing
                this.worker = null;
                this.pendingRequests = new Map();
                this.requestIdCounter = 0;
                this.workerSupported = false;
                
                this.initializeWorker();
            }
            
            initializeWorker() {
                try {
                    console.log('🔄 Attempting to initialize AI Web Worker...');
                    if (typeof Worker !== 'undefined') {
                        try {
                            // Try to create worker with detailed error handling
                            this.worker = new Worker('ai-worker.js');
                            
                            this.worker.onmessage = (event) => {
                                console.log('📨 Worker message received:', event.data.type);
                                this.handleWorkerMessage(event);
                            };
                            
                            this.worker.onerror = (error) => {
                                console.error('❌ AI Worker file error:', error);
                                console.error('Worker error details:', error.message, error.filename, error.lineno);
                                console.log('🔄 Trying inline worker as fallback...');
                                this.tryInlineWorker();
                            };
                            
                            this.worker.onmessageerror = (error) => {
                                console.error('❌ AI Worker message error:', error);
                                this.workerSupported = false;
                            };
                            
                            // Test the worker with a simple message
                            setTimeout(() => {
                                if (this.worker && this.workerSupported) {
                                    console.log('🧪 Testing worker communication...');
                                    this.testWorker();
                                }
                            }, 100);
                            
                            this.workerSupported = true;
                            console.log('🤖 AI Web Worker initialized successfully');
                            
                        } catch (workerError) {
                            console.warn('❌ Failed to load ai-worker.js:', workerError);
                            console.log('🔄 Trying inline worker as fallback...');
                            this.tryInlineWorker();
                        }
                    } else {
                        console.log('🤖 Web Workers not supported in this browser, using main thread');
                        this.workerSupported = false;
                    }
                } catch (error) {
                    console.error('❌ Failed to initialize AI Worker:', error);
                    console.log('🔄 Falling back to main thread processing');
                    this.workerSupported = false;
                }
            }
            
            tryInlineWorker() {
                try {
                    // Create a simple inline worker for basic AI functionality
                    const workerCode = `
                        self.onmessage = function(event) {
                            const { type, data, requestId } = event.data;
                            
                            try {
                                let result = { message: 'Inline worker - limited functionality' };
                                
                                if (type === 'test') {
                                    result = { message: 'Inline worker is responsive', timestamp: Date.now() };
                                } else {
                                    result = { error: 'Inline worker has limited functionality - using main thread' };
                                }
                                
                                self.postMessage({
                                    type: 'response',
                                    requestId,
                                    success: type === 'test',
                                    data: result
                                });
                            } catch (error) {
                                self.postMessage({
                                    type: 'response',
                                    requestId,
                                    success: false,
                                    error: error.message
                                });
                            }
                        };
                    `;
                    
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    this.worker = new Worker(URL.createObjectURL(blob));
                    
                    this.worker.onmessage = (event) => {
                        console.log('📨 Inline worker message received:', event.data.type);
                        this.handleWorkerMessage(event);
                    };
                    
                    this.worker.onerror = (error) => {
                        console.error('❌ Inline worker error:', error);
                        this.workerSupported = false;
                    };
                    
                    this.workerSupported = true;
                    console.log('🤖 Inline AI Worker created as fallback');
                    
                    // Test the inline worker
                    setTimeout(() => {
                        if (this.worker && this.workerSupported) {
                            console.log('🧪 Testing inline worker communication...');
                            this.testWorker();
                        }
                    }, 100);
                    
                } catch (inlineError) {
                    console.error('❌ Failed to create inline worker:', inlineError);
                    this.workerSupported = false;
                    console.log('🔄 Using main thread processing only');
                }
            }
            
            testWorker() {
                try {
                    // Send a simple test message to verify worker is responsive
                    const testRequest = {
                        type: 'test',
                        data: { message: 'hello' },
                        requestId: 'test-' + Date.now()
                    };
                    
                    this.worker.postMessage(testRequest);
                    
                    // Set a timeout to check if worker responds
                    setTimeout(() => {
                        if (this.workerSupported) {
                            console.log('✅ Worker communication test passed');
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('❌ Worker test failed:', error);
                    this.workerSupported = false;
                }
            }
            
            handleWorkerMessage(event) {
                const { requestId, success, data, error, requestType } = event.data;
                
                if (this.pendingRequests.has(requestId)) {
                    const { resolve, reject, type } = this.pendingRequests.get(requestId);
                    this.pendingRequests.delete(requestId);
                    
                    if (success) {
                        console.log(`✅ AI Worker completed ${type} in background`);
                        resolve(data);
                    } else {
                        console.error(`❌ AI Worker error for ${type}:`, error);
                        reject(new Error(error));
                    }
                }
            }
            
            async requestFromWorker(type, data) {
                return new Promise((resolve, reject) => {
                    if (!this.workerSupported || !this.worker) {
                        reject(new Error('Worker not available'));
                        return;
                    }
                    
                    const requestId = ++this.requestIdCounter;
                    this.pendingRequests.set(requestId, { resolve, reject, type });
                    
                    this.worker.postMessage({
                        type,
                        data,
                        requestId
                    });
                    
                    // Timeout after 60 seconds for complex analysis
                    setTimeout(() => {
                        if (this.pendingRequests.has(requestId)) {
                            this.pendingRequests.delete(requestId);
                            reject(new Error('Worker request timeout'));
                        }
                    }, 60000);
                });
            }
            
            // NEW: Auto-Complete Game Solver - Actually plays the game automatically
            async autoCompleteGame(maxDepth = this.autoSolveDepth, analysisOnly = false) {
                console.log('🤖 Auto-Play AI finding and executing winning moves...');
                
                const startTime = performance.now();
                const currentState = this.cloneGameState();
                
                try {
                    // Phase 2: Try to use enhanced AI Worker Manager first
                    if (this.game.aiWorkerManager && this.game.aiWorkerManager.isInitialized) {
                        console.log('🚀 Phase 2: Using enhanced AI Worker Manager for winning path analysis...');
                        
                        // Progressive search strategy to avoid timeouts
                        let searchDepth = maxDepth;
                        let attempts = 0;
                        const maxAttempts = 3;
                        
                        while (attempts < maxAttempts) {
                            console.log(`🔍 Attempt ${attempts + 1}: Searching ${searchDepth} moves deep`);
                            
                            try {
                                const result = await this.game.aiWorkerManager.findWinningPathAsync(currentState, searchDepth);
                                
                                const timeTaken = (performance.now() - startTime).toFixed(0);
                                
                                if (result.canWin) {
                                    console.log(`🎯 Auto-Complete found winning path in ${result.timeTaken}ms: ${result.moveCount} moves (depth: ${searchDepth})`);
                                    
                                    // Auto-execute the winning moves
                                    this.autoExecuteMoves(result.moves);
                                    
                                    return {
                                        canWin: true,
                                        moves: result.moves,
                                        moveCount: result.moveCount,
                                        timeTaken: timeTaken,
                                        confidence: result.confidence
                                    };
                                } else {
                                    console.log(`🔍 No path found at depth ${searchDepth}, trying different strategy...`);
                                    
                                    // Adjust search strategy for next attempt
                                    if (attempts === 0) {
                                        searchDepth = Math.max(75, Math.floor(searchDepth * 0.6)); // Reduce depth
                                    } else {
                                        searchDepth = Math.min(300, Math.floor(searchDepth * 1.4)); // Increase depth
                                    }
                                    attempts++;
                                    continue;
                                }
                            } catch (workerError) {
                                if (workerError.message.includes('timeout')) {
                                    console.log(`⏱️ Worker timeout at depth ${searchDepth}, adjusting strategy...`);
                                    searchDepth = Math.max(50, Math.floor(searchDepth * 0.5)); // Halve depth
                                    attempts++;
                                    continue;
                                } else {
                                    console.warn('Worker failed with non-timeout error:', workerError);
                                    break; // Exit loop for non-timeout errors
                                }
                            }
                        }
                        
                        console.warn('Worker exhausted all attempts, falling back to main thread');
                        // Fall through to main thread implementation
                    }
                    
                    // Fallback to main thread with intelligent auto-play
                    console.log('🔄 Using main thread for intelligent auto-play...');
                    
                    if (!analysisOnly) {
                        // Use step-by-step intelligent play instead of full path finding
                        const success = await this.playGameIntelligently(maxDepth);
                        const timeTaken = (performance.now() - startTime).toFixed(0);
                        
                        if (success) {
                            console.log(`🎉 Auto-play completed successfully in ${timeTaken}ms!`);
                            return { canWin: true, timeTaken: timeTaken };
                        } else {
                            console.log(`⚠️ Auto-play made progress but didn't complete (${timeTaken}ms)`);
                            return { canWin: false, reason: 'Game not winnable or too complex', timeTaken: timeTaken };
                        }
                    } else {
                        // Analysis mode - find complete path without executing
                        const winningSequence = await this.findWinningPath(currentState, [], Math.min(maxDepth, 100));
                        const timeTaken = (performance.now() - startTime).toFixed(0);
                        
                        if (winningSequence) {
                            console.log(`🎯 Analysis found winning path in ${timeTaken}ms: ${winningSequence.length} moves`);
                            return {
                                canWin: true,
                                moves: winningSequence,
                                moveCount: winningSequence.length,
                                timeTaken: timeTaken,
                                confidence: this.calculatePathConfidence(winningSequence)
                            };
                        } else {
                            console.log(`❌ No winning path found within ${maxDepth} moves (${timeTaken}ms)`);
                            return {
                                canWin: false,
                                reason: `No winning sequence found within ${maxDepth} moves`,
                                timeTaken: timeTaken,
                                suggestedMoves: await this.getBestProgressiveMoves(currentState, 3)
                            };
                        }
                    }
                } catch (error) {
                    console.error('Auto-Complete error:', error);
                    return { canWin: false, error: error.message };
                }
            }
            
            // Enhanced recursive pathfinding with intelligent pruning
            async findWinningPath(gameState, moveSequence, depthRemaining) {
                // Check if game is won
                if (this.isGameWon(gameState)) {
                    return moveSequence;
                }
                
                // Depth limit reached
                if (depthRemaining <= 0) {
                    return null;
                }
                
                // Generate all possible moves from current state
                const possibleMoves = this.generateAllPossibleMoves(gameState);
                if (possibleMoves.length === 0) {
                    return null; // Dead end
                }
                
                // Calculate game progress for intelligent branching
                const foundationCards = Object.values(gameState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                const gameProgress = foundationCards / 52;
                
                // Sort moves by strategic value (most promising first)
                const rankedMoves = this.rankMovesByWinPotential(possibleMoves, gameState);
                
                // Intelligent branching: fewer branches in early game, more in late game
                const maxBranches = gameProgress < 0.3 ? 4 : gameProgress < 0.6 ? 6 : 8;
                const movesToTry = rankedMoves.slice(0, maxBranches);
                
                // Always prioritize foundation moves regardless of branching limit
                const foundationMoves = rankedMoves.filter(m => 
                    m.type === 'tableau_to_foundation' || m.type === 'waste_to_foundation'
                );
                
                if (foundationMoves.length > 0) {
                    // Try foundation moves first
                    for (const move of foundationMoves) {
                        const newState = this.applyMoveToState(gameState, move);
                        const newSequence = [...moveSequence, move];
                        
                        const winningPath = await this.findWinningPath(newState, newSequence, depthRemaining - 1);
                        if (winningPath) {
                            return winningPath;
                        }
                    }
                }
                
                // Try other strategic moves
                const otherMoves = movesToTry.filter(m => 
                    m.type !== 'tableau_to_foundation' && m.type !== 'waste_to_foundation'
                );
                
                for (let i = 0; i < otherMoves.length; i++) {
                    const move = otherMoves[i];
                    
                    // Skip obviously counterproductive moves
                    if (this.isCounterproductiveMove(move, gameState, gameProgress)) {
                        continue;
                    }
                    
                    const newState = this.applyMoveToState(gameState, move);
                    const newSequence = [...moveSequence, move];
                    
                    // Progress check: skip moves that make things significantly worse
                    const progressScore = this.calculateProgressChange(newState, gameState);
                    if (progressScore < -5 && depthRemaining > 50) {
                        continue;
                    }
                    
                    // Recursive search
                    const winningPath = await this.findWinningPath(newState, newSequence, depthRemaining - 1);
                    if (winningPath) {
                        return winningPath;
                    }
                    
                    // Yield control more frequently for foundation-heavy games
                    if (i % (foundationMoves.length > 0 ? 2 : 4) === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                return null; // No winning path found
            }
            
            // Check if a move is counterproductive given game state
            isCounterproductiveMove(move, gameState, gameProgress) {
                // Don't move Aces away from foundation opportunities
                if (move.card && move.card.value === 1) {
                    if (move.type !== 'tableau_to_foundation' && move.type !== 'waste_to_foundation') {
                        return true;
                    }
                }
                
                // In early game, avoid stock draws when foundation moves available
                if (gameProgress < 0.3 && move.type === 'draw_stock') {
                    const foundationCards = Object.values(gameState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    if (foundationCards < 8) { // Very early game
                        return true;
                    }
                }
                
                // Don't break sequences that could lead to foundation
                if (move.type === 'tableau_to_tableau' && move.card) {
                    const foundationPile = gameState.foundations[move.card.suit];
                    if (foundationPile && foundationPile.length === move.card.value - 1) {
                        return true; // This card should go to foundation instead
                    }
                }
                
                return false;
            }
            
            // Calculate progress change between game states
            calculateProgressChange(newState, oldState) {
                const oldFoundationCards = Object.values(oldState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                const newFoundationCards = Object.values(newState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                
                const oldHiddenCards = oldState.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0);
                const newHiddenCards = newState.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0);
                
                const foundationProgress = (newFoundationCards - oldFoundationCards) * 10;
                const revealProgress = (oldHiddenCards - newHiddenCards) * 3;
                
                return foundationProgress + revealProgress;
            }
            
            // Auto-execute a sequence of moves
            async autoExecuteMoves(moves) {
                if (!moves || moves.length === 0) {
                    console.log('❌ No moves to execute');
                    return;
                }
                
                console.log(`🤖 Auto-executing ${moves.length} moves...`);
                
                for (let i = 0; i < moves.length; i++) {
                    const move = moves[i];
                    
                    try {
                        // Execute the move
                        await this.executeMove(move);
                        
                        // Show progress
                        if (i % 10 === 0 || i === moves.length - 1) {
                            console.log(`📈 Progress: ${i + 1}/${moves.length} moves executed`);
                        }
                        
                        // Small delay to make moves visible
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Check if game is won
                        if (this.isGameWon(this.cloneGameState())) {
                            console.log('🎉 Game won through auto-execution!');
                            this.game.ui.showWinModal();
                            break;
                        }
                        
                    } catch (error) {
                        console.error(`❌ Failed to execute move ${i + 1}:`, move, error);
                        break;
                    }
                }
            }
            
            // Intelligent step-by-step game playing
            async playGameIntelligently(maxMoves = 200) {
                console.log(`🤖 Starting intelligent auto-play (max ${maxMoves} moves)...`);
                
                let movesPlayed = 0;
                let consecutiveNonProgressMoves = 0;
                const maxNonProgressMoves = 20; // Prevent infinite loops
                const gameStateHistory = new Map(); // Track game states to prevent cycling
                let cycleDetectionCounter = 0;
                
                while (movesPlayed < maxMoves && !this.isGameWon(this.cloneGameState())) {
                    // Get current game state for analysis
                    const currentState = this.cloneGameState();
                    
                    // Create a state signature for cycle detection
                    const stateSignature = this.createGameStateSignature(currentState);
                    
                    // Check for cycling
                    if (gameStateHistory.has(stateSignature)) {
                        cycleDetectionCounter++;
                        console.log(`🔄 Detected game state cycle (${cycleDetectionCounter}/3)`);
                        
                        if (cycleDetectionCounter >= 3) {
                            console.log('❌ Breaking out of infinite cycle - trying stock draw');
                            // Force a stock draw to break the cycle
                            try {
                                this.game.ai.flipStock();
                                movesPlayed++;
                                cycleDetectionCounter = 0;
                                gameStateHistory.clear();
                                continue;
                            } catch (error) {
                                console.log('❌ Cannot break cycle - stopping auto-play');
                                return false;
                            }
                        }
                    } else {
                        cycleDetectionCounter = 0;
                    }
                    
                    // Store current state
                    gameStateHistory.set(stateSignature, movesPlayed);
                    
                    // Limit history size
                    if (gameStateHistory.size > 50) {
                        const oldestKey = gameStateHistory.keys().next().value;
                        gameStateHistory.delete(oldestKey);
                    }
                    
                    // Generate all possible moves
                    const possibleMoves = this.generateAllPossibleMoves(currentState);
                    
                    if (possibleMoves.length === 0) {
                        console.log('❌ No moves available - game stuck');
                        return false;
                    }
                    
                    // Rank moves by strategic value with anti-cycling bias
                    const rankedMoves = this.rankMovesByWinPotential(possibleMoves, currentState);
                    
                    // Apply anti-cycling filter
                    const filteredMoves = this.filterCyclicMoves(rankedMoves, gameStateHistory);
                    
                    // Calculate foundation cards before move
                    const foundationCardsBefore = Object.values(currentState.foundations)
                        .reduce((sum, pile) => sum + pile.length, 0);
                    
                    // Execute the best move
                    const bestMove = filteredMoves.length > 0 ? filteredMoves[0] : rankedMoves[0];
                    
                    if (!bestMove) {
                        console.log('❌ No valid moves available - game stuck');
                        return false;
                    }
                    
                    try {
                        console.log(`🎯 Move ${movesPlayed + 1}: ${this.describeMoveAction(bestMove)}`);
                        await this.executeMove(bestMove);
                        movesPlayed++;
                        
                        // Check progress after move
                        const foundationCardsAfter = Object.values(this.game.state.foundations)
                            .reduce((sum, pile) => sum + pile.length, 0);
                        
                        if (foundationCardsAfter > foundationCardsBefore) {
                            consecutiveNonProgressMoves = 0; // Reset counter on progress
                            console.log(`📈 Foundation progress: ${foundationCardsAfter}/52 cards`);
                        } else {
                            consecutiveNonProgressMoves++;
                        }
                        
                        // Check if we're stuck in a loop
                        if (consecutiveNonProgressMoves >= maxNonProgressMoves) {
                            console.log(`⚠️ No foundation progress for ${maxNonProgressMoves} moves - trying deeper analysis`);
                            
                            // Try to find a sequence that makes progress
                            const progressSequence = await this.findProgressSequence(5);
                            if (progressSequence && progressSequence.length > 0) {
                                console.log(`🔄 Executing progress sequence of ${progressSequence.length} moves`);
                                for (const move of progressSequence) {
                                    await this.executeMove(move);
                                    movesPlayed++;
                                }
                                consecutiveNonProgressMoves = 0;
                            } else {
                                console.log('❌ Unable to find progress sequence - stopping auto-play');
                                return false;
                            }
                        }
                        
                        // Check if game is won
                        if (this.isGameWon(this.cloneGameState())) {
                            console.log(`🎉 Game won in ${movesPlayed} moves!`);
                            this.game.ui.showWinModal();
                            return true;
                        }
                        
                        // Small delay for visual feedback
                        await new Promise(resolve => setTimeout(resolve, 150));
                        
                        // Show progress every 25 moves
                        if (movesPlayed % 25 === 0) {
                            const foundationCount = Object.values(this.game.state.foundations)
                                .reduce((sum, pile) => sum + pile.length, 0);
                            console.log(`📊 Progress update: ${movesPlayed} moves played, ${foundationCount}/52 cards in foundations`);
                        }
                        
                    } catch (error) {
                        console.error(`❌ Failed to execute move:`, error);
                        return false;
                    }
                }
                
                if (movesPlayed >= maxMoves) {
                    console.log(`⏱️ Reached maximum moves (${maxMoves}) without winning`);
                    return false;
                }
                
                return false; // Shouldn't reach here
            }
            
            // Create a compact signature of the game state for cycle detection
            createGameStateSignature(gameState) {
                try {
                    const signature = {
                        foundations: Object.values(gameState.foundations || {}).map(pile => pile ? pile.length : 0),
                        tableau: (gameState.tableau || []).map(pile => {
                            if (!pile || pile.length === 0) return 'empty';
                            const topCard = pile[pile.length - 1];
                            return topCard ? `${topCard.value}${topCard.suit}${topCard.faceUp ? 'u' : 'd'}` : 'empty';
                        }),
                        waste: gameState.waste && gameState.waste.length > 0 ? 
                            `${gameState.waste[gameState.waste.length - 1].value}${gameState.waste[gameState.waste.length - 1].suit}` : 'empty',
                        stockSize: gameState.stock ? gameState.stock.length : 0
                    };
                    
                    return JSON.stringify(signature);
                } catch (error) {
                    console.warn('Error creating game state signature:', error);
                    return `fallback_${Date.now()}_${Math.random()}`;
                }
            }
            
            // Filter out moves that would create cycles
            filterCyclicMoves(moves, stateHistory) {
                if (stateHistory.size < 2) return moves;
                
                // Prioritize moves that haven't been seen recently
                const recentStates = Array.from(stateHistory.keys()).slice(-5);
                
                return moves.filter(move => {
                    // Simulate the move to see if it creates a known state
                    try {
                        const testState = this.applyMoveToState(this.cloneGameState(), move);
                        const testSignature = this.createGameStateSignature(testState);
                        
                        // Avoid moves that lead to recently seen states
                        return !recentStates.includes(testSignature);
                    } catch (error) {
                        // If we can't test the move, allow it
                        return true;
                    }
                });
            }

            // Find a sequence of moves that makes foundation progress
            async findProgressSequence(maxDepth = 5) {
                const currentState = this.cloneGameState();
                const currentFoundationCards = Object.values(currentState.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                
                // Try to find a short sequence that increases foundation cards
                return await this.searchProgressPath(currentState, [], maxDepth, currentFoundationCards);
            }
            
            // Recursive search for progress-making moves
            async searchProgressPath(gameState, moveSequence, depthRemaining, targetFoundationCards) {
                if (depthRemaining <= 0) {
                    return null;
                }
                
                const possibleMoves = this.generateAllPossibleMoves(gameState);
                const rankedMoves = this.rankMovesByWinPotential(possibleMoves, gameState);
                
                // Try only the top few moves to keep it fast
                const topMoves = rankedMoves.slice(0, 3);
                
                for (const move of topMoves) {
                    const newState = this.applyMoveToState(gameState, move);
                    const newFoundationCards = Object.values(newState.foundations)
                        .reduce((sum, pile) => sum + pile.length, 0);
                    
                    const newSequence = [...moveSequence, move];
                    
                    // If this move makes progress, return the sequence
                    if (newFoundationCards > targetFoundationCards) {
                        return newSequence;
                    }
                    
                    // Otherwise, search deeper
                    const progressPath = await this.searchProgressPath(
                        newState, 
                        newSequence, 
                        depthRemaining - 1, 
                        targetFoundationCards
                    );
                    
                    if (progressPath) {
                        return progressPath;
                    }
                }
                
                return null;
            }

            // Execute a single move from the move object
            async executeMove(move) {
                try {
                    switch (move.type) {
                        case 'tableau_to_foundation':
                            this.game.ai.moveCardToFoundation(move.card);
                            break;
                            
                        case 'waste_to_foundation':
                            this.game.ai.moveCardToFoundation(move.card);
                            break;
                            
                        case 'tableau_to_tableau':
                            // Find the card and move it to the target tableau
                            const sourceCard = move.card;
                            this.game.ai.moveCardToTableau(sourceCard, move.to?.index);
                            break;
                            
                        case 'waste_to_tableau':
                            // Move waste card to tableau
                            if (this.game.state.waste.length > 0) {
                                const wasteCard = this.game.state.waste[this.game.state.waste.length - 1];
                                this.game.ai.moveCardToTableau(wasteCard, move.to?.index);
                            }
                            break;
                            
                        case 'draw_stock':
                            // Execute multiple draws if specified
                            const drawCount = move.drawCount || 1;
                            for (let i = 0; i < drawCount; i++) {
                                this.game.ai.flipStock();
                                await new Promise(resolve => setTimeout(resolve, 50)); // Brief delay between draws
                            }
                            break;
                            
                        case 'reset_stock':
                            this.game.ai.flipStock(); // This handles both draw and reset
                            break;
                            
                        default:
                            console.warn('Unknown move type:', move.type);
                    }
                } catch (error) {
                    console.error('Error executing move:', error);
                    throw error;
                }
            }

            // Enhanced hint system using auto-complete analysis
            async getSmartHint() {
                console.log('🧠 Generating AI hint with auto-complete analysis...');
                
                // Try to get a quick hint from worker first
                if (this.workerSupported && this.worker) {
                    try {
                        console.log('🚀 Getting quick hint from Web Worker...');
                        const workerHint = await this.requestFromWorker('getHint', {
                            gameState: this.cloneGameState()
                        });
                        
                        if (workerHint && workerHint.bestMove) {
                            console.log('✅ Worker provided hint successfully');
                            return {
                                type: 'worker_strategic',
                                move: workerHint.bestMove,
                                message: `🤖 AI Recommends: ${this.describeMoveAction(workerHint.bestMove)}`,
                                details: `Win probability: ${Math.round(workerHint.winProbability)}%. ${workerHint.stockRecommendation.reason}${workerHint.stockRecommendation.drawsNeeded > 0 ? ` (${workerHint.stockRecommendation.drawsNeeded} draws)` : ''}`,
                                priority: 'medium',
                                winProbability: workerHint.winProbability,
                                stockRecommendation: workerHint.stockRecommendation,
                                strategicPlan: workerHint.strategicPlan,
                                multiMoveAnalysis: workerHint.multiMoveAnalysis,
                                showFullAnalysis: true // Flag to show full breakdown
                            };
                        } else {
                            console.log('⚠️ Worker returned no valid hint, falling back to main thread');
                        }
                    } catch (workerError) {
                        console.warn('❌ Worker hint failed, trying auto-complete:', workerError);
                        // Disable worker if it's consistently failing
                        if (workerError.message.includes('timeout') || workerError.message.includes('Worker not available')) {
                            console.log('🔄 Disabling worker due to persistent issues');
                            this.workerSupported = false;
                        }
                    }
                } else {
                    console.log('🔄 Worker not available, using main thread for hints');
                }
                
                // First, try auto-complete for immediate win detection (analysis mode)
                const autoComplete = await this.autoCompleteGame(150, true); // Full depth for analysis only
                
                if (autoComplete.canWin && autoComplete.moves.length > 0) {
                    const nextMove = autoComplete.moves[0];
                    const movesLeft = autoComplete.moves.length;
                    
                    return {
                        type: 'winning_path',
                        move: nextMove,
                        confidence: autoComplete.confidence,
                        message: `🎯 WINNING MOVE: ${this.describeMoveAction(nextMove)}`,
                        details: `This leads to victory in ${movesLeft} moves (${autoComplete.confidence}% confidence)`,
                        priority: 'critical',
                        fullPath: autoComplete.moves.slice(0, 5), // Show first 5 moves
                        pathLength: movesLeft
                    };
                } else {
                    // Fallback to current analysis if no winning path found
                    const currentAnalysis = this.analyzeCompleteGameState();
                    const bestMove = this.findBestCurrentMove(currentAnalysis);
                    
                    return {
                        type: 'strategic',
                        move: bestMove,
                        message: `💡 Strategic Move: ${this.describeMoveAction(bestMove)}`,
                        details: currentAnalysis.stockAnalysis.recommendation.reason,
                        priority: 'medium',
                        suggestion: autoComplete.suggestedMoves ? `Progress moves: ${autoComplete.suggestedMoves.map(m => this.describeMoveAction(m)).join(', ')}` : null
                    };
                }
            }
            
            // Find best move from current analysis (fallback when no winning path)
            findBestCurrentMove(analysis) {
                // Generate all possible moves
                const allMoves = this.generateAllPossibleMoves(this.cloneGameState());
                
                if (allMoves.length === 0) {
                    return null;
                }
                
                // Rank moves by strategic value
                const rankedMoves = this.rankMovesByWinPotential(allMoves, this.cloneGameState());
                
                return rankedMoves[0] || allMoves[0];
            }
            
                         // Get progressive moves when no complete winning path found
             async getBestProgressiveMoves(state, count = 3) {
                 const moves = this.generateAllPossibleMoves(state);
                 const rankedMoves = this.rankMovesByWinPotential(moves, state);
                 return rankedMoves.slice(0, count);
             }
            
            // Utility functions for auto-complete
            cloneGameState() {
                try {
                    // Clone only the essential game state, avoiding circular references
                    const state = this.game.state;
                    if (!state) {
                        console.warn('Game state is undefined, returning default state');
                        return {
                            tableau: Array.from({ length: 7 }, () => []),
                            foundations: { '♠': [], '♥': [], '♦': [], '♣': [] },
                            stock: [],
                            waste: [],
                            drawMode: 3,
                            moves: 0,
                            score: 0
                        };
                    }
                    return {
                        tableau: state.tableau.map(pile => 
                            pile.map(card => ({
                                id: card.id,
                                suit: card.suit,
                                value: card.value,
                                faceUp: card.faceUp
                            }))
                        ),
                        foundations: Object.fromEntries(
                            Object.entries(state.foundations).map(([suit, pile]) => [
                                suit,
                                pile.map(card => ({
                                    id: card.id,
                                    suit: card.suit,
                                    value: card.value,
                                    faceUp: card.faceUp
                                }))
                            ])
                        ),
                        stock: state.stock.map(card => ({
                            id: card.id,
                            suit: card.suit,
                            value: card.value,
                            faceUp: card.faceUp
                        })),
                        waste: state.waste.map(card => ({
                            id: card.id,
                            suit: card.suit,
                            value: card.value,
                            faceUp: card.faceUp
                        })),
                        drawMode: state.drawMode || 3,
                        moves: state.gameStats?.moves || 0,
                        score: state.gameStats?.score || 0
                    };
                } catch (error) {
                    console.error('Error cloning game state:', error);
                    return {
                        tableau: Array.from({ length: 7 }, () => []),
                        foundations: { '♠': [], '♥': [], '♦': [], '♣': [] },
                        stock: [],
                        waste: [],
                        drawMode: 3,
                        moves: 0,
                        score: 0
                    };
                }
            }
            
            deepCloneState(state) {
                try {
                    return {
                        tableau: state.tableau.map(pile => 
                            pile.map(card => ({
                                id: card.id,
                                suit: card.suit,
                                value: card.value,
                                faceUp: card.faceUp
                            }))
                        ),
                        foundations: Object.fromEntries(
                            Object.entries(state.foundations).map(([suit, pile]) => [
                                suit,
                                pile.map(card => ({
                                    id: card.id,
                                    suit: card.suit,
                                    value: card.value,
                                    faceUp: card.faceUp
                                }))
                            ])
                        ),
                        stock: state.stock.map(card => ({
                            id: card.id,
                            suit: card.suit,
                            value: card.value,
                            faceUp: card.faceUp
                        })),
                        waste: state.waste.map(card => ({
                            id: card.id,
                            suit: card.suit,
                            value: card.value,
                            faceUp: card.faceUp
                        })),
                        drawMode: state.drawMode || 3,
                        moves: state.moves || 0,
                        score: state.score || 0
                    };
                } catch (error) {
                    console.error('Error deep cloning state:', error);
                    return state; // Return original state on error
                }
            }
            
            isGameWon(state) {
                return Object.values(state.foundations).every(pile => pile.length === 13);
            }
            
            generateAllPossibleMoves(state) {
                const moves = [];
                
                // Tableau to foundation moves
                for (let i = 0; i < state.tableau.length; i++) {
                    const pile = state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp) {
                            Object.keys(state.foundations).forEach(suit => {
                                if (this.canPlaceOnFoundationState(topCard, state.foundations[suit])) {
                                    moves.push({
                                        type: 'tableau_to_foundation',
                                        from: { source: 'tableau', index: i },
                                        to: { source: 'foundation', suit: suit },
                                        card: topCard
                                    });
                                }
                            });
                        }
                    }
                }
                
                // Waste to foundation moves
                if (state.waste.length > 0) {
                    const topCard = state.waste[state.waste.length - 1];
                    Object.keys(state.foundations).forEach(suit => {
                        if (this.canPlaceOnFoundationState(topCard, state.foundations[suit])) {
                            moves.push({
                                type: 'waste_to_foundation',
                                from: { source: 'waste' },
                                to: { source: 'foundation', suit: suit },
                                card: topCard
                            });
                        }
                    });
                }
                
                // Tableau to tableau moves
                for (let i = 0; i < state.tableau.length; i++) {
                    const fromPile = state.tableau[i];
                    if (fromPile.length > 0) {
                        const topCard = fromPile[fromPile.length - 1];
                        if (topCard.faceUp) {
                            for (let j = 0; j < state.tableau.length; j++) {
                                if (i !== j && this.canPlaceOnTableauState(topCard, state.tableau[j])) {
                                    moves.push({
                                        type: 'tableau_to_tableau',
                                        from: { source: 'tableau', index: i },
                                        to: { source: 'tableau', index: j },
                                        card: topCard
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Stock draw move
                if (state.stock.length > 0 || state.waste.length > 0) {
                    moves.push({
                        type: 'draw_stock',
                        from: { source: 'stock' },
                        to: { source: 'waste' }
                    });
                }
                
                return moves;
            }
            
            rankMovesByWinPotential(moves, state) {
                return moves.sort((a, b) => {
                    let scoreA = this.calculateMoveScore(a, state);
                    let scoreB = this.calculateMoveScore(b, state);
                    return scoreB - scoreA; // Higher score first
                });
            }
            
            calculateMoveScore(move, state) {
                let score = 0;
                
                // Get adaptive weights from learning system
                const adaptiveWeights = this.game.persistentLearning?.getAdaptiveWeights() || {
                    foundationPriority: 1.0,
                    revealingBonus: 1.0,
                    sequenceBuilding: 1.0,
                    stockDrawPenalty: 1.0
                };
                
                // FOUNDATION MOVES - Highest priority (these win the game)
                if (move.type === 'tableau_to_foundation' || move.type === 'waste_to_foundation') {
                    score += 10000 * adaptiveWeights.foundationPriority; // Adaptive priority
                    
                    // CRITICAL: Aces get highest priority (they unlock everything)
                    if (move.card && move.card.value === 1) {
                        score += 5000;
                    }
                    // Low cards get high priority (build foundation early)
                    else if (move.card && move.card.value <= 4) {
                        score += 3000;
                    }
                    // Sequential foundation building bonus
                    if (move.card) {
                        const foundationPile = state.foundations[move.card.suit];
                        if (foundationPile && foundationPile.length === move.card.value - 1) {
                            score += 2000; // Perfect sequence match
                        }
                    }
                }
                
                // REVEALING MOVES - Second highest priority
                if (move.type === 'tableau_to_tableau' || move.type === 'tableau_to_foundation') {
                    const fromPile = state.tableau[move.from?.index];
                    if (fromPile && fromPile.length > 1 && !fromPile[fromPile.length - 2].faceUp) {
                        score += 1500 * adaptiveWeights.revealingBonus; // Adaptive revealing bonus
                        
                        // Extra bonus if revealing might expose an Ace or foundation card
                        const hiddenCard = fromPile[fromPile.length - 2];
                        if (hiddenCard && (hiddenCard.value === 1 || hiddenCard.value <= 4)) {
                            score += 1000; // Might reveal foundation card
                        }
                    }
                }
                
                // KINGS TO EMPTY SPACES - Strategic building moves
                if (move.card && move.card.value === 13 && move.to && state.tableau[move.to.index].length === 0) {
                    score += 800;
                }
                
                // SEQUENCE BUILDING - Tableau moves that build good sequences
                if (move.type === 'tableau_to_tableau' || move.type === 'waste_to_tableau') {
                    const targetPile = state.tableau[move.to?.index];
                    if (targetPile && targetPile.length > 0 && move.card) {
                        const topCard = targetPile[targetPile.length - 1];
                        if (topCard.faceUp) {
                            // Check if this creates a good sequence (alternating colors, descending)
                            const cardColor = (move.card.suit === '♠' || move.card.suit === '♣') ? 'black' : 'red';
                            const topColor = (topCard.suit === '♠' || topCard.suit === '♣') ? 'black' : 'red';
                            
                            if (cardColor !== topColor && move.card.value === topCard.value - 1) {
                                score += 400 * adaptiveWeights.sequenceBuilding; // Adaptive sequence bonus
                            }
                        }
                    }
                }
                
                // STRONGLY PENALIZE COUNTERPRODUCTIVE MOVES
                if (this.isCounterproductiveMoveMain(move, state)) {
                    score -= 2000;
                }
                
                // PENALIZE STOCK DRAWS when better options exist
                if (move.type === 'draw_stock') {
                    // Check if there are foundation or revealing moves available
                    score += 50 / adaptiveWeights.stockDrawPenalty; // Adaptive stock penalty
                }
                
                return score;
            }
            
            // Check if a move is counterproductive (main thread version)
            isCounterproductiveMoveMain(move, state) {
                // Don't move Aces away from foundation opportunities
                if (move.card && move.card.value === 1) {
                    if (move.type !== 'tableau_to_foundation' && move.type !== 'waste_to_foundation') {
                        return true;
                    }
                }
                
                // Don't break sequences that could lead to foundation
                if (move.type === 'tableau_to_tableau' && move.card) {
                    const foundationPile = state.foundations[move.card.suit];
                    if (foundationPile && foundationPile.length === move.card.value - 1) {
                        return true; // This card should go to foundation instead
                    }
                }
                
                // Don't move cards that could go to foundation to tableau instead
                if (move.type === 'waste_to_tableau' && move.card) {
                    for (const [suit, foundationPile] of Object.entries(state.foundations)) {
                        if (this.canPlaceOnFoundationState(move.card, foundationPile)) {
                            return true; // Should go to foundation instead
                        }
                    }
                }
                
                return false;
            }
            
            applyMoveToState(state, move) {
                const newState = this.deepCloneState(state); // Use safe clone method
                
                try {
                    switch (move.type) {
                        case 'tableau_to_foundation':
                            const tableauPile = newState.tableau[move.from.index];
                            const card = tableauPile.pop();
                            newState.foundations[move.to.suit].push(card);
                            // Flip hidden card if revealed
                            if (tableauPile.length > 0 && !tableauPile[tableauPile.length - 1].faceUp) {
                                tableauPile[tableauPile.length - 1].faceUp = true;
                            }
                            break;
                            
                        case 'waste_to_foundation':
                            const wasteCard = newState.waste.pop();
                            newState.foundations[move.to.suit].push(wasteCard);
                            break;
                            
                        case 'tableau_to_tableau':
                            const fromPile = newState.tableau[move.from.index];
                            const toPile = newState.tableau[move.to.index];
                            const movingCard = fromPile.pop();
                            toPile.push(movingCard);
                            // Flip hidden card if revealed
                            if (fromPile.length > 0 && !fromPile[fromPile.length - 1].faceUp) {
                                fromPile[fromPile.length - 1].faceUp = true;
                            }
                            break;
                            
                        case 'draw_stock':
                            if (newState.stock.length > 0) {
                                const drawCount = Math.min(newState.drawMode || 3, newState.stock.length);
                                const drawnCards = newState.stock.splice(-drawCount);
                                newState.waste.push(...drawnCards);
                            } else if (newState.waste.length > 0) {
                                newState.stock = newState.waste.reverse();
                                newState.waste = [];
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Error applying move:', error, move);
                    return state; // Return original state on error
                }
                
                return newState;
            }
            
            canPlaceOnFoundationState(card, foundationPile) {
                if (foundationPile.length === 0) {
                    return card.value === 1; // Ace
                }
                const topCard = foundationPile[foundationPile.length - 1];
                return topCard.suit === card.suit && topCard.value === card.value - 1;
            }
            
            canPlaceOnTableauState(card, tableauPile) {
                if (tableauPile.length === 0) {
                    return card.value === 13; // King
                }
                const topCard = tableauPile[tableauPile.length - 1];
                if (!topCard.faceUp) return false;
                
                const cardColor = (card.suit === '♠' || card.suit === '♣') ? 'black' : 'red';
                const topColor = (topCard.suit === '♠' || topCard.suit === '♣') ? 'black' : 'red';
                
                return cardColor !== topColor && card.value === topCard.value - 1;
            }
            
            calculatePathConfidence(winningPath) {
                // Shorter paths = higher confidence
                const lengthFactor = Math.max(20, 100 - winningPath.length * 2);
                
                // More foundation moves = higher confidence
                const foundationMoves = winningPath.filter(move => move.type.includes('foundation')).length;
                const foundationFactor = foundationMoves * 5;
                
                return Math.min(95, lengthFactor + foundationFactor);
            }
            
            describeMoveAction(move) {
                if (!move) return 'No move available';
                
                // Helper function to get card display name
                const getCardName = (card) => {
                    if (!card) return 'unknown card';
                    const rank = card.rank || this.game.constants.RANKS[card.value - 1] || 'unknown';
                    const suit = card.suit || '?';
                    return `${rank}${suit}`;
                };
                
                switch (move.type) {
                    case 'tableau_to_foundation':
                        return `Place ${getCardName(move.card)} on foundation`;
                    case 'waste_to_foundation':
                        return `Move ${getCardName(move.card)} from waste to foundation`;
                    case 'tableau_to_tableau':
                        return `Move ${getCardName(move.card)} to tableau column ${move.to ? move.to.index + 1 : 'unknown'}`;
                    case 'draw_stock':
                        if (move.drawsNeeded && move.drawsNeeded > 1) {
                            return `Draw from stock pile (${move.drawsNeeded} times)`;
                        }
                        return 'Draw from stock pile';
                    default:
                        return move.description || 'Unknown move';
                }
            }
            
            // New method: Analyze complete deck state with stock preview
            analyzeCompleteGameState() {
                const analysis = {
                    stockAnalysis: this.analyzeStock(),
                    foundationNeeds: this.analyzeFoundationNeeds(),
                    tableauOpportunities: this.analyzeTableauOpportunities(),
                    winProbabilityFactors: this.calculateWinFactors()
                };
                
                return analysis;
            }
            
            // Analyze what cards are coming in the stock
            analyzeStock() {
                const stockCards = [...this.game.state.stock];
                const wasteCards = [...this.game.state.waste];
                const drawMode = this.game.state.drawMode || 3;
                
                // Simulate stock drawing to see upcoming cards
                const upcomingCards = [];
                const stockCopy = [...stockCards];
                const wasteCopy = [...wasteCards];
                
                // Simulate next 10 draws to see what's coming
                for (let draw = 0; draw < 10 && (stockCopy.length > 0 || wasteCopy.length > 0); draw++) {
                    if (stockCopy.length === 0) {
                        // Reset stock from waste
                        stockCopy.push(...wasteCopy.reverse());
                        wasteCopy.length = 0;
                    }
                    
                    const cardsDrawn = stockCopy.splice(-Math.min(drawMode, stockCopy.length));
                    if (cardsDrawn.length > 0) {
                        const topCard = cardsDrawn[cardsDrawn.length - 1];
                        upcomingCards.push({
                            card: topCard,
                            drawNumber: draw + 1,
                            useful: this.isCardUseful(topCard)
                        });
                        wasteCopy.push(...cardsDrawn);
                    }
                }
                
                return {
                    totalCards: stockCards.length,
                    upcomingCards: upcomingCards,
                    nextUsefulCard: upcomingCards.find(item => item.useful),
                    recommendation: this.generateStockRecommendation(upcomingCards)
                };
            }
            
            // Check if a card would be immediately useful
            isCardUseful(card) {
                // Check if can go to foundation
                if (this.game.rules.canPlaceOnFoundation(card)) {
                    return { type: 'foundation', reason: `Can place ${card.rank}${card.suit} on foundation` };
                }
                
                // Check if can go to tableau
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    if (this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                        const onEmpty = this.game.state.tableau[i].length === 0;
                        return { 
                            type: 'tableau', 
                            reason: `Can place ${card.rank}${card.suit} on ${onEmpty ? 'empty tableau' : 'tableau'}`,
                            priority: onEmpty && card.value === 13 ? 'high' : 'medium'
                        };
                    }
                }
                
                // Check if would uncover useful hidden cards
                const wouldReveal = this.wouldRevealUsefulCards(card);
                if (wouldReveal.length > 0) {
                    return { 
                        type: 'reveal', 
                        reason: `Placing ${card.rank}${card.suit} would reveal: ${wouldReveal.join(', ')}`,
                        priority: 'high'
                    };
                }
                
                return null;
            }
            
            // Check what hidden cards would be revealed by using a card
            wouldRevealUsefulCards(card) {
                const reveals = [];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        
                        // If this card can be placed on the tableau pile
                        if (this.game.rules.canPlaceOnTableau(card, pile)) {
                            // Check what would be revealed in other piles if we moved topCard
                            for (let j = 0; j < this.game.state.tableau.length; j++) {
                                if (i !== j) {
                                    const otherPile = this.game.state.tableau[j];
                                    if (this.game.rules.canPlaceOnTableau(topCard, otherPile)) {
                                        // Check if moving topCard would reveal a hidden card
                                        if (pile.length > 1 && !pile[pile.length - 2].faceUp) {
                                            const hiddenCard = pile[pile.length - 2];
                                            reveals.push(`${hiddenCard.rank}${hiddenCard.suit}`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                return reveals;
            }
            
            // Generate strategic stock drawing recommendation
            generateStockRecommendation(upcomingCards) {
                const nextUseful = upcomingCards.find(item => item.useful);
                
                if (!nextUseful) {
                    return {
                        shouldDraw: false,
                        drawsNeeded: 0,
                        reason: "No immediately useful cards in next 10 draws. Focus on tableau moves first.",
                        priority: 'low'
                    };
                }
                
                const drawsNeeded = nextUseful.drawNumber;
                const useful = nextUseful.useful;
                
                if (drawsNeeded === 1) {
                                            return {
                            shouldDraw: true,
                            drawsNeeded: 1,
                            reason: `Next card (${nextUseful.card.rank}${nextUseful.card.suit}) is immediately useful: ${useful.reason}`,
                            priority: useful.priority || 'high'
                        };
                } else if (drawsNeeded <= 3) {
                    return {
                        shouldDraw: true,
                        drawsNeeded: drawsNeeded,
                        reason: `Draw ${drawsNeeded} time${drawsNeeded > 1 ? 's' : ''} to get ${nextUseful.card.rank}${nextUseful.card.suit}: ${useful.reason}`,
                        priority: useful.priority || 'medium'
                    };
                } else {
                    return {
                        shouldDraw: false,
                        drawsNeeded: drawsNeeded,
                        reason: `Useful card (${nextUseful.card.rank}${nextUseful.card.suit}) is ${drawsNeeded} draws away. Focus on tableau first.`,
                        priority: 'low'
                    };
                }
            }
            
            // Analyze what foundations need
            analyzeFoundationNeeds() {
                const needs = {};
                Object.keys(this.game.state.foundations).forEach(suit => {
                    const pile = this.game.state.foundations[suit];
                    const nextValue = pile.length + 1;
                    if (nextValue <= 13) {
                        needs[suit] = nextValue;
                    }
                });
                return needs;
            }
            
            // Analyze tableau opportunities
            analyzeTableauOpportunities() {
                const opportunities = [];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    
                    if (pile.length === 0) {
                        opportunities.push({
                            type: 'empty_space',
                            pileIndex: i,
                            needs: 'King',
                            priority: 'medium'
                        });
                    } else {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp) {
                            const needsValue = topCard.value - 1;
                            const needsColor = (topCard.suit === '♠' || topCard.suit === '♣') ? 'red' : 'black';
                            const needsSuits = needsColor === 'red' ? ['♥', '♦'] : ['♠', '♣'];
                            
                            if (needsValue > 0) {
                                opportunities.push({
                                    type: 'tableau_placement',
                                    pileIndex: i,
                                    needsValue: needsValue,
                                    needsSuits: needsSuits,
                                    priority: pile.filter(c => !c.faceUp).length > 0 ? 'high' : 'medium'
                                });
                            }
                        }
                    }
                }
                
                return opportunities;
            }
            
            // Calculate win probability factors
            calculateWinFactors() {
                const factors = {
                    foundationProgress: 0,
                    hiddenCards: 0,
                    blockedCards: 0,
                    availableMoves: 0
                };
                
                // Foundation progress
                const totalFoundationCards = Object.values(this.game.state.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                factors.foundationProgress = totalFoundationCards / 52;
                
                // Hidden cards (lower is better)
                factors.hiddenCards = this.game.state.tableau
                    .reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0);
                
                // Available moves
                factors.availableMoves = this.findAllPossibleMoves().length;
                
                                 return factors;
             }
             
             // Filter out non-strategic moves
             filterStrategicMoves(moves, completeAnalysis) {
                 // Remove lateral moves that don't provide value
                 const filtered = moves.filter(move => {
                     // Always keep foundation moves
                     if (move.type === 'foundation') return true;
                     
                     // Always keep stock drawing
                     if (move.type === 'stock-draw' || move.type === 'stock-reset') return true;
                     
                     // For tableau moves, check if they're actually strategic
                     if (move.type === 'tableau' || move.type === 'waste-to-tableau') {
                         return this.isStrategicMove(move, completeAnalysis);
                     }
                     
                     return true;
                 });
                 
                 return filtered;
             }
             
             // Check if a move is actually strategic (not just legal)
             isStrategicMove(move, completeAnalysis) {
                 const card = move.card;
                 if (!card) return false;
                 
                 // Check if this move reveals hidden cards
                 const cardLocation = this.game.cards.findCardLocation(card);
                 if (cardLocation && cardLocation.type === 'tableau') {
                     const pile = this.game.state.tableau[cardLocation.pileIndex];
                     if (pile.length > 1 && !pile[pile.length - 2].faceUp) {
                         return true; // Reveals hidden card
                     }
                 }
                 
                 // Check if this move enables foundation building
                 const foundationNeeds = completeAnalysis.foundationNeeds;
                 const wouldEnableFoundation = Object.keys(foundationNeeds).some(suit => {
                     const neededValue = foundationNeeds[suit];
                     return neededValue === card.value && suit === card.suit;
                 });
                 
                 if (wouldEnableFoundation) return true;
                 
                 // Check if this move puts a King on an empty space
                 const targetEmpty = this.getTargetPileEmpty(move);
                 if (targetEmpty && card.value === 13) return true;
                 
                 // Otherwise, it might be a lateral move - check if it actually helps
                 return this.evaluateLateralMoveValue(move, completeAnalysis);
             }
             
             // Evaluate if a lateral move provides strategic value
             evaluateLateralMoveValue(move, completeAnalysis) {
                 // For now, be conservative - reject most lateral moves unless they clearly help
                 // This prevents the AI from suggesting moving cards back and forth
                 return false;
             }
             
             // Check if target pile is empty
             getTargetPileEmpty(move) {
                 // This would need to be implemented based on move details
                 // For now, return false as we don't have enough info
                 return false;
             }
             
             // Evaluate strategic value of a move
             evaluateStrategicMove(move, completeAnalysis) {
                 let strategicScore = move.priority || 1;
                 let reasoning = [];
                 
                 // Foundation moves get highest priority
                 if (move.type === 'foundation') {
                     strategicScore += 50;
                     reasoning.push('Builds foundation');
                 }
                 
                 // Stock drawing - use complete analysis
                 if (move.type === 'stock-draw' || move.type === 'stock-reset') {
                     const stockRec = completeAnalysis.stockAnalysis.recommendation;
                     if (stockRec.shouldDraw) {
                         strategicScore += stockRec.priority === 'high' ? 30 : 
                                         stockRec.priority === 'medium' ? 20 : 10;
                         reasoning.push(stockRec.reason);
                     } else {
                         strategicScore = 5; // Low priority if stock not recommended
                         reasoning.push('Stock not immediately beneficial');
                     }
                 }
                 
                 // Tableau moves
                 if (move.type === 'tableau' || move.type === 'waste-to-tableau') {
                     const card = move.card;
                     if (card) {
                         // Check if reveals hidden card
                         const cardLocation = this.game.cards.findCardLocation(card);
                         if (cardLocation && cardLocation.type === 'tableau') {
                             const pile = this.game.state.tableau[cardLocation.pileIndex];
                             if (pile.length > 1 && !pile[pile.length - 2].faceUp) {
                                 strategicScore += 25;
                                 reasoning.push('Reveals hidden card');
                             }
                         }
                         
                         // Check if King to empty space
                         if (card.value === 13) {
                             strategicScore += 20;
                             reasoning.push('King to empty space');
                         }
                         
                         // Check if enables foundation building
                         const foundationNeeds = completeAnalysis.foundationNeeds;
                         const enablesFoundation = Object.keys(foundationNeeds).some(suit => {
                             return foundationNeeds[suit] === card.value && suit === card.suit;
                         });
                         
                         if (enablesFoundation) {
                             strategicScore += 15;
                             reasoning.push('Enables foundation building');
                         }
                     }
                 }
                 
                 return {
                     strategicScore: strategicScore,
                     strategicReasoning: reasoning,
                     confidence: Math.min(strategicScore / 50, 1)
                 };
             }
             
             // Calculate win probability
             calculateWinProbability(completeAnalysis) {
                 const factors = completeAnalysis.winProbabilityFactors;
                 let probability = factors.foundationProgress * 0.4; // 40% weight on foundation progress
                 
                 // Factor in hidden cards (more hidden = lower probability)
                 probability += (1 - (factors.hiddenCards / 21)) * 0.3; // 30% weight
                 
                 // Factor in available moves
                 probability += Math.min(factors.availableMoves / 10, 0.3) * 0.3; // 30% weight
                 
                 return Math.max(0.1, Math.min(0.95, probability));
             }
             
             // Assess difficulty
             assessDifficulty(completeAnalysis) {
                 const factors = completeAnalysis.winProbabilityFactors;
                 const winProb = this.calculateWinProbability(completeAnalysis);
                 
                 if (winProb > 0.7) return 'easy';
                 if (winProb > 0.4) return 'medium';
                 if (winProb > 0.2) return 'hard';
                 return 'expert';
             }
             
             // Generate strategic recommendation
             generateRecommendation(completeAnalysis, bestMove) {
                 const stockRec = completeAnalysis.stockAnalysis.recommendation;
                 const factors = completeAnalysis.winProbabilityFactors;
                 
                 if (stockRec.shouldDraw && stockRec.priority === 'high') {
                     return `${stockRec.reason} Focus on tableau moves after.`;
                 }
                 
                 if (factors.hiddenCards > 14) {
                     return 'Focus on revealing hidden cards to improve your options.';
                 }
                 
                 if (factors.foundationProgress < 0.2) {
                     return 'Build foundations when possible to create space.';
                 }
                 
                 return 'Continue with strategic tableau building and foundation moves.';
             }
             
             async showHint() {
                try {
                    this.game.sound.play('cardFlip');
                    console.log('🧠 Phase 2 Enhanced AI Hint System with Non-blocking Analysis...');
                
                // Track that AI assistance was used
                this.game.aiHintUsed = true;
                this.game.lastStrategyUsed = 'ai-assisted';
                
                // Phase 2: Show loading indicator while AI worker processes
                this.game.ui.showNotification('🤖 AI analyzing position...', 'info', 2000);
                
                // Phase 2: Use non-blocking AI Worker Manager
                let smartHint;
                try {
                    smartHint = await this.game.aiWorkerManager.analyzePositionAsync(this.game.state);
                    console.log('✅ AI Worker completed analysis in background');
                } catch (error) {
                    console.warn('AI Worker failed, falling back to main thread:', error);
                    // Fallback to original method
                    smartHint = await this.getSmartHint();
                }
                    const completeAnalysis = this.analyzeCompleteGameState();
                    this.game.state.hintCardId = null;
                    
                    if (smartHint && smartHint.move) {
                        // Highlight the recommended move if it has a card ID
                        if (smartHint.move.card && smartHint.move.card.id) {
                            this.game.state.hintCardId = smartHint.move.card.id;
                        }
                        this.game.renderer.render();
                        
                        // Display enhanced hint message
                        const isWinningPath = smartHint.type === 'winning_path';
                        const isWorkerHint = smartHint.type === 'worker_strategic';
                        const aiIcon = isWinningPath ? '🎯' : isWorkerHint ? '🤖' : '🧠';
                        const priority = smartHint.priority === 'critical' ? '#4ade80' : '#a78bfa';
                        
                        // Display winning path or strategic information
                        let pathInfo = '';
                        if (isWinningPath) {
                            pathInfo = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(72, 222, 128, 0.2); border-radius: 6px; border: 1px solid #4ade80;">
                                    <strong>🎯 WINNING PATH DETECTED!</strong><br>
                                    <small>This move leads to victory in ${smartHint.pathLength} moves</small><br>
                                    <small><strong>Confidence:</strong> ${smartHint.confidence}%</small>
                                    ${smartHint.fullPath ? `<br><small><strong>Next moves:</strong> ${smartHint.fullPath.slice(1, 4).map(m => this.describeMoveAction(m)).join(' → ')}</small>` : ''}
                                </div>
                            `;
                        } else if (smartHint.suggestion) {
                            pathInfo = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>💡 Strategic Progress:</strong><br>
                                    <small>${smartHint.suggestion}</small>
                                </div>
                            `;
                        }
                        
                        // Enhanced stock drawing recommendation with complete analysis
                        let stockAdvice = '';
                        let stockRec, stockAnalysis;
                        
                        if (isWorkerHint && smartHint.stockRecommendation) {
                            // Use worker-provided stock recommendation
                            stockRec = smartHint.stockRecommendation;
                            stockAdvice = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>🤖 Web Worker Stock Analysis:</strong><br>
                                    <span style="color: ${stockRec.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                        ${stockRec.shouldDraw ? `✅ Draw ${stockRec.drawsNeeded || 1} time${(stockRec.drawsNeeded || 1) > 1 ? 's' : ''} from deck` : `⏸️ ${stockRec.reason}`}
                                    </span><br>
                                    <small>${stockRec.reason}${stockRec.priority ? ` • Priority: ${stockRec.priority}` : ''}</small>
                                </div>
                            `;
                        } else if (completeAnalysis.stockAnalysis) {
                            // Use main thread analysis
                            stockRec = completeAnalysis.stockAnalysis.recommendation;
                            stockAnalysis = completeAnalysis.stockAnalysis;
                            
                            let upcomingCardsText = '';
                            if (stockAnalysis.upcomingCards && stockAnalysis.upcomingCards.length > 0) {
                                const nextFew = stockAnalysis.upcomingCards.slice(0, 5);
                                const upcomingList = nextFew.map(item => {
                                    const card = item.card;
                                    const useful = item.useful ? ' ✅' : '';
                                    return `${card.rank}${card.suit}${useful}`;
                                }).join(', ');
                                upcomingCardsText = `<br><small>Next 5 cards: ${upcomingList}</small>`;
                            }
                            
                            stockAdvice = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>📚 Complete Board Vision - Stock Strategy:</strong><br>
                                    <span style="color: ${stockRec.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                        ${stockRec.shouldDraw ? `✅ Draw ${stockRec.drawsNeeded} time${stockRec.drawsNeeded > 1 ? 's' : ''}` : '⏸️ Focus on tableau first'}
                                    </span><br>
                                    <small>${stockRec.reason}</small>
                                    ${upcomingCardsText}
                                    ${stockAnalysis.nextUsefulCard ? `<br><small><strong>Next useful:</strong> ${stockAnalysis.nextUsefulCard.card.rank}${stockAnalysis.nextUsefulCard.card.suit} in ${stockAnalysis.nextUsefulCard.drawNumber} draws</small>` : ''}
                                </div>
                            `;
                        }
                        
                        // Hidden cards insights
                        let hiddenInsights = '';
                        const hiddenCardInsights = this.game.ml ? this.game.ml.analyzeHiddenCards(this.game.state) : null;
                        if (hiddenCardInsights && hiddenCardInsights.insights && hiddenCardInsights.insights.length > 0) {
                            const insights = hiddenCardInsights.insights.slice(0, 3); // Show top 3
                            hiddenInsights = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>🔍 Hidden Card Intel:</strong><br>
                                    ${insights.map(insight => `<small>• ${insight}</small>`).join('<br>')}
                                </div>
                            `;
                        }
                        
                        // Learning insights
                        let learningInfo = '';
                        const learningInsights = this.game.ml ? this.game.ml.performLearningAnalysis(this.game.state) : null;
                        if (learningInsights && learningInsights.totalLearningData > 0) {
                            learningInfo = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>📖 AI Learning:</strong><br>
                                    <small>Learned from ${learningInsights.totalLearningData} winning games</small>
                                    ${learningInsights.insights.length > 0 ? '<br>' + learningInsights.insights.map(insight => `<small>• ${insight}</small>`).join('<br>') : ''}
                                </div>
                            `;
                        }
                        
                        // Alternative moves and worker insights
                        let alternativeMoves = '';
                        if (isWorkerHint && smartHint.winProbability !== undefined) {
                            // Show worker-specific insights with strategic planning
                            let strategicInfo = '';
                            if (smartHint.strategicPlan && smartHint.strategicPlan.futureSequence.length > 0) {
                                const futureSequence = smartHint.strategicPlan.futureSequence.slice(0, 2);
                                strategicInfo = `<br><small><strong>Follow-up Plan:</strong> ${futureSequence.map(move => this.describeMoveAction(move)).join(' → ')}</small>`;
                            }
                            
                            let multiMoveInfo = '';
                            if (smartHint.multiMoveAnalysis) {
                                multiMoveInfo = `<br><small><strong>Strategic Analysis:</strong> ${smartHint.multiMoveAnalysis}</small>`;
                            }
                            
                            alternativeMoves = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(72, 222, 128, 0.1); border-radius: 6px; border: 1px solid #22c55e;">
                                    <strong>🤖 Web Worker Strategic Analysis:</strong><br>
                                    <small><strong>Win Probability:</strong> ${Math.round(smartHint.winProbability)}%</small><br>
                                    <small><strong>Processing:</strong> Background thread with look-ahead</small>
                                    ${strategicInfo}
                                    ${multiMoveInfo}
                                </div>
                            `;
                        } else {
                            // Show alternative moves for main thread analysis
                            const smartMoves = this.findAllPossibleMoves();
                            if (smartMoves && smartMoves.length > 1) {
                                const alternatives = smartMoves.slice(1, 3);
                                alternativeMoves = `
                                    <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                        <strong>🔄 Alternative Moves:</strong><br>
                                        ${alternatives.map((move, i) => {
                                            const score = move.aiScore ? Math.round(move.aiScore) : Math.round((move.priority / 20) * 100);
                                            return `<small>${i + 2}. ${move.description} (${score}%)</small>`;
                                        }).join('<br>')}
                                    </div>
                                `;
                            }
                        }
                        
                        const message = `
                            <div style="text-align: left; line-height: 1.6; font-size: 14px; max-width: 500px;">
                                <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                                    ${aiIcon} ${isWinningPath ? 'Auto-Complete AI Analysis' : 'Enhanced AI Hint System'}
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>${isWinningPath ? '🎯 WINNING MOVE' : '💡 Best Move'}:</strong><br>
                                    <span style="color: ${priority}; font-weight: bold;">${smartHint.message}</span>
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>📋 Analysis:</strong><br>
                                    <span style="color: #e5e7eb;">${smartHint.details}</span>
                                </div>
                                
                                ${pathInfo}
                                ${stockAdvice}
                                ${hiddenInsights}
                                ${learningInfo}
                                ${alternativeMoves}
                                
                                <div style="text-align: center; margin-top: 15px; font-size: 11px; opacity: 0.7;">
                                    <strong>Powered by:</strong> ${isWinningPath ? 'Auto-Complete AI with Winning Path Analysis' : isWorkerHint ? 'Web Worker AI (Background Processing)' : 'Enhanced Strategic AI'}<br>
                                    ${isWinningPath ? 'Complete game simulation • Winning path detection • Move confidence scoring' : isWorkerHint ? 'Non-blocking analysis • Background processing • Real-time hints' : 'Complete board vision • Strategic analysis • Learning algorithms'}
                                </div>
                            </div>
                        `;
                        
                        this.game.ui.showNotification(message, 'hint', 20000);
                        
                    } else if (this.game.state.stock.length > 0 || this.game.state.waste.length > 0) {
                        // No strategic moves available - provide enhanced stock analysis
                        const stockAnalysis = completeAnalysis.stockAnalysis;
                        const stockRec = stockAnalysis.recommendation;
                        
                        let upcomingCardsText = '';
                        if (stockAnalysis.upcomingCards && stockAnalysis.upcomingCards.length > 0) {
                            const nextFew = stockAnalysis.upcomingCards.slice(0, 3);
                            const upcomingList = nextFew.map(item => {
                                const card = item.card;
                                const useful = item.useful ? ' ✅' : '';
                                return `${card.rank}${card.suit}${useful}`;
                            }).join(', ');
                            upcomingCardsText = `<br><strong>Next cards:</strong> ${upcomingList}`;
                        }
                        
                        const message = `
                            <div style="text-align: left; line-height: 1.6; font-size: 14px; max-width: 500px;">
                                <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                                    🔍 Complete Board Vision Analysis
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>📚 Stock Recommendation:</strong><br>
                                    <span style="color: ${stockRec.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                        ${stockRec.shouldDraw ? `✅ Draw ${stockRec.drawsNeeded} time${stockRec.drawsNeeded > 1 ? 's' : ''} from stock` : '⏸️ Focus on tableau moves first'}
                                    </span>
                                </div>
                                
                                <div style="margin-bottom: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>🧠 AI Analysis:</strong><br>
                                    <small>${stockRec.reason}</small>
                                    ${upcomingCardsText}
                                    ${stockAnalysis.nextUsefulCard ? `<br><strong>Next useful:</strong> ${stockAnalysis.nextUsefulCard.card.rank}${stockAnalysis.nextUsefulCard.card.suit} in ${stockAnalysis.nextUsefulCard.drawNumber} draws` : ''}
                                </div>
                                
                                <div style="text-align: center; margin-top: 15px; font-size: 11px; opacity: 0.7;">
                                    <strong>Powered by:</strong> Complete Board Vision AI<br>
                                    Analyzing all hidden cards • Strategic planning • Win probability calculation
                                </div>
                            </div>
                        `;
                        
                        this.game.ui.showNotification(message, 'hint', 15000);
                    } else {
                        // No moves and no stock - advanced analysis for stuck situations
                        let stuckAnalysis = '';
                        try {
                            if (this.game.ml && this.game.ml.isInitialized) {
                                const analysis = await this.game.ml.getGameAnalysis(this.game.state);
                                stuckAnalysis = `<br><small>${analysis.recommendation}</small>`;
                            }
                        } catch (error) {
                            console.warn('Stuck analysis failed:', error);
                        }
                        
                        this.game.ui.showNotification(`❌ No moves available${stuckAnalysis}<br><small>Consider undoing recent moves or starting fresh.</small>`, 'hint', 4000);
                    }
                } catch (error) {
                    console.error('Error showing enhanced hint:', error);
                    // Emergency fallback
                    this.game.ui.showNotification('💡 Try drawing from the stock pile or look for foundation moves', 'hint', 3000);
                }
            }
            
            findAllPossibleMoves() {
                const moves = [];
                
                moves.push(...this.findFoundationMoves());
                moves.push(...this.findTableauMoves());
                moves.push(...this.findWasteMoves());
                moves.push(...this.findStockMoves());
                
                return moves;
            }
            
            findFoundationMoves() {
                const moves = [];
                
                // Check waste pile
                if (this.game.state.waste.length > 0) {
                    const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (this.game.rules.canPlaceOnFoundation(topCard)) {
                        let priority = 10 + topCard.value;
                        
                        // Extra priority for breaking deadlocks (6s that can move to foundation)
                        if (topCard.value === 6 && this.hasLateralMovesSixOrFive()) {
                            priority += 15;
                        }
                        
                        moves.push({
                            type: 'foundation',
                            cardId: topCard.id,
                            card: topCard,
                            priority: priority,
                            description: `Move ${topCard.rank}${topCard.suit} to foundation`
                        });
                    }
                }
                
                // Check tableau piles
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.game.rules.canPlaceOnFoundation(topCard)) {
                            const willReveal = pile.length > 1 && pile[pile.length - 2] && !pile[pile.length - 2].faceUp;
                            let priority = 10 + topCard.value + (willReveal ? 5 : 0);
                            
                            // Extra priority for breaking deadlocks (6s that can move to foundation)
                            if (topCard.value === 6 && this.hasLateralMovesSixOrFive()) {
                                priority += 15;
                                console.log(`🎯 Found 6 that can break deadlock: ${topCard.rank}${topCard.suit}`);
                            }
                            
                            moves.push({
                                type: 'foundation',
                                cardId: topCard.id,
                                card: topCard,
                                priority: priority,
                                description: `Move ${topCard.rank}${topCard.suit} to foundation${willReveal ? ' (reveals card)' : ''}${topCard.value === 6 && this.hasLateralMovesSixOrFive() ? ' (breaks deadlock!)' : ''}`
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            hasLateralMovesSixOrFive() {
                // Check if there are 5s or 6s that can move between multiple black 6s (deadlock pattern)
                let blackSixes = 0;
                let redFives = 0;
                
                // Count black 6s and red 5s that can move laterally
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp) {
                            // Count black 6s on tableau
                            if (topCard.value === 6 && (topCard.suit === '♠' || topCard.suit === '♣')) {
                                blackSixes++;
                            }
                            // Count red 5s that could move between them
                            if (topCard.value === 5 && (topCard.suit === '♥' || topCard.suit === '♦')) {
                                redFives++;
                            }
                        }
                    }
                }
                
                // Also check waste for red 5s
                if (this.game.state.waste.length > 0) {
                    const wasteCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (wasteCard.value === 5 && (wasteCard.suit === '♥' || wasteCard.suit === '♦')) {
                        redFives++;
                    }
                }
                
                // Deadlock pattern: multiple black 6s with red 5s that can bounce between them
                return blackSixes >= 2 && redFives >= 1;
            }
            
            findTableauMoves() {
                const moves = [];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length === 0) continue;
                    
                    const topCard = pile[pile.length - 1];
                    if (!topCard.faceUp) continue;
                    
                    for (let j = 0; j < this.game.state.tableau.length; j++) {
                        if (i !== j && this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[j])) {
                            const targetEmpty = this.game.state.tableau[j].length === 0;
                            const priority = targetEmpty && topCard.value !== 13 ? 2 : 5;
                            
                            moves.push({
                                type: 'tableau',
                                cardId: topCard.id,
                                card: topCard,
                                priority: priority,
                                description: `Move ${topCard.rank}${topCard.suit} to ${targetEmpty ? 'empty space' : 'tableau pile'}`
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            findWasteMoves() {
                const moves = [];
                
                if (this.game.state.waste.length === 0) return moves;
                
                const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    if (this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[i])) {
                        const targetEmpty = this.game.state.tableau[i].length === 0;
                        const priority = targetEmpty && topCard.value !== 13 ? 3 : 6;
                        
                        moves.push({
                            type: 'waste-to-tableau',
                            cardId: topCard.id,
                            card: topCard,
                            priority: priority,
                            description: `Move ${topCard.rank}${topCard.suit} from waste to tableau`
                        });
                    }
                }
                
                return moves;
            }
            
            findStockMoves() {
                const moves = [];
                
                // Check if we can draw from stock (stock has cards) or reset waste to stock (stock empty but waste has cards)
                if (this.game.state.stock.length > 0) {
                    let stockDescription = 'Draw card(s) from stock';
                    let drawsNeeded = 1;
                    
                    // Get AI stock recommendation if available
                    try {
                        // Try multiple sources for stock analysis
                        let stockAnalysis = null;
                        
                        if (this.game.aiHint && this.game.aiHint.analyzeStock) {
                            stockAnalysis = this.game.aiHint.analyzeStock();
                        } else if (this.analyzeStock) {
                            // Direct call to this class's analyzeStock if available
                            stockAnalysis = this.analyzeStock();
                        }
                        
                        if (stockAnalysis && stockAnalysis.recommendation) {
                            const rec = stockAnalysis.recommendation;
                            if (rec.shouldDraw && rec.drawsNeeded > 0) {
                                drawsNeeded = rec.drawsNeeded;
                                stockDescription = `Draw ${rec.drawsNeeded} time${rec.drawsNeeded > 1 ? 's' : ''} from stock`;
                            } else if (rec.drawsNeeded > 0) {
                                // Even if not recommended to draw, show the count
                                stockDescription = `Draw from stock (next useful card in ${rec.drawsNeeded} draws)`;
                            }
                        }
                    } catch (error) {
                        // Fallback: try to analyze stock directly if AI hint system isn't available
                        try {
                            const simpleAnalysis = this.quickStockAnalysis();
                            if (simpleAnalysis.drawsNeeded > 1) {
                                stockDescription = `Draw ${simpleAnalysis.drawsNeeded} time${simpleAnalysis.drawsNeeded > 1 ? 's' : ''} from stock`;
                            }
                        } catch (e) {
                            // Final fallback to generic description
                        }
                    }
                    
                    moves.push({
                        type: 'stock-draw',
                        cardId: null,
                        card: null,
                        priority: 1, // Low priority, but still a valid move
                        description: stockDescription,
                        drawsNeeded: drawsNeeded
                    });
                } else if (this.game.state.waste.length > 0) {
                    moves.push({
                        type: 'stock-reset',
                        cardId: null,
                        card: null,
                        priority: 1, // Low priority, but still a valid move
                        description: 'Reset waste pile to stock'
                    });
                }
                
                return moves;
            }

            // Quick stock analysis for when full AI system isn't available
            quickStockAnalysis() {
                const stockCards = this.game.state.stock.length;
                const drawMode = this.game.state.drawMode || 3;
                
                // Simple heuristic: if only a few cards in stock, suggest drawing them all
                if (stockCards <= 3) {
                    return { drawsNeeded: 1, reason: 'Few cards remaining' };
                } else if (stockCards <= 6) {
                    return { drawsNeeded: 2, reason: 'Moderate cards remaining' };
                } else {
                    return { drawsNeeded: 1, reason: 'Many cards remaining' };
                }
            }
            
            prioritizeMoves(moves) {
                // Check for deadlock patterns (lateral moves)
                const lateralMoves = this.detectLateralMoves(moves);
                
                // Enhanced prioritization
                const prioritizedMoves = moves.map(move => {
                    let enhancedPriority = move.priority;
                    
                    // Heavily prioritize foundation moves
                    if (move.type === 'foundation') {
                        enhancedPriority += 20;
                        
                        // Special priority for foundation moves that break deadlocks
                        if (this.isFoundationMoveBreaksDeadlock(move)) {
                            enhancedPriority += 10;
                        }
                    }
                    
                    // Penalize lateral moves (moves that don't advance game state)
                    if (lateralMoves.includes(move)) {
                        enhancedPriority -= 15;
                    }
                    
                    // Check if move creates meaningful progress
                    if (this.createsMeaningfulProgress(move)) {
                        enhancedPriority += 5;
                    }
                    
                    // Penalize repetitive patterns
                    if (this.isRepetitiveMove(move)) {
                        enhancedPriority -= 10;
                    }
                    
                    return { ...move, enhancedPriority };
                });
                
                return prioritizedMoves.sort((a, b) => {
                    if (a.enhancedPriority !== b.enhancedPriority) {
                        return b.enhancedPriority - a.enhancedPriority;
                    }
                    
                    // Secondary sort by type
                    const typeOrder = { foundation: 4, tableau: 2, 'waste-to-tableau': 1, 'stock-draw': 0.5, 'stock-reset': 0.5 };
                    return (typeOrder[b.type] || 0) - (typeOrder[a.type] || 0);
                });
            }
            
            detectLateralMoves(moves) {
                const lateralMoves = [];
                
                // Look for cards that can move between multiple tableau positions
                const cardTargets = new Map();
                
                moves.forEach(move => {
                    if (move.type === 'tableau' && move.card) {
                        const cardKey = `${move.card.value}-${move.card.suit}`;
                        if (!cardTargets.has(cardKey)) {
                            cardTargets.set(cardKey, []);
                        }
                        cardTargets.get(cardKey).push(move);
                    }
                });
                
                // Identify cards with multiple possible placements (potential lateral moves)
                cardTargets.forEach((movesForCard, cardKey) => {
                    if (movesForCard.length > 1) {
                        // These are potential lateral moves - add penalty
                        lateralMoves.push(...movesForCard);
                    }
                });
                
                return lateralMoves;
            }
            
            isFoundationMoveBreaksDeadlock(move) {
                if (move.type !== 'foundation' || !move.card) return false;
                
                // Check if this foundation move would free up cards for other foundation moves
                const cardValue = move.card.value;
                const cardSuit = move.card.suit;
                
                // Look for cards that could benefit from this foundation move
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    for (let j = 0; j < pile.length; j++) {
                        const card = pile[j];
                        if (card.faceUp && card.suit === cardSuit && card.value === cardValue + 1) {
                            // This foundation move would enable the next card in sequence
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            createsMeaningfulProgress(move) {
                if (!move.card) return false;
                
                // Foundation moves always create meaningful progress
                if (move.type === 'foundation') return true;
                
                // Moving Kings to empty spaces is meaningful
                if (move.card.value === 13 && move.description && move.description.includes('empty space')) {
                    return true;
                }
                
                // Moves that reveal hidden cards are meaningful
                if (move.description && move.description.includes('reveals card')) {
                    return true;
                }
                
                return false;
            }
            
            isRepetitiveMove(move) {
                // Simple check for recently made similar moves
                // This could be enhanced with move history tracking
                if (!this.game.state.gameHistory || this.game.state.gameHistory.length === 0) {
                    return false;
                }
                
                const recentMoves = this.game.state.gameHistory.slice(-5); // Check last 5 moves
                const currentMoveSignature = `${move.card?.value}-${move.card?.suit}-${move.type}`;
                
                return recentMoves.some(historicalMove => {
                    if (!historicalMove.move) return false;
                    const histSignature = `${historicalMove.move.card?.value}-${historicalMove.move.card?.suit}-${historicalMove.move.type}`;
                    return histSignature === currentMoveSignature;
                });
            }
            
            moveCardToFoundation(card) {
                const cardLocation = this.game.cards.findCardLocation(card);
                if (!cardLocation) return;
                
                if (cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    const isTopCard = cardLocation.cardIndex === pile.length - 1;
                    if (!isTopCard) return;
                }
                
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                if (cardLocation.type === 'waste') {
                    const wasteIndex = this.game.state.waste.findIndex(c => c.id === card.id);
                    if (wasteIndex === this.game.state.waste.length - 1) {
                        this.game.state.waste.pop();
                    }
                } else if (cardLocation.type === 'foundation') {
                    const pile = this.game.state.foundations[cardLocation.suit];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                    }
                } else if (cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                        if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
                            pile[pile.length - 1].faceUp = true;
                            this.game.state.updateScore('reveal');
                        }
                    }
                }
                
                this.game.state.foundations[card.suit].push(card);
                this.game.state.updateScore('foundation');
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 300);
            }
            
            attemptAutoMove(card) {
                try {
                    const cardLocation = this.game.cards.findCardLocation(card);
                    if (!cardLocation) return false;
                    
                    if (cardLocation.type === 'tableau') {
                        const pile = this.game.state.tableau[cardLocation.pileIndex];
                        const cardIndex = cardLocation.cardIndex;
                        const isTopCard = cardIndex === pile.length - 1;
                        
                        if (isTopCard && this.game.rules.canPlaceOnFoundation(card)) {
                            this.moveCardToFoundation(card);
                            return true;
                        }
                        
                        const cardsToMove = pile.slice(cardIndex);
                        if (this.game.rules.isValidSequence(cardsToMove)) {
                            for (let i = 0; i < this.game.state.tableau.length; i++) {
                                if (i !== cardLocation.pileIndex && this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                                    this.moveCardSequenceToTableau(card, cardLocation, i);
                                    return true;
                                }
                            }
                        }
                    } else {
                        if (this.game.rules.canPlaceOnFoundation(card)) {
                            this.moveCardToFoundation(card);
                            return true;
                        }
                        
                        for (let i = 0; i < this.game.state.tableau.length; i++) {
                            if (this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                                this.moveCardToTableau(card, i);
                                return true;
                            }
                        }
                    }
                    
                    return false;
                } catch (error) {
                    console.error('Error attempting auto-move:', error);
                    return false;
                }
            }
            
            moveCardSequenceToTableau(card, sourceLocation, targetPileIndex) {
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                const sourcePile = this.game.state.tableau[sourceLocation.pileIndex];
                const cardIndex = sourceLocation.cardIndex;
                const movingCards = sourcePile.splice(cardIndex);
                
                if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                    sourcePile[sourcePile.length - 1].faceUp = true;
                    this.game.state.updateScore('reveal');
                }
                
                this.game.state.tableau[targetPileIndex].push(...movingCards);
                this.game.state.updateScore('tableau_to_tableau');
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 100);
            }
            
            moveCardToTableau(card, targetPileIndex) {
                const cardLocation = this.game.cards.findCardLocation(card);
                if (!cardLocation) return;
                
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                let moveType = 'tableau_to_tableau';
                
                if (cardLocation.type === 'waste') {
                    if (this.game.state.waste.length > 0 && this.game.state.waste[this.game.state.waste.length - 1].id === card.id) {
                        this.game.state.waste.pop();
                        this.game.state.tableau[targetPileIndex].push(card);
                        moveType = 'waste_to_tableau';
                    }
                } else if (cardLocation.type === 'foundation') {
                    const pile = this.game.state.foundations[cardLocation.suit];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                        this.game.state.tableau[targetPileIndex].push(card);
                        moveType = 'foundation_to_tableau';
                    }
                } else if (cardLocation.type === 'tableau') {
                    this.moveCardSequenceToTableau(card, cardLocation, targetPileIndex);
                    return;
                }
                
                this.game.state.updateScore(moveType);
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 100);
            }
            
            flipStock() {
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                this.game.sound.play('cardFlip');
                
                if (this.game.state.stock.length === 0) {
                    this.game.state.stock = this.game.state.waste.map(card => ({ ...card, faceUp: false })).reverse();
                    this.game.state.waste = [];
                    
                    if (this.game.settings.data.scoringMode === 'vegas') {
                        this.game.state.gameStats.score = Math.max(-999, this.game.state.gameStats.score - 100);
                    }
                } else {
                    const cardsToDraw = Math.min(this.game.state.drawMode, this.game.state.stock.length);
                    const drawn = this.game.state.stock.splice(-cardsToDraw).map(card => ({ ...card, faceUp: true }));
                    this.game.state.waste.push(...drawn);
                }
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
            }
        }

        // Enhanced haptic feedback for mobile
        class HapticManager {
            static vibrate(pattern = 50) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(pattern);
                }
            }
            
            static cardFlip() {
                this.vibrate([10]);
            }
            
            static cardPlace() {
                this.vibrate([30]);
            }
            
            static victory() {
                this.vibrate([100, 50, 100, 50, 200]);
            }
            
            static error() {
                this.vibrate([200]);
            }
        }

        // Particle effects system
        class ParticleSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
            }
            
            createVictoryEffect(x, y) {
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        decay: 0.02,
                        color: `hsl(${Math.random() * 60 + 300}, 100%, 50%)`
                    });
                }
            }
            
            createCardPlaceEffect(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 0.5,
                        decay: 0.05,
                        color: '#4ade80'
                    });
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2; // gravity
                    particle.life -= particle.decay;
                    return particle.life > 0;
                });
            }
            
            render() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
        }

        // Input manager
        class InputManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.canvas = null;
                this.isDragging = false;
                this.draggedCards = [];
                this.dragCurrentPos = { x: 0, y: 0 };
                this.dragSourceInfo = null;
                this.dragOffset = { x: 0, y: 0 };
                
                this.boundHandlers = {
                    mouseDown: this.handleMouseDown.bind(this),
                    mouseMove: this.handleMouseMove.bind(this),
                    mouseUp: this.handleMouseUp.bind(this),
                    click: this.handleCanvasClick.bind(this),
                    doubleClick: this.handleCanvasDoubleClick.bind(this),
                    mouseLeave: this.handleMouseLeave.bind(this),
                    touchStart: this.handleTouchStart.bind(this),
                    touchMove: this.handleTouchMove.bind(this),
                    touchEnd: this.handleTouchEnd.bind(this),
                    keyDown: this.handleKeyDown.bind(this),
                    contextMenu: this.handleContextMenu.bind(this)
                };
            }
            
            initCanvas() {
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) return;
                
                this.canvas.addEventListener('mousedown', this.boundHandlers.mouseDown, false);
                this.canvas.addEventListener('mousemove', this.boundHandlers.mouseMove, false);
                this.canvas.addEventListener('mouseup', this.boundHandlers.mouseUp, false);
                this.canvas.addEventListener('click', this.boundHandlers.click, false);
                this.canvas.addEventListener('dblclick', this.boundHandlers.doubleClick, false);
                this.canvas.addEventListener('mouseleave', this.boundHandlers.mouseLeave, false);
                
                this.canvas.addEventListener('touchstart', this.boundHandlers.touchStart, { passive: false });
                this.canvas.addEventListener('touchmove', this.boundHandlers.touchMove, { passive: false });
                this.canvas.addEventListener('touchend', this.boundHandlers.touchEnd, { passive: false });
                
                document.addEventListener('keydown', this.boundHandlers.keyDown, false);
                
                this.canvas.addEventListener('contextmenu', this.boundHandlers.contextMenu, false);
                
                this.canvas.style.userSelect = 'none';
                this.canvas.style.touchAction = 'none';
                this.canvas.tabIndex = 0;
            }
            
            cleanup() {
                if (!this.canvas) return;
                
                this.canvas.removeEventListener('mousedown', this.boundHandlers.mouseDown);
                this.canvas.removeEventListener('mousemove', this.boundHandlers.mouseMove);
                this.canvas.removeEventListener('mouseup', this.boundHandlers.mouseUp);
                this.canvas.removeEventListener('click', this.boundHandlers.click);
                this.canvas.removeEventListener('dblclick', this.boundHandlers.doubleClick);
                this.canvas.removeEventListener('mouseleave', this.boundHandlers.mouseLeave);
                this.canvas.removeEventListener('touchstart', this.boundHandlers.touchStart);
                this.canvas.removeEventListener('touchmove', this.boundHandlers.touchMove);
                this.canvas.removeEventListener('touchend', this.boundHandlers.touchEnd);
                this.canvas.removeEventListener('contextmenu', this.boundHandlers.contextMenu);
                
                document.removeEventListener('keydown', this.boundHandlers.keyDown);
            }
            
            resetDragState() {
                this.isDragging = false;
                this.draggedCards = [];
                this.dragSourceInfo = null;
                this.updateCursor();
            }
            
            updateCursor() {
                if (!this.canvas) return;
                
                if (this.isDragging) {
                    this.canvas.style.cursor = 'grabbing';
                } else if (this.game.state.hoveredCard && this.game.state.hoveredCard.faceUp && this.game.state.hoveredCard.id !== 'stock') {
                    this.canvas.style.cursor = 'pointer';
                } else if (this.game.state.hoveredCard && this.game.state.hoveredCard.id === 'stock') {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0] || e.changedTouches[0];
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            }
            
            handleKeyDown(e) {
                if (document.getElementById('gameArea').style.display === 'none') return;
                
                try {
                    switch(e.key.toLowerCase()) {
                        case 'n':
                            e.preventDefault();
                            this.game.newGame();
                            break;
                        case 'u':
                        case 'z':
                            if (e.ctrlKey || e.metaKey || e.key === 'u') {
                                e.preventDefault();
                                this.game.undo();
                            }
                            break;
                        case 'r':
                            e.preventDefault();
                            this.game.redo();
                            break;
                        case 'h':
                        case '?':
                            e.preventDefault();
                            this.game.ai.showHint();
                            break;
                        case 's':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.game.storage.quickSave();
                            }
                            break;
                        case ' ':
                        case 'enter':
                            e.preventDefault();
                            if (this.game.state.stock.length > 0 || this.game.state.waste.length > 0) {
                                this.game.ai.flipStock();
                            }
                            break;
                        case 'escape':
                            if (this.isDragging) {
                                this.resetDragState();
                                this.game.renderer.render();
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Error handling keyboard input:', error);
                }
            }
            
            handleMouseDown(e) {
                if (this.game.gameWon) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo) {
                        if (cardInfo.card.id === 'stock') {
                            return;
                        }
                        
                        if (cardInfo.card.faceUp) {
                            e.preventDefault();
                            this.startDrag(cardInfo, pos.x, pos.y);
                        }
                    }
                } catch (error) {
                    console.error('Error handling mouse down:', error);
                }
            }
            
            handleMouseMove(e) {
                try {
                    const pos = this.getMousePos(e);
                    
                    if (this.isDragging) {
                        this.dragCurrentPos.x = pos.x;
                        this.dragCurrentPos.y = pos.y;
                        this.game.renderer.render();
                    } else {
                        const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                        const newHoveredCard = cardInfo ? cardInfo.card : null;
                        if (this.game.state.hoveredCard !== newHoveredCard) {
                            this.game.state.hoveredCard = newHoveredCard;
                            this.updateCursor();
                            this.game.renderer.render();
                        }
                    }
                } catch (error) {
                    console.error('Error handling mouse move:', error);
                }
            }
            
            handleMouseUp(e) {
                if (!this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const dropZone = this.game.renderer.getDropZoneAt(pos.x, pos.y);
                    if (dropZone && this.isValidDrop(dropZone)) {
                        this.executeDrop(dropZone);
                    }
                    
                    this.resetDragState();
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling mouse up:', error);
                }
            }
            
            handleCanvasClick(e) {
                if (this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo && cardInfo.card.id === 'stock') {
                        this.game.ai.flipStock();
                    }
                } catch (error) {
                    console.error('Error handling canvas click:', error);
                }
            }
            
            handleCanvasDoubleClick(e) {
                if (this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo && cardInfo.card.faceUp && cardInfo.card.id !== 'stock') {
                        this.game.ai.attemptAutoMove(cardInfo.card);
                    }
                } catch (error) {
                    console.error('Error handling double click:', error);
                }
            }
            
            handleMouseLeave(e) {
                this.game.state.hoveredCard = null;
                this.updateCursor();
                if (!this.isDragging) {
                    this.game.renderer.render();
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                try {
                    const pos = this.getTouchPos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo) {
                        if (cardInfo.card.id === 'stock') {
                            this.game.haptics.cardFlip();
                            this.game.ai.flipStock();
                        } else if (cardInfo.card.faceUp) {
                            this.game.haptics.cardPlace();
                            this.startDrag(cardInfo, pos.x, pos.y);
                        }
                    }
                } catch (error) {
                    console.error('Error handling touch start:', error);
                }
            }
            
            handleTouchMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                
                try {
                    const pos = this.getTouchPos(e);
                    this.dragCurrentPos.x = pos.x;
                    this.dragCurrentPos.y = pos.y;
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling touch move:', error);
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                if (!this.isDragging) return;
                
                try {
                    const pos = this.getTouchPos(e);
                    const dropZone = this.game.renderer.getDropZoneAt(pos.x, pos.y);
                    if (dropZone && this.isValidDrop(dropZone)) {
                        this.game.haptics.cardPlace();
                        if (this.game.particles) {
                            this.game.particles.createCardPlaceEffect(pos.x, pos.y);
                        }
                        this.executeDrop(dropZone);
                    } else {
                        this.game.haptics.error();
                    }
                    
                    this.resetDragState();
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling touch end:', error);
                }
            }
            
            handleContextMenu(e) {
                e.preventDefault();
            }
            
            startDrag(cardInfo, mouseX, mouseY) {
                try {
                    const card = cardInfo.card;
                    this.dragOffset.x = mouseX - cardInfo.x;
                    this.dragOffset.y = mouseY - cardInfo.y;
                    this.dragCurrentPos.x = mouseX;
                    this.dragCurrentPos.y = mouseY;
                    
                    if (cardInfo.location === 'waste') {
                        if (this.game.state.waste.length > 0 && this.game.state.waste[this.game.state.waste.length - 1].id === card.id) {
                            this.dragSourceInfo = { type: 'waste' };
                            this.draggedCards = [card];
                        }
                    } else if (cardInfo.location === 'foundation') {
                        this.dragSourceInfo = { type: 'foundation', suit: cardInfo.suit };
                        this.draggedCards = [card];
                    } else if (cardInfo.location === 'tableau') {
                        const pile = this.game.state.tableau[cardInfo.pileIndex];
                        const cardIndex = cardInfo.cardIndex;
                        
                        this.dragSourceInfo = { type: 'tableau', pileIndex: cardInfo.pileIndex, cardIndex: cardIndex };
                        
                        if (pile[cardIndex].faceUp) {
                            this.draggedCards = pile.slice(cardIndex);
                        } else {
                            return;
                        }
                    }
                    
                    if (this.draggedCards.length > 0) {
                        this.isDragging = true;
                        this.updateCursor();
                        this.game.renderer.render();
                    }
                } catch (error) {
                    console.error('Error starting drag:', error);
                }
            }
            
            isValidDrop(dropZone) {
                try {
                    if (dropZone.type === 'foundation') {
                        return this.isValidFoundationDrop(dropZone.suit);
                    } else if (dropZone.type === 'tableau') {
                        return this.isValidTableauDrop(dropZone.pileIndex);
                    }
                    return false;
                } catch (error) {
                    console.error('Error validating drop:', error);
                    return false;
                }
            }
            
            isValidFoundationDrop(suit) {
                if (this.draggedCards.length !== 1) return false;
                const card = this.draggedCards[0];
                return card.suit === suit && this.game.rules.canPlaceOnFoundation(card);
            }
            
            isValidTableauDrop(pileIndex) {
                if (this.draggedCards.length === 0) return false;
                
                if (this.dragSourceInfo && this.dragSourceInfo.type === 'tableau' && 
                    this.dragSourceInfo.pileIndex === pileIndex) {
                    return false;
                }
                
                if (!this.game.rules.isValidSequence(this.draggedCards)) {
                    return false;
                }
                
                const topCard = this.draggedCards[0];
                return this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[pileIndex]);
            }
            
            executeDrop(dropZone) {
                try {
                    this.game.state.saveGameState();
                    this.game.state.gameStats.moves++;
                    this.game.sound.play('cardPlace');
                    
                    let moveType = '';
                    if (dropZone.type === 'foundation') {
                        moveType = 'foundation';
                    } else if (this.dragSourceInfo.type === 'waste') {
                        moveType = 'waste_to_tableau';
                    } else if (this.dragSourceInfo.type === 'foundation') {
                        moveType = 'foundation_to_tableau';
                    } else {
                        moveType = 'tableau_to_tableau';
                    }
                    
                    let willRevealCard = false;
                    if (this.dragSourceInfo.type === 'tableau') {
                        const sourcePile = this.game.state.tableau[this.dragSourceInfo.pileIndex];
                        const remainingCards = sourcePile.length - this.draggedCards.length;
                        if (remainingCards > 0 && !sourcePile[remainingCards - 1].faceUp) {
                            willRevealCard = true;
                        }
                    }
                    
                    if (this.dragSourceInfo.type === 'waste') {
                        this.game.state.waste.pop();
                    } else if (this.dragSourceInfo.type === 'foundation') {
                        this.game.state.foundations[this.dragSourceInfo.suit].pop();
                    } else if (this.dragSourceInfo.type === 'tableau') {
                        const sourcePile = this.game.state.tableau[this.dragSourceInfo.pileIndex];
                        sourcePile.splice(this.dragSourceInfo.cardIndex);
                        
                        if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                            sourcePile[sourcePile.length - 1].faceUp = true;
                        }
                    }
                    
                    if (dropZone.type === 'foundation') {
                        this.game.state.foundations[dropZone.suit].push(...this.draggedCards);
                    } else if (dropZone.type === 'tableau') {
                        this.game.state.tableau[dropZone.pileIndex].push(...this.draggedCards);
                    }
                    
                    this.game.state.updateScore(moveType);
                    if (willRevealCard) {
                        this.game.state.updateScore('reveal');
                    }
                    
                    this.game.state.hintCardId = null;
                    this.game.ui.updateUI();
                    
                    setTimeout(() => {
                        if (this.game.rules.checkAutoMoveToFoundation()) {
                            this.game.renderer.render();
                        }
                    }, 100);
                } catch (error) {
                    console.error('Error executing drop:', error);
                }
            }
        }

        // Render engine
        class RenderEngine {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.canvas = null;
                this.ctx = null;
                this.cardPositions = new Map();
                this.validDropZones = [];
            }
            
            init() {
                console.log('🎨 RenderEngine.init() called');
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) {
                    console.log('🎨 RenderEngine: Canvas element not found!');
                    return false;
                }
                console.log('🎨 RenderEngine: Canvas found:', this.canvas);
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.log('🎨 RenderEngine: Could not get 2D context!');
                    return false;
                }
                console.log('🎨 RenderEngine: 2D context obtained');
                
                const rect = this.canvas.getBoundingClientRect();
                // Fix: If getBoundingClientRect returns 0, use default size
                const canvasWidth = rect.width > 0 ? rect.width : 1000;
                const canvasHeight = rect.height > 0 ? rect.height : 600;
                
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                console.log('🎨 RenderEngine: Canvas size set to', canvasWidth, 'x', canvasHeight);
                
                // Initialize particle system
                if (!this.game.particles) {
                    this.game.particles = new ParticleSystem(this.canvas);
                }
                
                console.log('🎨 RenderEngine: Init successful');
                return true;
            }
            
            render() {
                try {
                    console.log('🎨 RenderEngine.render() called');
                    if (!this.ctx) {
                        console.log('🎨 RenderEngine: No context, initializing...');
                        if (!this.init()) {
                            console.log('🎨 RenderEngine: Init failed');
                            return;
                        }
                    }
                    
                    console.log('🎨 RenderEngine: Clearing canvas and drawing...');
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.cardPositions.clear();
                    this.validDropZones = [];
                    
                    this.drawStock();
                    this.drawWaste();
                    this.drawFoundations();
                    this.drawTableau();
                    this.drawDraggedCards();
                    
                    // Update and render particle effects
                    if (this.game.particles) {
                        this.game.particles.update();
                        this.game.particles.render();
                    }
                    console.log('🎨 RenderEngine: Render complete');
                } catch (error) {
                    console.error('Error rendering game:', error);
                }
            }
            
            drawStock() {
                const stockX = 50;
                const stockY = 50;
                
                if (this.game.state.stock.length > 0) {
                    const depth = Math.min(3, this.game.state.stock.length);
                    for (let i = 0; i < depth; i++) {
                        this.drawCard({ id: 'stock', faceUp: false }, stockX - i*2, stockY - i*2, false, 0.7 + i*0.1);
                    }
                    
                    const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === 'stock';
                    this.drawCard({ id: 'stock', faceUp: false }, stockX, stockY, false, 1, isHovered);
                } else {
                    this.ctx.strokeStyle = '#9ca3af';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(stockX, stockY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                    this.ctx.setLineDash([]);
                    
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('↻', stockX + this.game.constants.CARD_WIDTH/2, stockY + this.game.constants.CARD_HEIGHT/2);
                }
                
                this.cardPositions.set('stock', { 
                    x: stockX, 
                    y: stockY, 
                    card: { id: 'stock', faceUp: false }, 
                    width: this.game.constants.CARD_WIDTH, 
                    height: this.game.constants.CARD_HEIGHT,
                    location: 'stock'
                });
            }
            
            drawWaste() {
                const wasteX = 50 + this.game.constants.CARD_WIDTH + 20;
                const wasteY = 50;
                const visibleWaste = this.game.state.waste.slice(-this.game.state.drawMode);
                
                visibleWaste.forEach((card, i) => {
                    const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === card.id);
                    const alpha = isDraggedCard ? 0.3 : 1;
                    const x = wasteX + i * this.game.constants.WASTE_CARD_OFFSET;
                    const y = wasteY;
                    const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === card.id;
                    
                    this.drawCard(card, x, y, card.id === this.game.state.hintCardId, alpha, isHovered);
                    
                    if (alpha >= 0.5) {
                        this.cardPositions.set(card.id, { 
                            x, 
                            y, 
                            card, 
                            width: this.game.constants.CARD_WIDTH, 
                            height: this.game.constants.CARD_HEIGHT,
                            location: 'waste',
                            stackIndex: i
                        });
                    }
                });
            }
            
            drawFoundations() {
                const foundationStartX = 50 + this.game.constants.CARD_WIDTH + 20 + this.game.constants.CARD_WIDTH + 80;
                
                this.game.constants.SUITS.forEach((suit, i) => {
                    const foundationX = foundationStartX + i * (this.game.constants.CARD_WIDTH + 10);
                    const foundationY = 50;
                    const pile = this.game.state.foundations[suit];
                    
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === topCard.id);
                        const alpha = isDraggedCard ? 0.3 : 1;
                        const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === topCard.id;
                        
                        this.drawCard(topCard, foundationX, foundationY, topCard.id === this.game.state.hintCardId, alpha, isHovered);
                        
                        if (alpha >= 0.5) {
                            this.cardPositions.set(topCard.id, { 
                                x: foundationX, 
                                y: foundationY, 
                                card: topCard, 
                                width: this.game.constants.CARD_WIDTH, 
                                height: this.game.constants.CARD_HEIGHT,
                                location: 'foundation',
                                suit: suit
                            });
                        }
                    } else {
                        const isValidDrop = this.game.input.isDragging && this.isValidFoundationDrop(suit);
                        this.ctx.strokeStyle = isValidDrop ? '#22c55e' : '#9ca3af';
                        this.ctx.lineWidth = isValidDrop ? 4 : 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.strokeRect(foundationX, foundationY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        this.ctx.setLineDash([]);
                        
                        if (isValidDrop) {
                            this.ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            this.ctx.fillRect(foundationX, foundationY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.fillStyle = isValidDrop ? '#22c55e' : '#9ca3af';
                        this.ctx.font = 'bold 32px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(suit, foundationX + this.game.constants.CARD_WIDTH/2, foundationY + this.game.constants.CARD_HEIGHT/2);
                    }
                    
                    this.validDropZones.push({
                        type: 'foundation',
                        suit: suit,
                        x: foundationX,
                        y: foundationY,
                        width: this.game.constants.CARD_WIDTH,
                        height: this.game.constants.CARD_HEIGHT
                    });
                });
            }
            
            drawTableau() {
                const tableauStartX = 50;
                const tableauY = 50 + this.game.constants.CARD_HEIGHT + 40;
                
                this.game.state.tableau.forEach((pile, pileIndex) => {
                    const pileX = tableauStartX + pileIndex * (this.game.constants.CARD_WIDTH + 15);
                    let maxY = tableauY;
                    
                    pile.forEach((card, cardIndex) => {
                        const cardY = tableauY + cardIndex * (card.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET);
                        const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === card.id);
                        const alpha = isDraggedCard ? 0.3 : 1;
                        const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === card.id;
                        
                        this.drawCard(card, pileX, cardY, card.id === this.game.state.hintCardId, alpha, isHovered);
                        maxY = cardY + this.game.constants.CARD_HEIGHT;
                        
                        if (alpha >= 0.5) {
                            this.cardPositions.set(card.id, { 
                                x: pileX, 
                                y: cardY, 
                                card, 
                                width: this.game.constants.CARD_WIDTH, 
                                height: this.game.constants.CARD_HEIGHT,
                                location: 'tableau',
                                pileIndex,
                                cardIndex
                            });
                        }
                    });
                    
                    if (pile.length === 0) {
                        const isValidDrop = this.game.input.isDragging && this.isValidTableauDrop(pileIndex);
                        this.ctx.strokeStyle = isValidDrop ? '#22c55e' : '#6b7280';
                        this.ctx.lineWidth = isValidDrop ? 4 : 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.strokeRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        this.ctx.setLineDash([]);
                        
                        if (isValidDrop) {
                            this.ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            this.ctx.fillRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.fillStyle = isValidDrop ? '#22c55e' : '#6b7280';
                        this.ctx.font = 'bold 24px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('K', pileX + this.game.constants.CARD_WIDTH/2, tableauY + this.game.constants.CARD_HEIGHT/2);
                        
                        maxY = tableauY + this.game.constants.CARD_HEIGHT;
                    }
                    
                    this.validDropZones.push({
                        type: 'tableau',
                        pileIndex: pileIndex,
                        x: pileX,
                        y: tableauY,
                        width: this.game.constants.CARD_WIDTH,
                        height: Math.max(this.game.constants.CARD_HEIGHT, maxY - tableauY)
                    });
                });
            }
            
            drawDraggedCards() {
                if (this.game.input.isDragging && this.game.input.draggedCards.length > 0) {
                    this.game.input.draggedCards.forEach((card, index) => {
                        const x = this.game.input.dragCurrentPos.x - this.game.input.dragOffset.x;
                        const y = this.game.input.dragCurrentPos.y - this.game.input.dragOffset.y + index * this.game.constants.FACE_UP_OFFSET;
                        this.drawCard(card, x, y, false, 0.9);
                    });
                }
            }
            
            drawCard(card, x, y, highlighted = false, alpha = 1, isHovered = false) {
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                
                // Enhanced shadow with multiple layers for depth
                const shadowOffset = isHovered ? 6 : 3;
                const shadowBlur = isHovered ? 8 : 4;
                
                // Soft shadow
                this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                this.ctx.shadowBlur = shadowBlur;
                this.ctx.shadowOffsetX = shadowOffset;
                this.ctx.shadowOffsetY = shadowOffset;
                
                // Card border radius for rounded corners
                const cornerRadius = 8;
                
                if (card.faceUp) {
                    // Professional white card face with subtle gradient
                    const faceGradient = this.ctx.createLinearGradient(x, y, x, y + this.game.constants.CARD_HEIGHT);
                    faceGradient.addColorStop(0, '#ffffff');
                    faceGradient.addColorStop(0.05, '#fefefe');
                    faceGradient.addColorStop(0.95, '#f8f9fa');
                    faceGradient.addColorStop(1, '#f1f3f4');
                    this.ctx.fillStyle = faceGradient;
                } else {
                    // Enhanced card back with professional blue gradient
                    const backGradient = this.ctx.createLinearGradient(x, y, x + this.game.constants.CARD_WIDTH, y + this.game.constants.CARD_HEIGHT);
                    backGradient.addColorStop(0, '#1e40af');
                    backGradient.addColorStop(0.3, '#2563eb');
                    backGradient.addColorStop(0.7, '#3b82f6');
                    backGradient.addColorStop(1, '#1e40af');
                    this.ctx.fillStyle = backGradient;
                }
                
                // Draw rounded rectangle for card
                this.ctx.beginPath();
                if (this.ctx.roundRect) {
                    this.ctx.roundRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT, cornerRadius);
                } else {
                    // Fallback for browsers without roundRect support
                    this.ctx.moveTo(x + cornerRadius, y);
                    this.ctx.lineTo(x + this.game.constants.CARD_WIDTH - cornerRadius, y);
                    this.ctx.quadraticCurveTo(x + this.game.constants.CARD_WIDTH, y, x + this.game.constants.CARD_WIDTH, y + cornerRadius);
                    this.ctx.lineTo(x + this.game.constants.CARD_WIDTH, y + this.game.constants.CARD_HEIGHT - cornerRadius);
                    this.ctx.quadraticCurveTo(x + this.game.constants.CARD_WIDTH, y + this.game.constants.CARD_HEIGHT, x + this.game.constants.CARD_WIDTH - cornerRadius, y + this.game.constants.CARD_HEIGHT);
                    this.ctx.lineTo(x + cornerRadius, y + this.game.constants.CARD_HEIGHT);
                    this.ctx.quadraticCurveTo(x, y + this.game.constants.CARD_HEIGHT, x, y + this.game.constants.CARD_HEIGHT - cornerRadius);
                    this.ctx.lineTo(x, y + cornerRadius);
                    this.ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
                    this.ctx.closePath();
                }
                this.ctx.fill();
                
                // Reset shadow for other elements
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetX = 0;
                this.ctx.shadowOffsetY = 0;
                
                // Enhanced border
                this.ctx.strokeStyle = isHovered ? '#22c55e' : '#d1d5db';
                this.ctx.lineWidth = isHovered ? 2.5 : 1.5;
                this.ctx.stroke();
                
                // Highlight effects
                if (highlighted) {
                    this.ctx.strokeStyle = '#ffd700';
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeRect(x - 2, y - 2, this.game.constants.CARD_WIDTH + 4, this.game.constants.CARD_HEIGHT + 4);
                }
                
                if (isHovered && !this.game.input.isDragging) {
                    this.ctx.strokeStyle = '#4ade80';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x - 1, y - 1, this.game.constants.CARD_WIDTH + 2, this.game.constants.CARD_HEIGHT + 2);
                }
                
                if (card.faceUp) {
                    // Professional card face rendering
                    const isRed = this.game.constants.RED_SUITS.has(card.suit);
                    const cardColor = isRed ? '#dc2626' : '#1f2937';
                    this.ctx.fillStyle = cardColor;
                    
                    // Top-left corner values
                    this.ctx.font = 'bold 18px "Times New Roman", serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    
                    this.ctx.fillText(card.rank, x + 8, y + 8);
                    this.ctx.font = 'bold 16px "Times New Roman", serif';
                    this.ctx.fillText(card.suit, x + 8, y + 28);
                    
                    // Bottom-right corner values (rotated)
                    this.ctx.save();
                    this.ctx.translate(x + this.game.constants.CARD_WIDTH - 8, y + this.game.constants.CARD_HEIGHT - 8);
                    this.ctx.rotate(Math.PI);
                    this.ctx.font = 'bold 18px "Times New Roman", serif';
                    this.ctx.fillText(card.rank, 0, 0);
                    this.ctx.font = 'bold 16px "Times New Roman", serif';
                    this.ctx.fillText(card.suit, 0, 20);
                    this.ctx.restore();
                    
                    // Center suit symbol (larger)
                    this.ctx.font = 'bold 36px "Times New Roman", serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // Add subtle shadow to center symbol
                    this.ctx.shadowColor = 'rgba(0,0,0,0.1)';
                    this.ctx.shadowBlur = 2;
                    this.ctx.shadowOffsetX = 1;
                    this.ctx.shadowOffsetY = 1;
                    
                    this.ctx.fillText(card.suit, x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2);
                    
                    // Reset shadow
                    this.ctx.shadowColor = 'transparent';
                    this.ctx.shadowBlur = 0;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;
                    
                } else {
                    // Enhanced card back pattern
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.4 * alpha;
                    
                    // Decorative border
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(x + 12, y + 12, this.game.constants.CARD_WIDTH - 24, this.game.constants.CARD_HEIGHT - 24);
                    
                    // Elegant diamond pattern
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.globalAlpha = 0.3 * alpha;
                    
                    const centerX = x + this.game.constants.CARD_WIDTH/2;
                    const centerY = y + this.game.constants.CARD_HEIGHT/2;
                    
                    // Central diamond
                            this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY - 20);
                    this.ctx.lineTo(centerX + 15, centerY);
                    this.ctx.lineTo(centerX, centerY + 20);
                    this.ctx.lineTo(centerX - 15, centerY);
                    this.ctx.closePath();
                            this.ctx.fill();
                    
                    // Corner diamonds
                    for (let i = 0; i < 4; i++) {
                        this.ctx.save();
                        this.ctx.translate(centerX, centerY);
                        this.ctx.rotate(i * Math.PI / 2);
                        this.ctx.translate(0, -30);
                            
                            this.ctx.beginPath();
                        this.ctx.moveTo(0, -8);
                        this.ctx.lineTo(6, 0);
                        this.ctx.lineTo(0, 8);
                        this.ctx.lineTo(-6, 0);
                        this.ctx.closePath();
                            this.ctx.fill();
                        
                        this.ctx.restore();
                    }
                    
                    this.ctx.restore();
                }
                
                this.ctx.restore();
            }
            
            getCardAt(x, y) {
                let bestCard = null;
                let bestZ = -1;
                
                for (const [cardId, info] of this.cardPositions.entries()) {
                    if (x >= info.x && x < info.x + info.width && 
                        y >= info.y && y < info.y + info.height) {
                        
                        let zOrder = 0;
                        
                        if (info.location === 'stock') {
                            zOrder = 1000;
                        } else if (info.location === 'waste') {
                            zOrder = 900 + (info.stackIndex || 0);
                        } else if (info.location === 'foundation') {
                            zOrder = 800;
                        } else if (info.location === 'tableau') {
                            if (!info.card.faceUp) continue;
                            
                            zOrder = 100 + info.cardIndex;
                            const pile = this.game.state.tableau[info.pileIndex];
                            const isTopCard = info.cardIndex === pile.length - 1;
                            
                            if (isTopCard) {
                                zOrder += 100;
                            } else {
                                const nextCard = pile[info.cardIndex + 1];
                                if (nextCard) {
                                    const visibleHeight = nextCard.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET;
                                    if (y > info.y + visibleHeight) {
                                        zOrder -= 20;
                                    }
                                }
                            }
                        }
                        
                        if (zOrder > bestZ) {
                            bestZ = zOrder;
                            bestCard = info;
                        }
                    }
                }
                
                return bestCard;
            }
            
            getDropZoneAt(x, y) {
                for (const zone of this.validDropZones) {
                    if (x >= zone.x && x < zone.x + zone.width &&
                        y >= zone.y && y < zone.y + zone.height) {
                        return zone;
                    }
                }
                return null;
            }
            
            isValidFoundationDrop(suit) {
                return this.game.input.isValidFoundationDrop(suit);
            }
            
            isValidTableauDrop(pileIndex) {
                return this.game.input.isValidTableauDrop(pileIndex);
            }
        }

        // ===== PHASE 2 PERFORMANCE OPTIMIZATIONS =====

        // High-Performance Rendering System
        class PerformanceRenderer extends RenderEngine {
            constructor(gameInstance) {
                super(gameInstance);
                
                // Store game reference for canvas access
                this.game = gameInstance;
                
                // Debug flag
                this.debug = true;
                console.log('🎨 PerformanceRenderer: Constructor called');
                
                // Performance tracking
                this.lastFrameTime = 0;
                this.frameCount = 0;
                this.fps = 60;
                this.targetFPS = 60;
                this.frameInterval = 1000 / this.targetFPS;
                
                // Rendering optimizations
                this.isDirty = true;
                this.dirtyRegions = [];
                this.lastRenderState = null;
                this.renderCache = new Map();
                
                // Animation system
                this.animationId = null;
                this.isAnimating = false;
                this.animations = [];
                
                // Canvas optimizations
                this.offscreenCanvas = null;
                this.offscreenCtx = null;
                this.highDPIScale = 1;
                
                // Performance monitoring
                this.performanceMetrics = {
                    renderTime: 0,
                    lastFrameTime: 0,
                    averageFrameTime: 16.67,
                    droppedFrames: 0,
                    memoryUsage: 0
                };
                
                // Initialize after DOM is ready with longer delay to ensure canvas is available
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        this.waitForGameReady();
                    });
                } else {
                    this.waitForGameReady();
                }
            }
            
            waitForGameReady() {
                let attempts = 0;
                const maxAttempts = 25; // 5 seconds max wait time
                
                // Check if game is ready with canvas available
                const checkReady = () => {
                    attempts++;
                    
                    // Try multiple ways to find the canvas
                    let canvas = null;
                    let ctx = null;
                    
                    // Method 1: Check game instance
                    if (this.game && this.game.canvas && this.game.ctx) {
                        canvas = this.game.canvas;
                        ctx = this.game.ctx;
                    }
                    
                    // Method 2: Check DOM directly
                    if (!canvas) {
                        canvas = document.getElementById('gameCanvas');
                        if (canvas) {
                            ctx = canvas.getContext('2d');
                        }
                    }
                    
                    // Method 3: Check if canvas exists in DOM but not attached to game
                    if (!canvas) {
                        const canvasElements = document.getElementsByTagName('canvas');
                        if (canvasElements.length > 0) {
                            canvas = canvasElements[0];
                            ctx = canvas.getContext('2d');
                        }
                    }
                    
                    if (canvas && ctx && document.contains(canvas)) {
                        console.log('🎨 PerformanceRenderer: Canvas found, initializing...');
                        // Store references for later use
                        this.canvas = canvas;
                        this.ctx = ctx;
                        setTimeout(() => this.initPerformanceSystem(), 100);
                    } else if (attempts < maxAttempts && !this.disabled) {
                        // Check again in 200ms, but don't wait forever
                        setTimeout(checkReady, 200);
                    } else {
                        // Give up and disable performance renderer gracefully
                        console.log('🎨 PerformanceRenderer: Canvas not available, falling back to standard rendering');
                        this.disabled = true;
                        this.cleanup();
                        
                        // Ensure the game can still render normally
                        if (this.game && this.game.renderer && typeof this.game.renderer.render === 'function') {
                            console.log('✅ Standard renderer still available');
                        }
                    }
                };
                checkReady();
            }
            
            initPerformanceSystem() {
                // Initialize retry counter if not exists
                if (!this.initRetryCount) {
                    this.initRetryCount = 0;
                }
                
                // Canvas should already be set by waitForGameReady, but double-check
                if (!this.canvas || !this.ctx) {
                    console.warn('PerformanceRenderer: Canvas not available in initPerformanceSystem');
                    this.disabled = true;
                    return;
                }
                
                // Verify canvas is still in DOM
                if (!document.contains(this.canvas)) {
                    console.warn('PerformanceRenderer: Canvas no longer in DOM');
                    this.disabled = true;
                    return;
                }
                
                try {
                    console.log('🎨 PerformanceRenderer: Initializing performance systems...');
                    
                    // Setup high-DPI canvas - TEMPORARILY DISABLED for debugging
                    // this.setupHighDPICanvas();
                    
                    // Ensure canvas has proper size
                    if (this.canvas && (!this.canvas.width || !this.canvas.height)) {
                        this.canvas.width = 1000;
                        this.canvas.height = 600;
                        console.log('🎨 PerformanceRenderer: Set canvas size to 1000x600');
                    }
                    
                    // Create offscreen canvas for complex drawings
                    this.createOffscreenCanvas();
                    
                    // Start render loop
                    this.startRenderLoop();
                    
                    // Monitor performance
                    this.startPerformanceMonitoring();
                    
                    console.log('✅ PerformanceRenderer: Successfully initialized');
                    
                } catch (error) {
                    console.error('PerformanceRenderer: Failed to initialize:', error);
                    this.disabled = true;
                    this.cleanup();
                }
            }
            
            setupHighDPICanvas() {
                if (!this.canvas || !this.ctx) return;
                
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                
                // Fix: If getBoundingClientRect returns 0, use default size
                const canvasWidth = rect.width > 0 ? rect.width : 1000;
                const canvasHeight = rect.height > 0 ? rect.height : 600;
                
                console.log('🎨 PerformanceRenderer: Setting up high DPI canvas:', canvasWidth, 'x', canvasHeight, 'DPR:', dpr);
                
                // Set actual size in memory (scaled up for high DPI)
                this.canvas.width = canvasWidth * dpr;
                this.canvas.height = canvasHeight * dpr;
                
                // Scale back down using CSS
                this.canvas.style.width = canvasWidth + 'px';
                this.canvas.style.height = canvasHeight + 'px';
                
                // Scale the drawing context so everything draws at the correct size
                this.ctx.scale(dpr, dpr);
                this.highDPIScale = dpr;
                
                // Optimize canvas rendering
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                console.log('🎨 PerformanceRenderer: High DPI canvas setup complete');
            }
            
            createOffscreenCanvas() {
                try {
                    if ('OffscreenCanvas' in window) {
                        this.offscreenCanvas = new OffscreenCanvas(
                            this.game.constants.CARD_WIDTH * this.highDPIScale,
                            this.game.constants.CARD_HEIGHT * this.highDPIScale
                        );
                        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                    }
                } catch (error) {
                    console.warn('OffscreenCanvas not supported, using regular canvas');
                }
            }
            
            startRenderLoop() {
                // Don't start if disabled
                if (this.disabled) {
                    return;
                }
                
                const renderFrame = (timestamp) => {
                    // Stop loop if disabled
                    if (this.disabled) {
                        if (this.animationId) {
                            cancelAnimationFrame(this.animationId);
                            this.animationId = null;
                        }
                        return;
                    }
                    
                    this.performanceMetrics.lastFrameTime = timestamp - this.lastFrameTime;
                    
                    // Frame rate limiting for performance
                    if (timestamp - this.lastFrameTime >= this.frameInterval) {
                        this.renderOptimized(timestamp);
                        this.lastFrameTime = timestamp;
                        this.frameCount++;
                    }
                    
                    this.animationId = requestAnimationFrame(renderFrame);
                };
                
                this.animationId = requestAnimationFrame(renderFrame);
            }
            
            renderOptimized(timestamp) {
                // Skip rendering if disabled
                if (this.disabled) {
                    return;
                }
                
                const renderStart = performance.now();
                
                try {
                    // Ensure canvas and context are still available
                    if (!this.ctx || !this.canvas) {
                        console.warn('Canvas context lost during render, skipping frame');
                        return;
                    }
                    
                    // Only render if something changed or animations are active
                    if (this.isDirty || this.isAnimating || this.animations.length > 0) {
                        
                        // Update animations first
                        this.updateAnimations(timestamp);
                        
                        // Efficient partial rendering
                        if (this.dirtyRegions.length > 0) {
                            this.renderDirtyRegions();
                        } else {
                            this.renderComplete();
                        }
                        
                        this.isDirty = false;
                        this.dirtyRegions = [];
                    }
                    
                } catch (error) {
                    console.error('Render error:', error);
                    // If we get repeated render errors, stop the render loop temporarily
                    this.performanceMetrics.droppedFrames++;
                    if (this.performanceMetrics.droppedFrames > 10) {
                        console.warn('Too many render errors, pausing render loop');
                        setTimeout(() => {
                            this.performanceMetrics.droppedFrames = 0;
                        }, 1000);
                        return;
                    }
                }
                
                // Track performance
                this.performanceMetrics.renderTime = performance.now() - renderStart;
                this.updatePerformanceMetrics();
            }
            
            cleanup() {
                // Stop animation loop
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // Clear references
                this.canvas = null;
                this.ctx = null;
                this.offscreenCanvas = null;
                this.offscreenCtx = null;
                
                // Clear caches
                if (this.renderCache) {
                    this.renderCache.clear();
                }
                
                console.log('🧹 PerformanceRenderer: Cleaned up resources');
            }
            
            renderDirtyRegions() {
                // Ensure context is available
                if (!this.ctx || !this.canvas || this.disabled) {
                    return;
                }
                
                try {
                    // Render only specific regions that changed
                    this.dirtyRegions.forEach(region => {
                        try {
                            this.ctx.save();
                            this.ctx.beginPath();
                            this.ctx.rect(region.x, region.y, region.width, region.height);
                            this.ctx.clip();
                            
                            // Clear and redraw region
                            this.ctx.clearRect(region.x, region.y, region.width, region.height);
                            this.renderRegion(region);
                            
                            this.ctx.restore();
                        } catch (error) {
                            console.warn('Error rendering dirty region:', error);
                            try {
                                this.ctx.restore(); // Ensure context is restored even on error
                            } catch (restoreError) {
                                // Context might be completely lost
                                this.disabled = true;
                            }
                        }
                    });
                } catch (error) {
                    console.warn('Critical error in dirty region rendering:', error);
                    this.disabled = true;
                }
            }
            
            renderRegion(region) {
                // Fallback region rendering - just call the parent render method
                // This is a simplified implementation for the dirty region system
                try {
                    if (this.game && this.game.renderer && typeof this.game.renderer.render === 'function') {
                        this.game.renderer.render();
                    } else {
                        // Basic fallback rendering
                        super.render();
                    }
                } catch (error) {
                    console.warn('Error in region rendering fallback:', error);
                }
            }
            
            renderComplete() {
                // Ensure context is available
                if (!this.ctx || !this.canvas) {
                    console.warn('Canvas context not available for rendering');
                    return;
                }
                
                // Full screen render with optimizations
                this.ctx.clearRect(0, 0, this.canvas.width / this.highDPIScale, this.canvas.height / this.highDPIScale);
                
                // Batch similar operations for GPU efficiency
                try {
                    this.drawStockBatch();
                    this.drawWasteBatch();
                    this.drawFoundationsBatch();
                    this.drawTableauBatch();
                    this.drawDraggedCards();
                } catch (drawError) {
                    console.warn('Error in batch drawing, falling back to parent render:', drawError);
                    // Fallback to parent render method
                    try {
                        super.render();
                    } catch (fallbackError) {
                        console.error('Error in fallback render, disabling PerformanceRenderer:', fallbackError);
                        this.disabled = true;
                        this.cleanup();
                    }
                }
                
                // Render particle effects
                if (this.game.particles) {
                    this.game.particles.update();
                    this.game.particles.render();
                }
            }
            
            // Batched drawing methods for better performance
            drawStockBatch() {
                // Use the parent's drawStock method directly
                try {
                    super.drawStock();
                } catch (error) {
                    console.warn('Error calling parent drawStock, using fallback:', error);
                    // Basic stock drawing implementation as fallback
                    try {
                        this.ctx.save();
                        
                        const stockX = 50;
                        const stockY = 50;
                        
                        if (this.game.state.stock.length > 0) {
                            // Draw card back for stock
                            this.ctx.fillStyle = '#0066cc';
                            this.ctx.fillRect(stockX, stockY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                            this.ctx.strokeStyle = '#003d7a';
                            this.ctx.strokeRect(stockX, stockY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.restore();
                    } catch (fallbackError) {
                        console.error('Error in stock fallback rendering:', fallbackError);
                    }
                }
            }
            
            drawWasteBatch() {
                // Use the parent's drawWaste method directly
                try {
                    super.drawWaste();
                } catch (error) {
                    console.warn('Error calling parent drawWaste, using fallback:', error);
                    // Basic waste drawing implementation as fallback
                    try {
                        this.ctx.save();
                        
                        const wasteX = 150;
                        const wasteY = 50;
                        
                        if (this.game.state.waste.length > 0) {
                            const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                            this.drawCardSimple(topCard, wasteX, wasteY);
                        }
                        
                        this.ctx.restore();
                    } catch (fallbackError) {
                        console.error('Error in waste fallback rendering:', fallbackError);
                    }
                }
            }
            
            drawFoundationsBatch() {
                // Use the parent's drawFoundations method directly
                try {
                    super.drawFoundations();
                } catch (error) {
                    console.warn('Error calling parent drawFoundations, using fallback:', error);
                    // Basic foundations drawing implementation as fallback
                    try {
                        this.ctx.save();
                        
                        const suits = ['♠', '♥', '♦', '♣'];
                        suits.forEach((suit, index) => {
                            const x = 350 + index * 120;
                            const y = 50;
                            const pile = this.game.state.foundations[suit];
                            
                            if (pile && pile.length > 0) {
                                const topCard = pile[pile.length - 1];
                                this.drawCardSimple(topCard, x, y);
                            } else {
                                // Draw empty foundation slot
                                this.ctx.strokeStyle = '#ccc';
                                this.ctx.strokeRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                            }
                        });
                        
                        this.ctx.restore();
                    } catch (fallbackError) {
                        console.error('Error in foundations fallback rendering:', fallbackError);
                    }
                }
            }
            
            drawTableauBatch() {
                // Use the parent's drawTableau method directly
                try {
                    super.drawTableau();
                } catch (error) {
                    console.warn('Error calling parent drawTableau, using fallback:', error);
                    // Basic tableau drawing implementation as fallback
                    try {
                        this.ctx.save();
                        
                        const tableauStartX = 50;
                        const tableauY = 50 + this.game.constants.CARD_HEIGHT + 40;
                        
                        this.game.state.tableau.forEach((pile, pileIndex) => {
                            const pileX = tableauStartX + pileIndex * (this.game.constants.CARD_WIDTH + 15);
                            
                            pile.forEach((card, cardIndex) => {
                                const cardY = tableauY + cardIndex * (card.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET);
                                
                                if (card.faceUp) {
                                    this.drawCardSimple(card, pileX, cardY);
                                } else {
                                    // Draw card back
                                    this.ctx.fillStyle = '#0066cc';
                                    this.ctx.fillRect(pileX, cardY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                                    this.ctx.strokeStyle = '#003d7a';
                                    this.ctx.strokeRect(pileX, cardY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                                }
                            });
                            
                            // Draw empty pile placeholder if needed
                            if (pile.length === 0) {
                                this.ctx.strokeStyle = '#ccc';
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.strokeRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                                this.ctx.setLineDash([]);
                            }
                        });
                        
                        this.ctx.restore();
                    } catch (fallbackError) {
                        console.error('Error in tableau fallback rendering:', fallbackError);
                    }
                }
            }
            
            drawDraggedCards() {
                // Use the parent's drawDraggedCards method directly
                try {
                    super.drawDraggedCards();
                } catch (error) {
                    console.warn('Error calling parent drawDraggedCards:', error);
                    // Basic dragged cards implementation could go here if needed
                }
            }
            
            drawCardSimple(card, x, y) {
                // Simple card drawing for fallback
                try {
                    if (!card || !this.ctx) return;
                    
                    // Draw card background
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                    this.ctx.strokeStyle = 'black';
                    this.ctx.strokeRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                    
                    // Draw card value and suit
                    this.ctx.fillStyle = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    
                    // Use rank if available, otherwise use value
                    const displayValue = card.rank || card.value || '?';
                    const displaySuit = card.suit || '?';
                    
                    this.ctx.fillText(`${displayValue}${displaySuit}`, x + 5, y + 5);
                    
                    // Draw suit in bottom right (flipped)
                    this.ctx.save();
                    this.ctx.translate(x + this.game.constants.CARD_WIDTH, y + this.game.constants.CARD_HEIGHT);
                    this.ctx.rotate(Math.PI);
                    this.ctx.fillText(`${displayValue}${displaySuit}`, 5, 5);
                    this.ctx.restore();
                    
                } catch (error) {
                    console.warn('Error drawing simple card:', error);
                }
            }
            
            updateAnimations(timestamp) {
                // Basic animation update
                this.animations = this.animations.filter(animation => {
                    try {
                        if (animation.update) {
                            return animation.update(timestamp);
                        }
                        return false;
                    } catch (error) {
                        console.warn('Error updating animation:', error);
                        return false;
                    }
                });
                
                this.isAnimating = this.animations.length > 0;
            }
            
            drawCardOptimized(card, x, y, highlighted = false, alpha = 1, isHovered = false) {
                // Use cached rendering for identical cards
                const cacheKey = `${card.suit}-${card.value}-${card.faceUp}-${highlighted}-${isHovered}`;
                
                if (this.renderCache.has(cacheKey) && !this.isDirty) {
                    const cached = this.renderCache.get(cacheKey);
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.drawImage(cached, x, y);
                    this.ctx.restore();
                    return;
                }
                
                // Call parent drawing method
                this.drawCard(card, x, y, highlighted, alpha, isHovered);
            }
            
            // Animation system
            addAnimation(animation) {
                animation.startTime = performance.now();
                animation.id = Math.random().toString(36).substr(2, 9);
                this.animations.push(animation);
                this.isAnimating = true;
            }
            
            updateAnimations(timestamp) {
                this.animations = this.animations.filter(animation => {
                    const elapsed = timestamp - animation.startTime;
                    const progress = Math.min(elapsed / animation.duration, 1);
                    
                    // Update animation
                    if (animation.update) {
                        animation.update(progress, elapsed);
                    }
                    
                    // Animation complete
                    if (progress >= 1) {
                        if (animation.onComplete) {
                            animation.onComplete();
                        }
                        return false; // Remove from array
                    }
                    
                    return true; // Keep in array
                });
                
                this.isAnimating = this.animations.length > 0;
            }
            
            // Performance monitoring
            startPerformanceMonitoring() {
                setInterval(() => {
                    this.fps = Math.round(1000 / this.performanceMetrics.averageFrameTime);
                    
                    // Adjust quality based on performance
                    if (this.fps < 45) {
                        this.adjustQualityDown();
                    } else if (this.fps > 55 && this.performanceMetrics.renderTime < 8) {
                        this.adjustQualityUp();
                    }
                    
                    // Memory usage check
                    if (performance.memory) {
                        this.performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                        
                        // Clear cache if memory usage is high
                        if (this.performanceMetrics.memoryUsage > 100) {
                            this.clearRenderCache();
                        }
                    }
                    
                }, 1000);
            }
            
            updatePerformanceMetrics() {
                // Moving average for smooth FPS calculation
                this.performanceMetrics.averageFrameTime = 
                    (this.performanceMetrics.averageFrameTime * 0.9) + 
                    (this.performanceMetrics.lastFrameTime * 0.1);
                
                // Track dropped frames
                if (this.performanceMetrics.lastFrameTime > 20) {
                    this.performanceMetrics.droppedFrames++;
                }
            }
            
            adjustQualityDown() {
                // Reduce visual quality for better performance
                if (this.ctx) {
                    this.ctx.imageSmoothingEnabled = false;
                }
                this.targetFPS = 30;
                this.frameInterval = 1000 / this.targetFPS;
            }
            
            adjustQualityUp() {
                // Increase visual quality when performance allows
                if (this.ctx) {
                    this.ctx.imageSmoothingEnabled = true;
                    this.ctx.imageSmoothingQuality = 'high';
                }
                this.targetFPS = 60;
                this.frameInterval = 1000 / this.targetFPS;
            }
            
            // Dirty region management
            markDirty(x, y, width, height) {
                this.isDirty = true;
                this.dirtyRegions.push({ x, y, width, height });
            }
            
            clearRenderCache() {
                this.renderCache.clear();
                if (typeof gc === 'function') {
                    gc(); // Force garbage collection if available
                }
            }
            
            // Override parent render method
            render() {
                if (this.debug) {
                    console.log('🎨 PerformanceRenderer.render() called');
                    console.log('Canvas:', this.canvas);
                    console.log('Context:', this.ctx);
                    console.log('Game state stock length:', this.game?.state?.stock?.length);
                    console.log('Game state tableau length:', this.game?.state?.tableau?.length);
                }
                
                // Check if we should fall back to parent render
                if (this.disabled || !this.canvas || !this.ctx) {
                    if (this.debug) {
                        console.log('🎨 PerformanceRenderer: Falling back to parent render');
                        console.log('Disabled:', this.disabled);
                        console.log('Canvas exists:', !!this.canvas);
                        console.log('Context exists:', !!this.ctx);
                    }
                    try {
                        super.render();
                    } catch (error) {
                        console.error('Error in parent render:', error);
                    }
                    return;
                }
                
                try {
                    this.renderComplete();
                } catch (error) {
                    console.error('Error in PerformanceRenderer.render():', error);
                    // Fall back to parent render
                    try {
                        super.render();
                    } catch (fallbackError) {
                        console.error('Error in fallback render:', fallbackError);
                    }
                }
            }
            
            cleanup() {
                // Stop render loop
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                // Clear performance monitoring
                if (this.performanceMonitorId) {
                    clearInterval(this.performanceMonitorId);
                    this.performanceMonitorId = null;
                }
                
                console.log('🧹 PerformanceRenderer: Cleaned up resources');
            }
            
            // Cleanup
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.clearRenderCache();
                this.animations = [];
            }
        }
        
        // Enhanced AI Worker Integration for Non-blocking Operations
        class AIWorkerManager {
            constructor(game) {
                this.game = game;
                this.worker = null;
                this.isInitialized = false;
                this.pendingRequests = new Map();
                this.requestId = 0;
                
                this.initWorker();
            }
            
            initWorker() {
                try {
                    this.worker = new Worker('ai-worker.js');
                    
                    this.worker.onmessage = (event) => {
                        this.handleWorkerMessage(event.data);
                    };
                    
                    this.worker.onerror = (error) => {
                        console.error('AI Worker error:', error);
                        this.fallbackToMainThread();
                    };
                    
                    this.isInitialized = true;
                    console.log('🚀 AI Worker Manager initialized');
                    
                } catch (error) {
                    console.warn('AI Worker not available, using main thread');
                    this.fallbackToMainThread();
                }
            }
            
            // Serialize gameState for worker communication (remove non-serializable objects)
            serializeGameStateForWorker(gameState) {
                try {
                    if (!gameState) return null;
                    
                    // Create a clean copy without non-serializable objects
                    const cleanState = {
                        stock: gameState.stock || [],
                        waste: gameState.waste || [],
                        tableau: gameState.tableau || Array.from({ length: 7 }, () => []),
                        foundations: gameState.foundations || { '♠': [], '♥': [], '♦': [], '♣': [] },
                        gameStats: {
                            moves: gameState.gameStats?.moves || 0,
                            time: gameState.gameStats?.time || 0,
                            score: gameState.gameStats?.score || 0
                        }
                    };
                    
                    // Ensure all cards are properly serializable
                    cleanState.stock = this.cleanCardArray(cleanState.stock);
                    cleanState.waste = this.cleanCardArray(cleanState.waste);
                    cleanState.tableau = cleanState.tableau.map(pile => this.cleanCardArray(pile));
                    
                    Object.keys(cleanState.foundations).forEach(suit => {
                        cleanState.foundations[suit] = this.cleanCardArray(cleanState.foundations[suit]);
                    });
                    
                    return cleanState;
                } catch (error) {
                    console.warn('Error serializing game state for worker:', error);
                    return null;
                }
            }
            
            cleanCardArray(cards) {
                if (!Array.isArray(cards)) return [];
                
                return cards.map(card => {
                    if (!card) return null;
                    
                    return {
                        id: card.id || `${card.rank || card.value}${card.suit}`,
                        suit: card.suit,
                        rank: card.rank,
                        value: card.value,
                        faceUp: Boolean(card.faceUp)
                    };
                }).filter(card => card !== null);
            }

            async analyzePositionAsync(gameState) {
                return new Promise((resolve, reject) => {
                    if (!this.isInitialized || !this.worker) {
                        // Fallback to main thread
                        resolve(this.analyzePositionMainThread(gameState));
                        return;
                    }
                    
                    // Validate and serialize gameState
                    const cleanGameState = this.serializeGameStateForWorker(gameState);
                    if (!cleanGameState) {
                        resolve(this.analyzePositionMainThread(gameState));
                        return;
                    }
                    
                    const requestId = ++this.requestId;
                    this.pendingRequests.set(requestId, { resolve, reject, timeout: null });
                    
                    // Set timeout for request
                    const timeout = setTimeout(() => {
                        this.pendingRequests.delete(requestId);
                        reject(new Error('AI analysis timeout'));
                    }, 5000);
                    
                    this.pendingRequests.get(requestId).timeout = timeout;
                    
                    // Send to worker
                    this.worker.postMessage({
                        type: 'analyzePosition',
                        data: { gameState: cleanGameState },
                        requestId: requestId
                    });
                });
            }
            
            async findWinningPathAsync(gameState, maxDepth = 150) {
                return new Promise((resolve, reject) => {
                    if (!this.isInitialized || !this.worker) {
                        resolve({ canWin: false, error: 'Worker not available' });
                        return;
                    }
                    
                    // Validate and serialize gameState
                    const cleanGameState = this.serializeGameStateForWorker(gameState);
                    if (!cleanGameState) {
                        resolve({ canWin: false, error: 'Invalid game state' });
                        return;
                    }
                    
                    const requestId = ++this.requestId;
                    this.pendingRequests.set(requestId, { resolve, reject, timeout: null });
                    
                    // Set longer timeout for path finding
                    const timeout = setTimeout(() => {
                        this.pendingRequests.delete(requestId);
                        reject(new Error('Path finding timeout'));
                    }, 30000);
                    
                    this.pendingRequests.get(requestId).timeout = timeout;
                    
                    this.worker.postMessage({
                        type: 'findWinningPath',
                        data: { gameState: cleanGameState, maxDepth: maxDepth },
                        requestId: requestId
                    });
                });
            }
            
            handleWorkerMessage(data) {
                try {
                    // Handle different message formats
                    let requestId, result, error;
                    
                    if (data.requestId !== undefined) {
                        // Standard format
                        requestId = data.requestId;
                        result = data.result || data.data;
                        error = data.error;
                    } else if (data.type === 'response') {
                        // Worker response format
                        requestId = data.requestId;
                        result = data.success ? data.data : null;
                        error = data.success ? null : data.error;
                    } else {
                        console.warn('Unknown worker message format:', data);
                        return;
                    }
                    
                    if (this.pendingRequests.has(requestId)) {
                        const request = this.pendingRequests.get(requestId);
                        
                        // Clear timeout
                        if (request.timeout) {
                            clearTimeout(request.timeout);
                        }
                        
                        // Resolve or reject
                        if (error) {
                            request.reject(new Error(error));
                        } else {
                            request.resolve(result);
                        }
                        
                        this.pendingRequests.delete(requestId);
                    }
                } catch (err) {
                    console.error('Error handling worker message:', err);
                }
            }
            
            analyzePositionMainThread(gameState) {
                // Fallback implementation for main thread
                try {
                    // Basic analysis without worker
                    return {
                        possibleMoves: this.game.ai ? this.game.ai.findAllPossibleMoves() : [],
                        winProbability: 0.5,
                        bestMove: null,
                        timestamp: Date.now()
                    };
                } catch (error) {
                    return { error: error.message, timestamp: Date.now() };
                }
            }
            
            async getWorkerPerformanceReport() {
                if (!this.isInitialized || !this.worker) {
                    return { error: 'Worker not available' };
                }
                
                return new Promise((resolve) => {
                    const requestId = ++this.requestId;
                    this.pendingRequests.set(requestId, { resolve, reject: () => {}, timeout: null });
                    
                    const timeout = setTimeout(() => {
                        this.pendingRequests.delete(requestId);
                        resolve({ error: 'Performance report timeout' });
                    }, 2000);
                    
                    this.pendingRequests.get(requestId).timeout = timeout;
                    
                    this.worker.postMessage({
                        type: 'getPerformanceReport',
                        requestId: requestId
                    });
                });
            }
            
            async clearWorkerCache() {
                if (!this.isInitialized || !this.worker) {
                    return { error: 'Worker not available' };
                }
                
                return new Promise((resolve) => {
                    const requestId = ++this.requestId;
                    this.pendingRequests.set(requestId, { resolve, reject: () => {}, timeout: null });
                    
                    const timeout = setTimeout(() => {
                        this.pendingRequests.delete(requestId);
                        resolve({ error: 'Clear cache timeout' });
                    }, 2000);
                    
                    this.pendingRequests.get(requestId).timeout = timeout;
                    
                    this.worker.postMessage({
                        type: 'clearCache',
                        requestId: requestId
                    });
                });
            }
            
            async optimizeWorkerPerformance() {
                if (!this.isInitialized || !this.worker) {
                    return { error: 'Worker not available' };
                }
                
                return new Promise((resolve) => {
                    const requestId = ++this.requestId;
                    this.pendingRequests.set(requestId, { resolve, reject: () => {}, timeout: null });
                    
                    const timeout = setTimeout(() => {
                        this.pendingRequests.delete(requestId);
                        resolve({ error: 'Optimize performance timeout' });
                    }, 2000);
                    
                    this.pendingRequests.get(requestId).timeout = timeout;
                    
                    this.worker.postMessage({
                        type: 'optimizePerformance',
                        requestId: requestId
                    });
                });
            }

            fallbackToMainThread() {
                this.isInitialized = false;
                this.worker = null;
            }
        }

        // ===== END PHASE 2 OPTIMIZATIONS =====

        // Advanced Intelligent ML Manager with Complete Board Vision and Learning
        class MLManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.isInitialized = false;
                this.isDisposed = false;
                this.fallbackMode = false;
                
                class LearningDB {
                  constructor() {
                   this.dbPromise = new Promise((resolve, reject) => {
                      const req = indexedDB.open('KlondikeLearning', 1);
                      req.onupgradeneeded = (event) => {
                         const db = event.target.result;
                         if (!db.objectStoreNames.contains('games')) {
                           db.createObjectStore('games', { keyPath: 'timestamp' });
                     }
                 };
                 req.onsuccess = () => resolve(req.result);
                  req.onerror = () => reject(req.error);
                 });
             }

                  async saveGameRecord(gameRecord) {
                     const db = await this.dbPromise;
                     const tx = db.transaction('games', 'readwrite');
                      tx.objectStore('games').put(gameRecord);
                      return tx.complete;
                  }

                 async getAllGameRecords() {
                     const db = await this.dbPromise;
                     const tx = db.transaction('games', 'readonly');
                      return tx.objectStore('games').getAll();
                 }
            }


                // Advanced learning and memory systems
                this.gameMemory = {
                    winningGames: [], // Complete games that resulted in wins
                    losingGames: [], // Games that were lost or abandoned
                    moveOutcomes: new Map(), // Move -> success rate mapping
                    positionEvaluations: new Map(), // Game state -> win probability
                    sequencePatterns: new Map(), // Successful move sequences
                    cardMemory: new Map(), // Hidden card location tracking
                    stockDrawingPatterns: new Map() // Optimal stock drawing strategies
                };
                
                // Neural network simulation with weights
                this.neuralWeights = {
                    foundationValue: 10.0,
                    sequenceValue: 8.0,
                    revealValue: 7.0,
                    emptySpaceValue: 6.0,
                    kingPlacementValue: 5.0,
                    stockEfficiency: 4.0,
                    riskMitigation: 3.0
                };
                
                // Complete board vision tracking
                this.completeBoard = {
                    allCards: new Map(), // cardId -> current location and properties
                    hiddenCards: new Map(), // location -> card for face-down cards
                    stockOrder: [], // exact order of cards in stock
                    futureStockCards: [] // cards that will come up in stock
                };
                
                // Web AI integration capabilities
                this.webAIEnabled = false;
                this.lastWebAIQuery = 0;
                this.webAICache = new Map();
                
                this.initializeAdvancedAI();
            }
            
            async initializeAdvancedAI() {
                try {
                    this.isInitialized = true;
                    
                    // Load existing learning data
                    await this.loadLearningData();
                    
                    // Initialize complete board tracking
                    this.initializeCompleteBoard();
                    
                    // Check for web AI capabilities
                    this.checkWebAIAvailability();
                    
                    console.log('🧠 Advanced AI System initialized with complete board vision and learning');
                    console.log(`📚 Loaded: ${this.gameMemory.winningGames.length} winning games, ${this.gameMemory.moveOutcomes.size} move patterns`);
                    
                    // Show initialization status
                    setTimeout(() => {
                        if (this.game.ui) {
                            this.game.ui.showNotification(
                                `🧠 Advanced AI Online! Features: Complete board vision, learning from ${this.gameMemory.winningGames.length} wins, strategic analysis`,
                                'info', 4000
                            );
                        }
                    }, 2000);
                    
                } catch (error) {
                    console.warn('Advanced AI initialization failed, using enhanced mode:', error);
                    this.fallbackMode = true;
                    this.isInitialized = true;
                }
            }
            
            initializeCompleteBoard() {
                // Initialize tracking for all cards in the deck
                this.game.constants.SUITS.forEach(suit => {
                    this.game.constants.RANKS.forEach((rank, index) => {
                        const cardId = `${rank}${suit}`;
                        this.completeBoard.allCards.set(cardId, {
                            id: cardId,
                            suit: suit,
                            rank: rank,
                            value: index + 1,
                            location: 'unknown',
                            visible: false,
                            strategic_value: this.calculateCardStrategicValue(suit, index + 1)
                        });
                    });
                });
            }
            
            // Update complete board vision when game state changes
            updateCompleteBoard(gameState) {
                // Clear current tracking
                this.completeBoard.allCards.forEach(card => {
                    card.location = 'unknown';
                    card.visible = false;
                });
                
                // Track visible cards
                gameState.waste.forEach((card, index) => {
                    const cardInfo = this.completeBoard.allCards.get(card.id);
                    if (cardInfo) {
                        cardInfo.location = 'waste';
                        cardInfo.position = index;
                        cardInfo.visible = true;
                    }
                });
                
                Object.entries(gameState.foundations).forEach(([suit, pile]) => {
                    pile.forEach((card, index) => {
                        const cardInfo = this.completeBoard.allCards.get(card.id);
                        if (cardInfo) {
                            cardInfo.location = `foundation-${suit}`;
                            cardInfo.position = index;
                            cardInfo.visible = true;
                        }
                    });
                });
                
                gameState.tableau.forEach((pile, pileIndex) => {
                    pile.forEach((card, cardIndex) => {
                        const cardInfo = this.completeBoard.allCards.get(card.id);
                        if (cardInfo) {
                            cardInfo.location = `tableau-${pileIndex}`;
                            cardInfo.position = cardIndex;
                            cardInfo.visible = card.faceUp;
                            cardInfo.faceUp = card.faceUp;
                            
                            // AI can "see" face-down cards for strategic planning
                            if (!card.faceUp) {
                                this.completeBoard.hiddenCards.set(`tableau-${pileIndex}-${cardIndex}`, card);
                            }
                        }
                    });
                });
                
                // Track stock cards (AI knows the order)
                this.completeBoard.stockOrder = [...gameState.stock];
                this.completeBoard.futureStockCards = gameState.stock.slice(-6); // Next 6 cards
            }
            
            calculateCardStrategicValue(suit, value) {
                let strategicValue = value;
                
                // Aces are highly valuable
                if (value === 1) strategicValue += 10;
                
                // Kings are valuable for empty spaces
                if (value === 13) strategicValue += 5;
                
                // Face cards have higher value
                if (value >= 11) strategicValue += 3;
                
                // Red and black suit balance
                const isRed = this.game.constants.RED_SUITS.has(suit);
                strategicValue += isRed ? 1 : 2; // Slight preference for black cards
                
                return strategicValue;
            }
            
            // Memory-optimized advanced move evaluation with complete board knowledge
            async evaluateMove(move, gameState) {
                // Acquire evaluation object from memory pool
                const evaluation = this.game.memory.acquireMoveEvaluation();
                
                try {
                    this.updateCompleteBoard(gameState);
                    
                    // Cache game state for repeated analysis
                    const stateKey = this.hashGameState(gameState);
                    let cachedState = this.game.memory.getCachedGameState(stateKey);
                    if (!cachedState) {
                        cachedState = gameState;
                        this.game.memory.cacheGameState(stateKey, gameState);
                    }
                    
                    let score = 0;
                    let confidence = 0.5;
                    evaluation.strategicReasoning.length = 0; // Reset array
                    
                    // Base move value
                    score += move.priority || 0;
                    
                    // Foundation moves are always valuable
                    if (move.type === 'foundation') {
                        score += this.neuralWeights.foundationValue;
                        confidence += 0.3;
                        evaluation.strategicReasoning.push('Foundation building increases win probability');
                        
                        // Bonus for balanced foundation building
                        const foundations = Object.values(cachedState.foundations);
                        const heights = foundations.map(pile => pile.length);
                        const maxHeight = Math.max(...heights);
                        const minHeight = Math.min(...heights);
                        if (maxHeight - minHeight <= 2) {
                            score += 3;
                            evaluation.strategicReasoning.push('Maintains balanced foundation building');
                        }
                    }
                    
                    // Sequence building evaluation with lookahead
                    if (move.type === 'tableau' || move.type === 'waste-to-tableau') {
                        const sequenceValue = this.evaluateSequenceBuilding(move, cachedState);
                        score += sequenceValue * this.neuralWeights.sequenceValue;
                        if (sequenceValue > 0.5) {
                            confidence += 0.2;
                            evaluation.strategicReasoning.push('Creates beneficial card sequences');
                        }
                    }
                    
                    // Card reveal evaluation with hidden knowledge
                    const revealValue = this.evaluateCardReveal(move, cachedState);
                    if (revealValue > 0) {
                        score += revealValue * this.neuralWeights.revealValue;
                        confidence += 0.15;
                        evaluation.strategicReasoning.push(`Will reveal ${revealValue > 5 ? 'high-value' : 'useful'} hidden card`);
                    }
                    
                    // Empty space utilization
                    const emptySpaceValue = this.evaluateEmptySpaceUse(move, cachedState);
                    if (emptySpaceValue > 0) {
                        score += emptySpaceValue * this.neuralWeights.emptySpaceValue;
                        evaluation.strategicReasoning.push('Optimizes empty space usage');
                    }
                    
                    // Risk assessment with complete board vision
                    const riskAssessment = this.assessMoveRisk(move, cachedState);
                    score -= riskAssessment.risk * this.neuralWeights.riskMitigation;
                    if (riskAssessment.risk > 0.3) {
                        confidence -= 0.1;
                        evaluation.strategicReasoning.push(`Risk: ${riskAssessment.reason}`);
                    }
                    
                    // Learning from historical data
                    const historicalValue = this.getHistoricalMoveValue(move, cachedState);
                    score += historicalValue * 2;
                    if (historicalValue > 0.5) {
                        confidence += 0.1;
                        evaluation.strategicReasoning.push('Historically successful move pattern');
                    }
                    
                    // Future planning with stock knowledge
                    const futureValue = this.evaluateFuturePlanning(move, cachedState);
                    score += futureValue;
                    
                    // Store metadata for debugging
                    evaluation.metadata.set('cacheHit', cachedState !== gameState);
                    evaluation.metadata.set('totalCalculations', evaluation.strategicReasoning.length);
                    evaluation.metadata.set('poolUsage', this.game.memory.getMemoryStats().hitRate);
                    
                    // Populate evaluation
                    evaluation.move = move;
                    evaluation.aiScore = Math.max(0, score);
                    evaluation.confidence = Math.min(0.95, confidence);
                    evaluation.riskAssessment = riskAssessment;
                    evaluation.historicalValue = historicalValue;
                    evaluation.futurePlanning = futureValue;
                    
                    // Return optimized result
                    return {
                        ...move,
                        aiScore: evaluation.aiScore,
                        confidence: evaluation.confidence,
                        strategicReasoning: [...evaluation.strategicReasoning], // Copy array
                        futureValue: evaluation.futurePlanning,
                        riskAssessment: { ...evaluation.riskAssessment } // Copy object
                    };
                    
                } finally {
                    // Always release evaluation back to pool
                    this.game.memory.releaseMoveEvaluation(evaluation);
                }
            }
            
            evaluateSequenceBuilding(move, gameState) {
                let value = 0;
                
                if (move.card) {
                    // Check if this move creates or extends valuable sequences
                    const cardValue = move.card.value;
                    const cardSuit = move.card.suit;
                    const isRed = this.game.constants.RED_SUITS.has(cardSuit);
                    
                    // Look for cards that can build on this move
                    for (const [cardId, cardInfo] of this.completeBoard.allCards.entries()) {
                        if (cardInfo.value === cardValue - 1 && 
                            this.game.constants.RED_SUITS.has(cardInfo.suit) !== isRed) {
                            if (cardInfo.visible || this.canRevealSoon(cardInfo)) {
                                value += 2;
                            }
                        }
                    }
                    
                    // Check for long sequence potential
                    let sequenceLength = 1;
                    for (let i = 1; i < 7; i++) {
                        const nextValue = cardValue - i;
                        if (nextValue < 1) break;
                        
                        const hasNextCard = Array.from(this.completeBoard.allCards.values()).some(card => 
                            card.value === nextValue && 
                            this.game.constants.RED_SUITS.has(card.suit) !== isRed &&
                            (card.visible || this.canRevealSoon(card))
                        );
                        
                        if (hasNextCard) {
                            sequenceLength++;
                            value += 1;
                        } else {
                            break;
                        }
                    }
                    
                    // Bonus for long sequences
                    if (sequenceLength >= 4) value += 3;
                    if (sequenceLength >= 6) value += 5;
                }
                
                return value;
            }
            
            evaluateCardReveal(move, gameState) {
                let value = 0;
                
                try {
                    // Check if this move will reveal a hidden card
                    if (move && move.card && (move.type === 'tableau' || move.type === 'foundation')) {
                        const cardLocation = this.game.cards.findCardLocation(move.card);
                        if (cardLocation && cardLocation.type === 'tableau' && 
                            gameState && gameState.tableau && gameState.tableau[cardLocation.pileIndex]) {
                            const pile = gameState.tableau[cardLocation.pileIndex];
                            const cardIndex = cardLocation.cardIndex;
                            
                            if (cardIndex > 0 && pile && pile[cardIndex - 1] && !pile[cardIndex - 1].faceUp) {
                                const hiddenCard = pile[cardIndex - 1];
                                
                                // AI knows what the hidden card is
                                value += hiddenCard.value || 0; // Base value
                                
                                // Bonus for high-value cards
                                if (hiddenCard.value === 1) value += 8; // Aces
                                if (hiddenCard.value === 13) value += 6; // Kings
                                if (hiddenCard.value >= 11) value += 4; // Face cards
                                
                                // Check if revealed card will create immediate opportunities
                                const immediateUse = this.canUseCardImmediately(hiddenCard, gameState);
                                if (immediateUse) value += 5;
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Error evaluating card reveal:', error);
                }
                
                return value;
            }
            
            evaluateEmptySpaceUse(move, gameState) {
                let value = 0;
                
                if (move.type === 'tableau' && move.targetPileIndex !== undefined) {
                    const targetPile = gameState.tableau[move.targetPileIndex];
                    if (targetPile.length === 0 && move.card && move.card.value === 13) {
                        // King to empty space
                        value = 3;
                        
                        // Check if this king placement unlocks valuable cards
                        const sourceLocation = this.game.cards.findCardLocation(move.card);
                        if (sourceLocation && sourceLocation.type === 'tableau') {
                            const sourcePile = gameState.tableau[sourceLocation.pileIndex];
                            const unlockedCards = sourcePile.slice(0, sourceLocation.cardIndex);
                            value += unlockedCards.filter(card => !card.faceUp).length * 2;
                        }
                    }
                }
                
                return value;
            }
            
            assessMoveRisk(move, gameState) {
                let risk = 0;
                let reason = '';
                
                try {
                    // Risk of moving from foundation
                    if (move.type === 'foundation-to-tableau') {
                        risk += 0.4;
                        reason = 'Moving from foundation is risky';
                    }
                    
                    // Risk of placing King on empty space without good reason
                    if (move.card && move.card.value === 13 && move.type === 'tableau' && 
                        typeof move.targetPileIndex === 'number' && 
                        gameState.tableau && gameState.tableau[move.targetPileIndex]) {
                        const targetPile = gameState.tableau[move.targetPileIndex];
                        if (targetPile && targetPile.length === 0) {
                            const emptySpaces = gameState.tableau.filter(pile => pile && pile.length === 0).length;
                            if (emptySpaces === 1) { // Last empty space
                                risk += 0.3;
                                reason = 'Using last empty space without clear benefit';
                            }
                        }
                    }
                    
                    // Risk assessment based on game progress
                    if (gameState.foundations) {
                        const foundationProgress = Object.values(gameState.foundations).reduce((sum, pile) => sum + (pile ? pile.length : 0), 0) / 52;
                        if (foundationProgress < 0.3 && move.type === 'foundation-to-tableau') {
                            risk += 0.5;
                            reason = 'Too early to move from foundation';
                        }
                    }
                } catch (error) {
                    console.warn('Error in risk assessment:', error);
                    risk = 0.5; // Default moderate risk
                    reason = 'Unable to assess risk';
                }
                
                return { risk, reason };
            }
            
            getHistoricalMoveValue(move, gameState) {
                const gameStateHash = this.hashGameState(gameState);
                const movePattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                
                // Check if this move pattern has been successful before
                if (this.gameMemory.moveOutcomes.has(movePattern)) {
                    const outcome = this.gameMemory.moveOutcomes.get(movePattern);
                    return outcome.successRate || 0;
                }
                
                // Check similar game states
                for (const [stateHash, evaluation] of this.gameMemory.positionEvaluations.entries()) {
                    if (this.calculateStateSimilarity(gameStateHash, stateHash) > 0.8) {
                        return evaluation.bestMoveValue || 0;
                    }
                }
                
                return 0;
            }
            
            evaluateFuturePlanning(move, gameState) {
                let value = 0;
                
                try {
                    // Use stock knowledge to plan ahead
                    if (this.completeBoard && this.completeBoard.futureStockCards) {
                        const upcomingCards = this.completeBoard.futureStockCards;
                        
                        upcomingCards.forEach((card, index) => {
                            // Check if this move sets up future opportunities
                            if (this.moveCreatesOpportunityFor && this.moveCreatesOpportunityFor(move, card)) {
                                value += (6 - index) * 0.5; // Earlier cards are more valuable
                            }
                        });
                    }
                } catch (error) {
                    console.warn('Error in future planning evaluation:', error);
                }
                
                return value;
            }
            
            moveCreatesOpportunityFor(move, card) {
                // Simple check if a move creates opportunities for a future card
                try {
                    if (!move || !card) return false;
                    
                    // If move reveals a space, check if the card could use it
                    if (move.willReveal && card.value === 13) {
                        return true; // King can use revealed space
                    }
                    
                    // If move to foundation, it might clear space for the card
                    if (move.type === 'foundation' && card.value <= 11) {
                        return true; // Provides tableau space
                    }
                    
                    return false;
                } catch (error) {
                    return false;
                }
            }
            
            canUseCardImmediately(card, gameState) {
                try {
                    if (!card || !gameState) return false;
                    
                    // Check if card can go to foundation
                    if (gameState.foundations && gameState.foundations[card.suit]) {
                        const foundation = gameState.foundations[card.suit];
                        if (foundation.length === 0 && card.value === 1) return true; // Ace
                        if (foundation.length > 0 && foundation[foundation.length - 1].value === card.value - 1) return true;
                    }
                    
                    // Check if card can go to tableau
                    if (gameState.tableau) {
                        for (const pile of gameState.tableau) {
                            if (pile.length === 0 && card.value === 13) return true; // King on empty
                            if (pile.length > 0) {
                                const topCard = pile[pile.length - 1];
                                if (topCard.faceUp && topCard.value === card.value + 1) {
                                    // Check color alternation
                                    const isRedCard = card.suit === '♥' || card.suit === '♦';
                                    const isTopRed = topCard.suit === '♥' || topCard.suit === '♦';
                                    if (isRedCard !== isTopRed) return true;
                                }
                            }
                        }
                    }
                    
                    return false;
                } catch (error) {
                    return false;
                }
            }
            
            helpsFoundationBuilding(card, gameState) {
                try {
                    if (!card || !gameState || !gameState.foundations) return false;
                    
                    // Check if this card can go directly to foundation
                    const foundation = gameState.foundations[card.suit];
                    if (!foundation) return false;
                    
                    if (foundation.length === 0 && card.value === 1) return true; // Ace
                    if (foundation.length > 0 && foundation[foundation.length - 1].value === card.value - 1) return true;
                    
                    return false;
                } catch (error) {
                    return false;
                }
            }
            
            // Stock drawing recommendation system
            async recommendStockDrawing(gameState) {
                this.updateCompleteBoard(gameState);
                
                if (gameState.stock.length === 0) {
                    return {
                        shouldDraw: false,
                        reason: 'Stock is empty',
                        recommendation: 'Cycle through waste pile or focus on tableau moves'
                    };
                }
                
                const upcomingCards = this.completeBoard && this.completeBoard.futureStockCards ? 
                    this.completeBoard.futureStockCards : [];
                const currentMoves = this.game.ai.findAllPossibleMoves();
                
                // Analyze next few stock cards
                let drawValue = 0;
                let immediateUseCards = 0;
                let valuableCards = 0;
                
                if (upcomingCards.length > 0) {
                    upcomingCards.slice(0, gameState.drawMode || 1).forEach(card => {
                        // Check if card can be used immediately
                        if (this.canUseCardImmediately && this.canUseCardImmediately(card, gameState)) {
                            immediateUseCards++;
                            drawValue += 5;
                        }
                        
                        // Check strategic value
                        if (card.value === 1 || card.value === 13 || card.value >= 11) {
                            valuableCards++;
                            drawValue += 2;
                        }
                        
                        // Check if card helps with foundation building
                        if (this.helpsFoundationBuilding && this.helpsFoundationBuilding(card, gameState)) {
                            drawValue += 3;
                        }
                    });
                }
                
                // Decision logic
                let shouldDraw = false;
                let reason = '';
                
                if (currentMoves.length === 0) {
                    shouldDraw = true;
                    reason = 'No current moves available';
                } else if (immediateUseCards > 0) {
                    shouldDraw = true;
                    reason = `${immediateUseCards} immediately useful card(s) coming up`;
                } else if (drawValue >= 5) {
                    shouldDraw = true;
                    reason = `${valuableCards} valuable card(s) in next draw`;
                } else if (currentMoves.length < 2 && drawValue >= 3) {
                    shouldDraw = true;
                    reason = 'Limited current options, decent cards coming';
                } else {
                    shouldDraw = false;
                    reason = 'Better to play current available moves first';
                }
                
                return {
                    shouldDraw,
                    reason,
                    drawValue,
                    immediateUseCards,
                    valuableCards,
                    upcomingCards: upcomingCards.length > 0 ? 
                        upcomingCards.slice(0, gameState.drawMode || 1).map(card => `${card.rank}${card.suit}`) : [],
                    recommendation: shouldDraw ? 
                        `Draw ${gameState.drawMode} card(s) from stock` : 
                        'Focus on tableau moves first'
                };
            }
            
            // Web AI integration for enhanced intelligence
            async consultWebAI(gameState, question) {
                if (!this.webAIEnabled || Date.now() - this.lastWebAIQuery < 5000) {
                    return null; // Rate limiting
                }
                
                try {
                    const cacheKey = this.hashGameState(gameState) + question;
                    if (this.webAICache.has(cacheKey)) {
                        return this.webAICache.get(cacheKey);
                    }
                    
                    // Prepare game state for web AI
                    const gameDescription = this.prepareGameStateForWebAI(gameState);
                    
                    // This would connect to external AI services
                    // For now, we'll simulate advanced analysis
                    const webAIResponse = await this.simulateWebAIResponse(gameDescription, question);
                    
                    this.webAICache.set(cacheKey, webAIResponse);
                    this.lastWebAIQuery = Date.now();
                    
                    return webAIResponse;
                } catch (error) {
                    console.warn('Web AI consultation failed:', error);
                    return null;
                }
            }
            
            prepareGameStateForWebAI(gameState) {
                return {
                    foundations: Object.entries(gameState.foundations).map(([suit, pile]) => ({
                        suit,
                        count: pile.length,
                        nextNeeded: pile.length + 1
                    })),
                    tableau: gameState.tableau.map((pile, index) => ({
                        pileIndex: index,
                        totalCards: pile.length,
                        faceUpCards: pile.filter(c => c.faceUp).length,
                        topCard: pile.length > 0 ? `${pile[pile.length - 1].rank}${pile[pile.length - 1].suit}` : null,
                        isEmpty: pile.length === 0
                    })),
                    stock: {
                        remaining: gameState.stock.length,
                        drawMode: gameState.drawMode
                    },
                    waste: {
                        count: gameState.waste.length,
                        topCard: gameState.waste.length > 0 ? 
                            `${gameState.waste[gameState.waste.length - 1].rank}${gameState.waste[gameState.waste.length - 1].suit}` : null
                    },
                    gameStats: gameState.gameStats
                };
            }
            
            async simulateWebAIResponse(gameDescription, question) {
                // Simulate advanced AI analysis
                await new Promise(resolve => setTimeout(resolve, 100));
                
                return {
                    confidence: 0.85,
                    recommendation: 'Focus on foundation building while maintaining tableau flexibility',
                    strategicInsights: [
                        'Prioritize revealing face-down cards',
                        'Maintain color balance in tableau sequences',
                        'Use empty spaces strategically for Kings'
                    ],
                    riskAssessment: 'Low risk - good position for steady progress'
                };
            }
            
            checkWebAIAvailability() {
                // Check if we can connect to external AI services
                this.webAIEnabled = false; // Disabled by default for privacy
                
                // Could enable this if user opts in and API keys are available
                if (localStorage.getItem('enableWebAI') === 'true') {
                    this.webAIEnabled = true;
                    console.log('🌐 Web AI integration enabled');
                }
            }
            
            // Memory-optimized learning system - record game outcomes
            recordGameOutcome(gameState, moves, won, additionalData = null) {
                try {
                    if (!gameState) {
                        console.warn('Cannot record game outcome - no game state provided');
                        return;
                    }
                    
                    // Use memory manager for efficient game record creation
                    const compressedState = this.game.memory.compressGameState(gameState);
                const gameRecord = {
                    gameState: compressedState, // Store compressed state
                    moves: [...moves],
                    won: won,
                    timestamp: Date.now(),
                    difficulty: this.calculateGameDifficulty(gameState),
                    finalScore: gameState.gameStats.score,
                    totalTime: gameState.gameStats.time,
                    totalMoves: gameState.gameStats.moves,
                    additionalData: additionalData
                };
                
                // Store deadlock analysis for UI display
                if (additionalData && additionalData.reason === 'deadlock') {
                    this.lastDeadlockAnalysis = additionalData.analysis;
                    
                    // Record as a special category for learning
                    if (!this.gameMemory.deadlockGames) {
                        this.gameMemory.deadlockGames = [];
                    }
                    this.gameMemory.deadlockGames.push(gameRecord);
                    
                    // Learn from deadlock patterns using memory manager
                    this.recordDeadlockPatterns(gameRecord);
                    
                    // Limit deadlock memory
                    if (this.gameMemory.deadlockGames.length > 30) {
                        this.gameMemory.deadlockGames.shift();
                    }
                }
                
                if (won) {
                    this.gameMemory.winningGames.push(gameRecord);
                    
                    // Update neural weights based on successful strategies
                    this.updateNeuralWeights(gameRecord);
                    
                    // Record successful move patterns with memory optimization
                    this.recordSuccessfulMovesOptimized(moves);
                    
                    // Limit memory size
                    if (this.gameMemory.winningGames.length > 50) { // Reduced from 100 for memory efficiency
                        this.gameMemory.winningGames.shift();
                    }
                } else {
                    if (!this.gameMemory.losingGames) this.gameMemory.losingGames = [];
                    this.gameMemory.losingGames.push(gameRecord);
                    
                    // Learn from failures too
                    this.recordFailedMovesOptimized(moves);
                    
                    if (this.gameMemory.losingGames.length > 25) { // Reduced for memory efficiency
                        this.gameMemory.losingGames.shift();
                    }
                }
                
                // Use memory manager for move history tracking
                this.game.memory.moveHistory.push({
                    outcome: won ? 'win' : (additionalData?.reason === 'deadlock' ? 'deadlock' : 'loss'),
                    totalMoves: gameState.gameStats.moves,
                    finalScore: gameState.gameStats.score,
                    timestamp: Date.now()
                });
                
                // Asynchronous save to prevent blocking
                setTimeout(() => this.saveLearningData(), 100);
                
                const gameType = additionalData?.reason === 'deadlock' ? 'deadlocked' : (won ? 'winning' : 'losing');
                console.log(`🧠 Recorded ${gameType} game (optimized). Memory stats: Pool hit rate ${this.game.memory.getMemoryStats().hitRate}%, Cache size: ${this.game.memory.getMemoryStats().cacheSize}`);
                } catch (error) {
                    console.error('Error recording game outcome:', error);
                }
            }
            
            // Memory-optimized move recording
            recordSuccessfulMovesOptimized(moves) {
                moves.forEach(move => {
                    const pattern = this.createMovePattern(move);
                    this.game.memory.storePattern(pattern, true); // Success = true
                    
                    // Update traditional move outcomes too
                    const patternKey = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    if (!this.gameMemory.moveOutcomes.has(patternKey)) {
                        this.gameMemory.moveOutcomes.set(patternKey, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(patternKey);
                    outcome.successes++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            recordFailedMovesOptimized(moves) {
                moves.forEach(move => {
                    const pattern = this.createMovePattern(move);
                    this.game.memory.storePattern(pattern, false); // Success = false
                    
                    // Update traditional move outcomes too
                    const patternKey = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    if (!this.gameMemory.moveOutcomes.has(patternKey)) {
                        this.gameMemory.moveOutcomes.set(patternKey, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(patternKey);
                    outcome.failures++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            createMovePattern(move) {
                return {
                    type: move.type,
                    cardValue: move.card?.value || 0,
                    cardSuit: move.card?.suit || '',
                    targetType: move.targetType || '',
                    timestamp: Date.now()
                };
            }
            
            recordDeadlockPatterns(gameRecord) {
                try {
                    const analysis = gameRecord?.additionalData?.analysis || {};
                    
                    // Record common deadlock patterns for future detection
                    if (!this.gameMemory.deadlockPatterns) {
                        this.gameMemory.deadlockPatterns = {
                            excessiveStockCycling: 0,
                            suboptimalMidGame: 0,
                            unfavorableDeal: 0,
                            stockCycleThresholds: []
                        };
                    }
                    
                    // Ensure stockCycleThresholds is always an array
                    if (!Array.isArray(this.gameMemory.deadlockPatterns.stockCycleThresholds)) {
                        this.gameMemory.deadlockPatterns.stockCycleThresholds = [];
                    }
                    
                    // Track pattern frequencies
                    if (analysis.primaryCause === 'excessive_stock_cycling') {
                        this.gameMemory.deadlockPatterns.excessiveStockCycling++;
                        if (typeof analysis.stockCycles === 'number' && analysis.stockCycles > 0) {
                            this.gameMemory.deadlockPatterns.stockCycleThresholds.push(analysis.stockCycles);
                        }
                    } else if (analysis.primaryCause === 'suboptimal_mid_game_decisions') {
                        this.gameMemory.deadlockPatterns.suboptimalMidGame++;
                    } else if (analysis.primaryCause === 'unfavorable_initial_deal') {
                        this.gameMemory.deadlockPatterns.unfavorableDeal++;
                    }
                    
                    // Learn optimal stock cycle limits
                    if (this.gameMemory.deadlockPatterns.stockCycleThresholds.length > 10) {
                        this.gameMemory.deadlockPatterns.stockCycleThresholds.shift();
                    }
                    
                    console.log('🧠 Recorded deadlock pattern for future prevention');
                } catch (error) {
                    console.error('Error recording deadlock pattern:', error);
                }
            }
            
            updateNeuralWeights(winningGame) {
                // Analyze successful game for weight adjustments
                const moves = winningGame.moves;
                const foundationMoves = moves.filter(m => m.type === 'foundation').length;
                const sequenceMoves = moves.filter(m => m.type === 'tableau').length;
                const revealMoves = moves.filter(m => m.willReveal).length;
                
                // Adjust weights based on successful strategies
                if (foundationMoves / moves.length > 0.4) {
                    this.neuralWeights.foundationValue *= 1.05;
                }
                if (sequenceMoves / moves.length > 0.3) {
                    this.neuralWeights.sequenceValue *= 1.03;
                }
                if (revealMoves / moves.length > 0.2) {
                    this.neuralWeights.revealValue *= 1.02;
                }
                
                // Normalize weights to prevent runaway growth
                const totalWeight = Object.values(this.neuralWeights).reduce((sum, w) => sum + w, 0);
                if (totalWeight > 60) {
                    Object.keys(this.neuralWeights).forEach(key => {
                        this.neuralWeights[key] *= 0.95;
                    });
                }
            }
            
            recordSuccessfulMoves(moves) {
                moves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    
                    if (!this.gameMemory.moveOutcomes.has(pattern)) {
                        this.gameMemory.moveOutcomes.set(pattern, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    outcome.successes++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                    
                    // Record move sequences
                    if (moves.length >= 3) {
                        const sequence = moves.slice(0, 3).map(m => `${m.type}-${m.card?.value}`).join('->');
                        if (!this.gameMemory.sequencePatterns.has(sequence)) {
                            this.gameMemory.sequencePatterns.set(sequence, 0);
                        }
                        this.gameMemory.sequencePatterns.set(sequence, this.gameMemory.sequencePatterns.get(sequence) + 1);
                    }
                });
            }
            
            recordFailedMoves(moves) {
                moves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    
                    if (!this.gameMemory.moveOutcomes.has(pattern)) {
                        this.gameMemory.moveOutcomes.set(pattern, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    outcome.failures++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            // Enhanced game analysis with complete intelligence
            async getGameAnalysis(gameState) {
                try {
                    this.updateCompleteBoard(gameState);
                    
                    // Multi-layered analysis
                    const basicAnalysis = this.performBasicAnalysis(gameState);
                    const strategicAnalysis = this.performStrategicAnalysis(gameState);
                    const learningAnalysis = this.performLearningAnalysis(gameState);
                    const stockAnalysis = await this.recommendStockDrawing(gameState);
                    
                    // Web AI consultation if enabled
                    let webAIInsights = null;
                    if (this.webAIEnabled) {
                        webAIInsights = await this.consultWebAI(gameState, 'strategic_analysis');
                    }
                    
                    return {
                        winProbability: this.calculateWinProbability(gameState, strategicAnalysis),
                        difficulty: strategicAnalysis.difficulty,
                        recommendation: this.generateAdvancedRecommendation(basicAnalysis, strategicAnalysis, learningAnalysis),
                        stockRecommendation: stockAnalysis,
                        strategicInsights: strategicAnalysis.insights,
                        hiddenCardInsights: null, // Temporarily disabled due to method error
                        learningInsights: learningAnalysis,
                        webAIInsights: webAIInsights,
                        neuralWeights: { ...this.neuralWeights }
                    };
                } catch (error) {
                    console.error('Advanced game analysis error:', error);
                    return this.getFallbackAnalysis(gameState);
                }
            }
            
            performBasicAnalysis(gameState) {
                try {
                    if (!gameState) {
                        return {
                            foundationProgress: 0,
                            faceUpCards: 0,
                            emptySpaces: 0,
                            blockedCards: 0,
                            stockRemaining: 0,
                            wasteSize: 0
                        };
                    }
                    
                    const foundationCards = gameState.foundations ? 
                        Object.values(gameState.foundations).reduce((sum, pile) => sum + (pile ? pile.length : 0), 0) : 0;
                    const foundationProgress = foundationCards / 52;
                    const faceUpCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && c.faceUp).length : 0), 0);
                    const emptySpaces = (gameState.tableau || []).filter(pile => !pile || pile.length === 0).length;
                    const blockedCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && !c.faceUp).length : 0), 0);
                    
                    return {
                        foundationProgress,
                        faceUpCards,
                        emptySpaces,
                        blockedCards,
                        stockRemaining: gameState.stock ? gameState.stock.length : 0,
                        wasteSize: gameState.waste ? gameState.waste.length : 0
                    };
                } catch (error) {
                    console.warn('Error in basic analysis:', error);
                    return {
                        foundationProgress: 0,
                        faceUpCards: 0,
                        emptySpaces: 0,
                        blockedCards: 0,
                        stockRemaining: 0,
                        wasteSize: 0
                    };
                }
            }
            
            performStrategicAnalysis(gameState) {
                try {
                    const insights = [];
                    let difficulty = 'medium';
                    let strategicValue = 0;
                    let foundationGap = 0;
                    let longSequences = 0;
                    
                    if (!gameState) {
                        return {
                            insights: ['Strategic analysis unavailable - no game state'],
                            difficulty: 'medium',
                            strategicValue: 0,
                            foundationGap: 0,
                            longSequences: 0,
                            complexityScore: 3
                        };
                    }
                    
                    // Analyze foundation balance
                    if (gameState.foundations) {
                        const foundations = Object.values(gameState.foundations).map(pile => pile ? pile.length : 0);
                        const maxFoundation = foundations.length > 0 ? Math.max(...foundations) : 0;
                        const minFoundation = foundations.length > 0 ? Math.min(...foundations) : 0;
                        foundationGap = maxFoundation - minFoundation;
                        
                        if (foundationGap <= 1) {
                            insights.push('Excellent foundation balance maintained');
                            strategicValue += 3;
                        } else if (foundationGap >= 4) {
                            insights.push('Foundation imbalance detected - focus on lagging suits');
                            strategicValue -= 2;
                        }
                    }
                    
                    // Analyze sequence opportunities with complete board vision
                    if (gameState.tableau && Array.isArray(gameState.tableau)) {
                        gameState.tableau.forEach(pile => {
                            if (pile && Array.isArray(pile) && pile.length > 1) {
                                let currentSequence = 0;
                                for (let i = pile.length - 1; i > 0; i--) {
                                    if (pile[i] && pile[i-1] && pile[i].faceUp && pile[i-1].faceUp &&
                                        pile[i-1].value === pile[i].value + 1 &&
                                        this.game.constants.RED_SUITS.has(pile[i-1].suit) !== this.game.constants.RED_SUITS.has(pile[i].suit)) {
                                        currentSequence++;
                                    } else {
                                        break;
                                    }
                                }
                                if (currentSequence >= 3) longSequences++;
                            }
                        });
                        
                        if (longSequences >= 2) {
                            insights.push('Multiple long sequences available for strategic moves');
                            strategicValue += 2;
                        }
                    }
                    
                    // Analyze hidden card potential
                    const hiddenHighValue = this.countHiddenHighValueCards(gameState);
                    if (hiddenHighValue.aces > 0) {
                        insights.push(`${hiddenHighValue.aces} hidden Ace(s) - prioritize revealing them`);
                    }
                    if (hiddenHighValue.kings > 0 && gameState.tableau && 
                        gameState.tableau.filter(pile => !pile || pile.length === 0).length > 0) {
                        insights.push(`${hiddenHighValue.kings} hidden King(s) available for empty spaces`);
                    }
                    
                    // Calculate difficulty
                    const hiddenCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && !c.faceUp).length : 0), 0);
                    const stockUsed = gameState.stock ? (24 - gameState.stock.length) : 0;
                    
                    const complexityScore = (
                        hiddenCards * 0.1 +
                        foundationGap * 0.2 +
                        stockUsed * 0.05
                    );
                    
                    if (complexityScore < 2) difficulty = 'easy';
                    else if (complexityScore < 4) difficulty = 'medium';
                    else if (complexityScore < 6) difficulty = 'hard';
                    else difficulty = 'expert';
                    
                    return {
                        insights,
                        difficulty,
                        strategicValue,
                        foundationGap,
                        longSequences,
                        complexityScore
                    };
                } catch (error) {
                    console.warn('Error in strategic analysis:', error);
                    return {
                        insights: ['Strategic analysis temporarily unavailable'],
                        difficulty: 'medium',
                        strategicValue: 0,
                        foundationGap: 0,
                        longSequences: 0,
                        complexityScore: 3
                    };
                }
            }
            
            performLearningAnalysis(gameState) {
                try {
                    const insights = [];
                    let confidenceBoost = 0;
                    
                    if (!gameState) {
                        return {
                            insights: ['Learning analysis unavailable - no game state'],
                            confidenceBoost: 0,
                            similarWinningGames: 0,
                            historicallySuccessfulMoves: 0,
                            totalLearningData: this.gameMemory.winningGames.length
                        };
                    }
                    
                    // Check against successful game patterns
                    const currentStateHash = this.hashGameState(gameState);
                    let similarWinningGames = 0;
                    
                    this.gameMemory.winningGames.forEach(game => {
                        try {
                            const gameStateToHash = game.gameState || game;
                            const similarity = this.calculateStateSimilarity(currentStateHash, this.hashGameState(gameStateToHash));
                            if (similarity > 0.7) {
                                similarWinningGames++;
                            }
                        } catch (hashError) {
                            // Skip this game if comparison fails
                        }
                    });
                    
                    if (similarWinningGames > 0) {
                        insights.push(`Similar to ${similarWinningGames} previously won game(s)`);
                        confidenceBoost += 0.2;
                    }
                    
                    // Check move success patterns
                    let historicallySuccessfulMoves = 0;
                    
                    try {
                        const availableMoves = this.game.ai.findAllPossibleMoves();
                        availableMoves.forEach(move => {
                            const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                            const outcome = this.gameMemory.moveOutcomes.get(pattern);
                            if (outcome && outcome.successRate > 0.6) {
                                historicallySuccessfulMoves++;
                            }
                        });
                    } catch (moveError) {
                        console.warn('Error analyzing available moves:', moveError);
                    }
                    
                    if (historicallySuccessfulMoves > 0) {
                        insights.push(`${historicallySuccessfulMoves} historically successful move(s) available`);
                        confidenceBoost += 0.1;
                    }
                    
                    return {
                        insights,
                        confidenceBoost,
                        similarWinningGames,
                        historicallySuccessfulMoves,
                        totalLearningData: this.gameMemory.winningGames.length
                    };
                } catch (error) {
                    console.warn('Error in learning analysis:', error);
                    return {
                        insights: ['Learning analysis temporarily unavailable'],
                        confidenceBoost: 0,
                        similarWinningGames: 0,
                        historicallySuccessfulMoves: 0,
                        totalLearningData: this.gameMemory.winningGames.length
                    };
                }
            }
            
            calculateWinProbability(gameState, strategicAnalysis) {
                const basic = this.performBasicAnalysis(gameState);
                
                let winProb = 0.3; // Base probability
                
                // Foundation progress (40% weight)
                winProb += basic.foundationProgress * 0.4;
                
                // Face-up card ratio (20% weight)
                winProb += (basic.faceUpCards / 28) * 0.2;
                
                // Strategic factors (25% weight)
                winProb += Math.max(0, strategicAnalysis.strategicValue / 10) * 0.25;
                
                // Learning boost (10% weight)
                const learningAnalysis = this.performLearningAnalysis(gameState);
                winProb += learningAnalysis.confidenceBoost * 0.1;
                
                // Stock efficiency (5% weight)
                winProb += (1 - basic.stockRemaining / 24) * 0.05;
                
                return Math.min(0.95, Math.max(0.05, winProb));
            }
            
            generateAdvancedRecommendation(basicAnalysis, strategicAnalysis, learningAnalysis) {
                const foundationProgress = basicAnalysis.foundationProgress;
                const insights = [...strategicAnalysis.insights, ...learningAnalysis.insights];
                
                if (foundationProgress > 0.8) {
                    return `🏆 Victory is near! ${insights[0] || 'Focus on final foundation moves.'}`;
                } else if (foundationProgress > 0.6) {
                    return `💪 Strong position! ${insights[0] || 'Maintain strategic pressure on foundations.'}`;
                } else if (foundationProgress > 0.4) {
                    return `🎯 Good progress! ${insights[0] || 'Continue revealing cards and building sequences.'}`;
                } else if (strategicAnalysis.longSequences > 0) {
                    return `🔄 Strategic opportunity! ${insights[0] || 'Use long sequences to create foundation opportunities.'}`;
                } else {
                    return `🧠 Challenging position! ${insights[0] || 'Focus on revealing hidden cards and creating space.'}`;
                }
            }
            
            analyzeHiddenCards(gameState) {
                const hiddenInsights = [];
                let totalHiddenValue = 0;
                
                gameState.tableau.forEach((pile, pileIndex) => {
                    pile.forEach((card, cardIndex) => {
                        if (!card.faceUp) {
                            const strategicValue = this.calculateCardStrategicValue(card.suit, card.value);
                            totalHiddenValue += strategicValue;
                            
                            // AI knows what the hidden cards are
                            if (card.value === 1) {
                                hiddenInsights.push(`Hidden Ace of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            } else if (card.value === 13) {
                                hiddenInsights.push(`Hidden King of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            } else if (card.value >= 11) {
                                hiddenInsights.push(`Hidden ${card.rank} of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            }
                        }
                    });
                });
                
                return {
                    insights: hiddenInsights,
                    totalValue: totalHiddenValue,
                    count: hiddenInsights.length
                };
            }
            
            // Helper methods
            canRevealSoon(cardInfo) {
                if (cardInfo.location.startsWith('tableau-')) {
                    const pileIndex = parseInt(cardInfo.location.split('-')[1]);
                    const pile = this.game.state.tableau[pileIndex];
                    return cardInfo.position >= pile.length - 3; // Within 3 moves of top
                }
                return false;
            }
            
            canUseCardImmediately(card, gameState) {
                // Check if card can go to foundation
                if (this.game.rules.canPlaceOnFoundation(card)) {
                    return true;
                }
                
                // Check if card can go to tableau
                for (const pile of gameState.tableau) {
                    if (this.game.rules.canPlaceOnTableau(card, pile)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            helpsFoundationBuilding(card, gameState) {
                const foundationPile = gameState.foundations[card.suit];
                const nextNeeded = foundationPile.length + 1;
                return card.value === nextNeeded;
            }
            
            moveCreatesOpportunityFor(move, futureCard) {
                // Check if the current move creates space or sequences for future card
                if (move.type === 'foundation' && futureCard.value === 1) {
                    return true; // Foundation moves create space for Aces
                }
                
                if (move.type === 'tableau' && move.card && futureCard.value === move.card.value - 1) {
                    const moveCardIsRed = this.game.constants.RED_SUITS.has(move.card.suit);
                    const futureCardIsRed = this.game.constants.RED_SUITS.has(futureCard.suit);
                    return moveCardIsRed !== futureCardIsRed; // Alternating colors
                }
                
                return false;
            }
            
            countHiddenHighValueCards(gameState) {
                let aces = 0, kings = 0, faces = 0;
                
                try {
                    if (!gameState || !gameState.tableau) {
                        return { aces: 0, kings: 0, faces: 0 };
                    }
                    
                    gameState.tableau.forEach(pile => {
                        if (pile && Array.isArray(pile)) {
                            pile.forEach(card => {
                                if (card && !card.faceUp) {
                                    if (card.value === 1) aces++;
                                    else if (card.value === 13) kings++;
                                    else if (card.value >= 11) faces++;
                                }
                            });
                        }
                    });
                } catch (error) {
                    console.warn('Error counting hidden high value cards:', error);
                }
                
                return { aces, kings, faces };
            }
            
            cloneGameState(gameState) {
                try {
                    if (!gameState) {
                        console.warn('Cannot clone null/undefined game state');
                        return this.createDefaultGameState();
                    }
                    
                    // Only include the deck arrays, foundations, and gameStats—omit 'game' and other managers
                    return {
                        stock: (gameState.stock || []).map(card => ({ 
                            id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                        })),
                        waste: (gameState.waste || []).map(card => ({ 
                            id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                        })),
                        tableau: (gameState.tableau || []).map(pile =>
                            (pile || []).map(card => ({ 
                                id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                            }))
                        ),
                        foundations: gameState.foundations ? Object.fromEntries(
                            Object.entries(gameState.foundations).map(([suit, pile]) =>
                                [suit, (pile || []).map(card => ({ 
                                    id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                                }))]
                            )
                        ) : { '♠': [], '♥': [], '♦': [], '♣': [] },
                        gameStats: gameState.gameStats ? {
                            moves: gameState.gameStats.moves || 0,
                            time: gameState.gameStats.time || 0,
                            score: gameState.gameStats.score || 0
                        } : { moves: 0, time: 0, score: 0 }
                    };
                } catch (error) {
                    console.warn('Error cloning game state:', error);
                    return this.createDefaultGameState();
                }
            }
            
            createDefaultGameState() {
                return {
                    stock: [],
                    waste: [],
                    tableau: Array.from({ length: 7 }, () => []),
                    foundations: { '♠': [], '♥': [], '♦': [], '♣': [] },
                    gameStats: { moves: 0, time: 0, score: 0 }
                };
            }
            
            hashGameState(gameState) {
                try {
                    if (!gameState) return 'empty';
                    
                    const state = {
                        foundations: gameState.foundations ? 
                            Object.entries(gameState.foundations).map(([suit, pile]) => `${suit}:${pile ? pile.length : 0}`) : [],
                        tableau: gameState.tableau ? 
                            gameState.tableau.map(pile => pile ? pile.length : 0) : [],
                        stock: gameState.stock ? gameState.stock.length : 0,
                        waste: gameState.waste ? gameState.waste.length : 0
                    };
                    return JSON.stringify(state);
                } catch (error) {
                    console.warn('Error hashing game state:', error);
                    return 'error_' + Date.now();
                }
            }
            
            calculateStateSimilarity(state1Hash, state2Hash) {
                // Simple similarity calculation - could be more sophisticated
                return state1Hash === state2Hash ? 1.0 : 0.5;
            }
            
            calculateGameDifficulty(gameState) {
                try {
                    if (!gameState) return 'medium';
                    
                    const hiddenCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && !c.faceUp).length : 0), 0);
                    const foundationProgress = gameState.foundations ? 
                        Object.values(gameState.foundations).reduce((sum, pile) => 
                            sum + (pile ? pile.length : 0), 0) / 52 : 0;
                    
                    if (hiddenCards <= 5 && foundationProgress > 0.5) return 'easy';
                    if (hiddenCards <= 15 && foundationProgress > 0.2) return 'medium';
                    if (hiddenCards <= 21) return 'hard';
                    return 'expert';
                } catch (error) {
                    console.warn('Error calculating game difficulty:', error);
                    return 'medium';
                }
            }
            
            getFallbackAnalysis(gameState) {
                const basic = this.performBasicAnalysis(gameState);
                return {
                    winProbability: basic.foundationProgress * 0.6 + 0.3,
                    difficulty: 'medium',
                    recommendation: 'Continue playing strategically',
                    stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                };
            }
            
            // Memory-optimized data persistence
            async saveLearningData() {
                try {
                    // Use memory manager for efficient data structures
                    const learningData = {
                        version: '3.0', // Updated version for memory optimization
                        timestamp: Date.now(),
                        gameMemory: {
                            // Compress winning games for storage efficiency
                            winningGames: this.gameMemory.winningGames.slice(-30).map(game => {
                                try {
                                    const stateToCompress = game.gameState || game;
                                    return this.game.memory.compressGameState(stateToCompress);
                                } catch (error) {
                                    console.warn('Error compressing game state, using empty buffer:', error);
                                    return new Uint8Array(256);
                                }
                            }),
                            // Store move outcomes efficiently
                            moveOutcomes: Array.from(this.gameMemory.moveOutcomes.entries()).slice(-500),
                            sequencePatterns: Array.from(this.gameMemory.sequencePatterns.entries()).slice(-200),
                            // Include deadlock patterns for improved learning
                            deadlockPatterns: this.gameMemory.deadlockPatterns || {},
                            deadlockGames: (this.gameMemory.deadlockGames || []).slice(-20)
                        },
                        neuralWeights: this.neuralWeights,
                        // Store memory stats for analysis
                        optimizationStats: this.game.memory.getMemoryStats()
                    };
                    
                    // Use efficient storage with memory manager's pattern storage
                    this.game.memory.patternMap.forEach((entry, key) => {
                        this.game.storage.set(`pattern_${key}`, {
                            outcomes: Array.from(entry.outcomes),
                            count: entry.count,
                            successRate: entry.successRate
                        });
                    });
                    
                    this.game.storage.set('advanced_ml_learning_data', learningData);
                    
                    console.log(`🧠 Saved optimized learning data: ${learningData.gameMemory.winningGames.length} compressed games, ${this.game.memory.patternMap.size} patterns`);
                } catch (error) {
                    console.warn('Failed to save learning data:', error);
                }
            }
            
            async loadLearningData() {
                try {
                    const saved = this.game.storage.get('advanced_ml_learning_data');
                    if (saved) {
                        if (saved.version === '3.0') {
                            // Load compressed data efficiently with error handling
                            const compressedGames = saved.gameMemory.winningGames || [];
                            this.gameMemory.winningGames = [];
                            
                            compressedGames.forEach((compressed, index) => {
                                try {
                                    const gameState = this.game.memory.decompressGameState(compressed);
                                    if (gameState) {
                                        this.gameMemory.winningGames.push({
                                            gameState: gameState,
                                            won: true,
                                            timestamp: Date.now() // Approximated for efficiency
                                        });
                                    }
                                } catch (error) {
                                    console.warn(`Failed to decompress game ${index}:`, error);
                                }
                            });
                            
                            this.gameMemory.moveOutcomes = new Map(saved.gameMemory.moveOutcomes || []);
                            this.gameMemory.sequencePatterns = new Map(saved.gameMemory.sequencePatterns || []);
                            this.gameMemory.deadlockPatterns = saved.gameMemory.deadlockPatterns || {};
                            this.gameMemory.deadlockGames = saved.gameMemory.deadlockGames || [];
                            this.neuralWeights = { ...this.neuralWeights, ...saved.neuralWeights };
                            
                            // Load pattern data into memory manager with error handling
                            try {
                                const patternKeys = Object.keys(localStorage).filter(key => key.startsWith('pattern_'));
                                patternKeys.forEach(key => {
                                    try {
                                        const patternKey = key.replace('pattern_', '');
                                        const patternData = this.game.storage.get(key);
                                        if (patternData && patternData.outcomes) {
                                            this.game.memory.patternMap.set(patternKey, {
                                                outcomes: new Float32Array(patternData.outcomes),
                                                count: patternData.count || 0,
                                                successRate: patternData.successRate || 0
                                            });
                                        }
                                    } catch (patternError) {
                                        console.warn(`Failed to load pattern ${key}:`, patternError);
                                    }
                                });
                            } catch (error) {
                                console.warn('Failed to load pattern data:', error);
                            }
                            
                            console.log(`🧠 Loaded optimized learning data: ${this.gameMemory.winningGames.length} games, ${this.game.memory.patternMap.size} patterns, ${Object.keys(this.gameMemory.deadlockPatterns).length} deadlock patterns`);
                        } else if (saved.version === '2.0') {
                            // Legacy data migration
                            this.gameMemory.winningGames = saved.gameMemory.winningGames || [];
                            this.gameMemory.moveOutcomes = new Map(saved.gameMemory.moveOutcomes || []);
                            this.gameMemory.sequencePatterns = new Map(saved.gameMemory.sequencePatterns || []);
                            this.neuralWeights = { ...this.neuralWeights, ...saved.neuralWeights };
                            
                            console.log(`🧠 Migrated legacy learning data: ${this.gameMemory.winningGames.length} games`);
                            // Save in new format
                            setTimeout(() => this.saveLearningData(), 1000);
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load learning data:', error);
                    // Clear potentially corrupted data
                    try {
                        localStorage.removeItem('advanced_ml_learning_data');
                        console.log('🧠 Cleared corrupted learning data, starting fresh');
                    } catch (clearError) {
                        console.warn('Failed to clear corrupted data:', clearError);
                    }
                }
            }
            
            dispose() {
                // Save learning data before cleanup
                this.saveLearningData();
                
                // Clear game memory to free up space
                this.gameMemory.winningGames.length = 0;
                this.gameMemory.losingGames = [];
                this.gameMemory.deadlockGames = [];
                this.gameMemory.moveOutcomes.clear();
                this.gameMemory.sequencePatterns.clear();
                this.gameMemory.positionEvaluations.clear();
                
                // Clear complete board tracking
                this.completeBoard.allCards.clear();
                this.completeBoard.hiddenCards.clear();
                this.completeBoard.stockOrder.length = 0;
                this.completeBoard.futureStockCards.length = 0;
                
                // Clear web AI cache
                this.webAICache.clear();
                
                this.isDisposed = true;
                this.isInitialized = false;
                console.log('🧠 Advanced ML resources cleaned up and learning data saved');
            }
        }

        // Enhanced Persistent Learning System
        class PersistentLearningManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.isInitialized = false;
                this.remoteStorageEnabled = false;
                
                // Learning data structure
                this.learningDatabase = {
                    version: '4.0',
                    metadata: {
                        totalGamesPlayed: 0,
                        totalGamesWon: 0,
                        winRate: 0,
                        lastUpdated: Date.now(),
                        analyticsId: this.generateAnalyticsId()
                    },
                    gameRecords: [], // All games (wins and losses)
                    patterns: {
                        winningPatterns: new Map(),
                        losingPatterns: new Map(),
                        moveEffectiveness: new Map(),
                        stockDrawPatterns: new Map(),
                        foundationSequences: new Map()
                    },
                    strategies: {
                        successfulOpenings: new Map(),
                        effectiveMidGameTactics: new Map(),
                        endGameOptimizations: new Map()
                    },
                    adaptiveWeights: {
                        foundationPriority: 1.0,
                        revealingBonus: 1.0,
                        sequenceBuilding: 1.0,
                        stockDrawPenalty: 1.0
                    },
                    performanceMetrics: {
                        averageMovesPerWin: 0,
                        averageTimePerWin: 0,
                        mostEffectiveStrategies: [],
                        commonFailurePoints: []
                    }
                };
                
                this.initializePersistentStorage();
            }
            
            generateAnalyticsId() {
                return 'kl_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now().toString(36);
            }
            
            async initializePersistentStorage() {
                try {
                    console.log('🧠 Initializing Enhanced Persistent Learning System...');
                    await this.loadLocalData();
                    await this.loadRemoteData();
                    this.setupAutoSave();
                    await this.setupRemoteSync();
                    this.isInitialized = true;
                    console.log(`🧠 Learning system initialized with ${this.learningDatabase.gameRecords.length} game records`);
                } catch (error) {
                    console.warn('Failed to initialize learning system:', error);
                    this.isInitialized = true;
                }
            }
            
            async loadLocalData() {
                try {
                    const localData = this.game.storage.get('persistent_learning_v4');
                    if (localData) {
                        this.mergeLearningData(localData);
                        console.log(`📚 Loaded ${localData.gameRecords?.length || 0} local game records`);
                    }
                } catch (error) {
                    console.warn('Failed to load local learning data:', error);
                }
            }
            
            async loadRemoteData() {
                try {
                    const response = await fetch('./data/learning-data.json', { 
                        cache: 'no-cache',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (response.ok) {
                        const remoteData = await response.json();
                        this.mergeLearningData(remoteData);
                        this.remoteStorageEnabled = true;
                        console.log(`🌐 Loaded remote learning data: ${remoteData.gameRecords?.length || 0} records`);
                    }
                } catch (error) {
                    console.log('🌐 Remote learning data not available (expected for first-time users)');
                }
            }
            
            mergeLearningData(newData) {
                if (!newData || newData.version !== '4.0') return;
                
                this.learningDatabase.metadata.totalGamesPlayed = Math.max(
                    this.learningDatabase.metadata.totalGamesPlayed,
                    newData.metadata?.totalGamesPlayed || 0
                );
                
                if (newData.gameRecords) {
                    const existingIds = new Set(this.learningDatabase.gameRecords.map(r => r.id));
                    const newRecords = newData.gameRecords.filter(r => !existingIds.has(r.id));
                    this.learningDatabase.gameRecords.push(...newRecords);
                }
                
                if (newData.adaptiveWeights) {
                    this.learningDatabase.adaptiveWeights = {
                        ...this.learningDatabase.adaptiveWeights,
                        ...newData.adaptiveWeights
                    };
                }
            }
            
            async recordGameResult(gameData) {
                if (!this.isInitialized) return;
                
                try {
                    const gameRecord = {
                        id: `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        timestamp: Date.now(),
                        won: gameData.won,
                        moves: gameData.moves || 0,
                        timeElapsed: gameData.timeElapsed || 0,
                        finalState: this.compressGameState(gameData.finalState),
                        moveSequence: gameData.moveSequence || [],
                        strategyUsed: gameData.strategyUsed || 'standard',
                        aiAssisted: gameData.aiAssisted || false,
                        difficulty: this.calculateGameDifficulty(gameData.finalState),
                        patterns: this.extractGamePatterns(gameData)
                    };
                    
                    this.learningDatabase.gameRecords.push(gameRecord);
                    
                    this.learningDatabase.metadata.totalGamesPlayed++;
                    if (gameData.won) {
                        this.learningDatabase.metadata.totalGamesWon++;
                    }
                    this.learningDatabase.metadata.winRate = 
                        (this.learningDatabase.metadata.totalGamesWon / this.learningDatabase.metadata.totalGamesPlayed) * 100;
                    this.learningDatabase.metadata.lastUpdated = Date.now();
                    
                    await this.learnFromGame(gameRecord);
                    await this.saveAllData();
                    
                    console.log(`🧠 Recorded ${gameData.won ? 'WIN' : 'LOSS'}: Total games: ${this.learningDatabase.metadata.totalGamesPlayed}, Win rate: ${this.learningDatabase.metadata.winRate.toFixed(1)}%`);
                    
                } catch (error) {
                    console.error('Failed to record game result:', error);
                }
            }
            
            calculateGameDifficulty(finalState) {
                if (!finalState) return 'unknown';
                
                const hiddenCards = finalState.tableau?.reduce((sum, pile) => 
                    sum + pile.filter(c => !c.faceUp).length, 0) || 0;
                const foundationCards = Object.values(finalState.foundations || {})
                    .reduce((sum, pile) => sum + pile.length, 0);
                
                if (foundationCards > 40) return 'easy';
                if (foundationCards > 20) return 'medium';
                if (hiddenCards < 10) return 'medium';
                return 'hard';
            }
            
            extractGamePatterns(gameData) {
                const patterns = {
                    openingMoves: gameData.moveSequence?.slice(0, 5) || [],
                    foundationBuilding: [],
                    stockCycling: 0,
                    revealingMoves: 0
                };
                
                gameData.moveSequence?.forEach(move => {
                    if (move.type?.includes('foundation')) {
                        patterns.foundationBuilding.push({
                            card: move.card,
                            timing: patterns.foundationBuilding.length
                        });
                    }
                    if (move.type === 'draw_stock') {
                        patterns.stockCycling++;
                    }
                    if (move.revealsCard) {
                        patterns.revealingMoves++;
                    }
                });
                
                return patterns;
            }
            
            async learnFromGame(gameRecord) {
                try {
                    this.updateMoveEffectiveness(gameRecord);
                    this.updateStrategyEffectiveness(gameRecord);
                    this.adaptAIWeights(gameRecord);
                    this.updatePerformanceMetrics(gameRecord);
                } catch (error) {
                    console.warn('Failed to learn from game:', error);
                }
            }
            
            updateMoveEffectiveness(gameRecord) {
                try {
                    const effectiveness = this.learningDatabase.patterns.moveEffectiveness;
                    
                    gameRecord.moveSequence?.forEach((move, index) => {
                        const moveKey = `${move.type || 'unknown'}_${move.card?.value || 'any'}`;
                        
                        if (!effectiveness.has(moveKey)) {
                            effectiveness.set(moveKey, { wins: 0, losses: 0, total: 0 });
                        }
                        
                        const stats = effectiveness.get(moveKey);
                        stats.total++;
                        
                        if (gameRecord.won) {
                            stats.wins++;
                        } else {
                            stats.losses++;
                        }
                        
                        effectiveness.set(moveKey, stats);
                    });
                } catch (error) {
                    console.warn('Error updating move effectiveness:', error);
                }
            }
            
            updateStrategyEffectiveness(gameRecord) {
                try {
                    const strategy = gameRecord.strategyUsed || 'standard';
                    const strategies = this.learningDatabase.strategies;
                    
                    if (gameRecord.patterns?.openingMoves?.length > 0) {
                        const openingKey = gameRecord.patterns.openingMoves.slice(0, 3)
                            .map(m => m.type || 'unknown').join('-');
                        
                        if (!strategies.successfulOpenings.has(openingKey)) {
                            strategies.successfulOpenings.set(openingKey, { wins: 0, total: 0 });
                        }
                        
                        const openingStats = strategies.successfulOpenings.get(openingKey);
                        openingStats.total++;
                        if (gameRecord.won) openingStats.wins++;
                        strategies.successfulOpenings.set(openingKey, openingStats);
                    }
                } catch (error) {
                    console.warn('Error updating strategy effectiveness:', error);
                }
            }
            
            updatePerformanceMetrics(gameRecord) {
                try {
                    const metrics = this.learningDatabase.performanceMetrics;
                    
                    if (gameRecord.won) {
                        const currentAvg = metrics.averageMovesPerWin || 0;
                        const totalWins = this.learningDatabase.metadata.totalGamesWon;
                        metrics.averageMovesPerWin = ((currentAvg * (totalWins - 1)) + gameRecord.moves) / totalWins;
                        
                        if (gameRecord.timeElapsed) {
                            const currentTimeAvg = metrics.averageTimePerWin || 0;
                            metrics.averageTimePerWin = ((currentTimeAvg * (totalWins - 1)) + gameRecord.timeElapsed) / totalWins;
                        }
                    }
                } catch (error) {
                    console.warn('Error updating performance metrics:', error);
                }
            }
            
            generateStrategySuggestions() {
                try {
                    const suggestions = [];
                    const winRate = this.learningDatabase.metadata.winRate;
                    
                    if (winRate < 20) {
                        suggestions.push('Focus on foundation building early in the game');
                        suggestions.push('Prioritize revealing hidden cards over lateral moves');
                    } else if (winRate < 40) {
                        suggestions.push('Consider stock cycling patterns more carefully');
                        suggestions.push('Look for multi-move sequences that create progress');
                    } else {
                        suggestions.push('Experiment with advanced strategies');
                        suggestions.push('Focus on optimizing move efficiency');
                    }
                    
                    return suggestions;
                } catch (error) {
                    console.warn('Error generating strategy suggestions:', error);
                    return ['Continue practicing to improve your game'];
                }
            }
            
            adaptAIWeights(gameRecord) {
                const weights = this.learningDatabase.adaptiveWeights;
                const learningRate = 0.01;
                
                if (gameRecord.won) {
                    if (gameRecord.patterns.foundationBuilding.length > 0) {
                        weights.foundationPriority = Math.min(2.0, 
                            weights.foundationPriority + learningRate);
                    }
                    
                    if (gameRecord.patterns.revealingMoves > 5) {
                        weights.revealingBonus = Math.min(2.0,
                            weights.revealingBonus + learningRate);
                    }
                } else {
                    if (gameRecord.patterns.stockCycling > 20) {
                        weights.stockDrawPenalty = Math.max(0.5,
                            weights.stockDrawPenalty - learningRate);
                    }
                }
            }
            
            getAdaptiveWeights() {
                return { ...this.learningDatabase.adaptiveWeights };
            }
            
            getPerformanceAnalytics() {
                try {
                    return {
                        metadata: this.learningDatabase.metadata,
                        recentPerformance: this.analyzeRecentPerformance(),
                        strategySuggestions: this.generateStrategySuggestions(),
                        learningProgress: this.calculateLearningProgress ? this.calculateLearningProgress() : {
                            stage: 'beginner',
                            progress: 0,
                            gamesPlayed: 0,
                            skillLevel: 'learning'
                        }
                    };
                } catch (error) {
                    console.warn('Error in getPerformanceAnalytics:', error);
                    return {
                        metadata: this.learningDatabase.metadata,
                        recentPerformance: { recentWinRate: 0, improvementTrend: 'insufficient-data', gamesAnalyzed: 0 },
                        strategySuggestions: ['Continue practicing to improve your game'],
                        learningProgress: {
                            stage: 'beginner',
                            progress: 0,
                            gamesPlayed: 0,
                            skillLevel: 'learning'
                        }
                    };
                }
            }

            calculateLearningProgress() {
                try {
                    const totalGames = this.learningDatabase.metadata.totalGamesPlayed;
                    const winRate = this.learningDatabase.metadata.winRate;
                    
                    if (totalGames === 0) {
                        return {
                            stage: 'beginner',
                            progress: 0,
                            gamesPlayed: 0,
                            skillLevel: 'learning'
                        };
                    }
                    
                    let stage = 'beginner';
                    let skillLevel = 'learning';
                    
                    if (totalGames >= 100) {
                        stage = 'expert';
                        skillLevel = winRate > 15 ? 'advanced' : 'intermediate';
                    } else if (totalGames >= 50) {
                        stage = 'intermediate';
                        skillLevel = winRate > 10 ? 'intermediate' : 'learning';
                    } else if (totalGames >= 20) {
                        stage = 'developing';
                        skillLevel = winRate > 5 ? 'developing' : 'learning';
                    }
                    
                    const progress = Math.min(100, (totalGames / 100) * 100);
                    
                    return {
                        stage: stage,
                        progress: progress,
                        gamesPlayed: totalGames,
                        skillLevel: skillLevel,
                        winRate: winRate
                    };
                } catch (error) {
                    console.warn('Error calculating learning progress:', error);
                    return {
                        stage: 'beginner',
                        progress: 0,
                        gamesPlayed: 0,
                        skillLevel: 'learning'
                    };
                }
            }
            
            analyzeRecentPerformance() {
                const recentGames = this.learningDatabase.gameRecords.slice(-50);
                const recentWins = recentGames.filter(g => g.won).length;
                
                return {
                    recentWinRate: (recentWins / Math.max(1, recentGames.length)) * 100,
                    improvementTrend: this.calculateImprovementTrend(recentGames),
                    gamesAnalyzed: recentGames.length
                };
            }
            
            calculateImprovementTrend(recentGames) {
                if (recentGames.length < 10) return 'insufficient-data';
                
                const firstHalf = recentGames.slice(0, Math.floor(recentGames.length / 2));
                const secondHalf = recentGames.slice(Math.floor(recentGames.length / 2));
                
                const firstHalfWinRate = firstHalf.filter(g => g.won).length / firstHalf.length;
                const secondHalfWinRate = secondHalf.filter(g => g.won).length / secondHalf.length;
                
                const improvement = secondHalfWinRate - firstHalfWinRate;
                
                if (improvement > 0.1) return 'improving';
                if (improvement < -0.1) return 'declining';
                return 'stable';
            }
            
            async saveAllData() {
                try {
                    const localData = {
                        ...this.learningDatabase,
                        gameRecords: this.learningDatabase.gameRecords.slice(-100),
                        patterns: this.convertMapsToObjects(this.learningDatabase.patterns),
                        strategies: this.convertMapsToObjects(this.learningDatabase.strategies)
                    };
                    
                    this.game.storage.set('persistent_learning_v4', localData);
                    await this.generateDataFile();
                    
                    console.log('💾 Learning data saved to all storage systems');
                } catch (error) {
                    console.warn('Failed to save learning data:', error);
                }
            }
            
            convertMapsToObjects(mapContainer) {
                const result = {};
                Object.keys(mapContainer).forEach(key => {
                    if (mapContainer[key] instanceof Map) {
                        result[key] = Object.fromEntries(mapContainer[key]);
                    } else {
                        result[key] = mapContainer[key];
                    }
                });
                return result;
            }
            
            async generateDataFile() {
                try {
                    const exportData = {
                        version: '4.0',
                        exported: new Date().toISOString(),
                        metadata: this.learningDatabase.metadata,
                        analytics: this.getPerformanceAnalytics(),
                        anonymizedPatterns: this.anonymizePatterns(),
                        aggregatedStats: this.generateAggregatedStats()
                    };
                    
                    const dataBlob = new Blob([JSON.stringify(exportData, null, 2)], {
                        type: 'application/json'
                    });
                    
                    this.latestExportData = exportData;
                    
                    // Create download link for manual GitHub upload
                    if (this.learningDatabase.gameRecords.length > 0 && this.learningDatabase.gameRecords.length % 25 === 0) {
                        this.createDownloadLink(dataBlob);
                    }
                    
                    console.log('📄 Generated exportable learning data file');
                } catch (error) {
                    console.warn('Failed to generate data file:', error);
                }
            }
            
            createDownloadLink(dataBlob) {
                const url = URL.createObjectURL(dataBlob);
                const downloadElement = document.createElement('a');
                downloadElement.href = url;
                downloadElement.download = `solitaire-learning-data-${Date.now()}.json`;
                downloadElement.style.display = 'none';
                document.body.appendChild(downloadElement);
                
                // Show a notification about the download option
                console.log('📥 Learning data export available - check browser downloads for GitHub upload');
                setTimeout(() => {
                    document.body.removeChild(downloadElement);
                    URL.revokeObjectURL(url);
                }, 5000);
            }
            
            anonymizePatterns() {
                return {
                    moveEffectiveness: Object.fromEntries(this.learningDatabase.patterns.moveEffectiveness),
                    totalGamesAnalyzed: this.learningDatabase.gameRecords.length,
                    winRateTrends: this.extractWinRateTrends(),
                    strategicInsights: this.extractStrategicInsights()
                };
            }
            
            extractWinRateTrends() {
                try {
                    const recentGames = this.learningDatabase.gameRecords.slice(-50);
                    if (recentGames.length < 10) {
                        return { trend: 'insufficient-data', recentWinRate: 0, improvement: 0 };
                    }
                    
                    const firstHalf = recentGames.slice(0, Math.floor(recentGames.length / 2));
                    const secondHalf = recentGames.slice(Math.floor(recentGames.length / 2));
                    
                    const firstHalfWinRate = firstHalf.filter(g => g.won).length / firstHalf.length;
                    const secondHalfWinRate = secondHalf.filter(g => g.won).length / secondHalf.length;
                    
                    const improvement = secondHalfWinRate - firstHalfWinRate;
                    const recentWinRate = secondHalfWinRate * 100;
                    
                    let trend = 'stable';
                    if (improvement > 0.1) trend = 'improving';
                    else if (improvement < -0.1) trend = 'declining';
                    
                    return {
                        trend,
                        recentWinRate: Math.round(recentWinRate * 10) / 10,
                        improvement: Math.round(improvement * 1000) / 10,
                        gamesAnalyzed: recentGames.length
                    };
                } catch (error) {
                    console.warn('Error extracting win rate trends:', error);
                    return { trend: 'error', recentWinRate: 0, improvement: 0 };
                }
            }
            
            extractStrategicInsights() {
                try {
                    const insights = [];
                    const winningGames = this.learningDatabase.gameRecords.filter(g => g.won);
                    
                    if (winningGames.length > 0) {
                        const avgMoves = winningGames.reduce((sum, g) => sum + (g.moves || 0), 0) / winningGames.length;
                        insights.push(`Average winning game: ${Math.round(avgMoves)} moves`);
                        
                        const fastWins = winningGames.filter(g => g.moves && g.moves < avgMoves * 0.8).length;
                        if (fastWins > 0) {
                            insights.push(`${fastWins} fast wins (< ${Math.round(avgMoves * 0.8)} moves)`);
                        }
                    }
                    
                    return insights;
                } catch (error) {
                    console.warn('Error extracting strategic insights:', error);
                    return ['Strategic analysis unavailable'];
                }
            }
            
            generateAggregatedStats() {
                return {
                    totalAnalyzedGames: this.learningDatabase.gameRecords.length,
                    overallWinRate: this.learningDatabase.metadata.winRate,
                    averageGameLength: this.calculateAverageGameLength(),
                    difficultyBreakdown: this.analyzeDifficultyDistribution(),
                    adaptiveWeights: this.learningDatabase.adaptiveWeights
                };
            }
            
            calculateAverageGameLength() {
                const allMoves = this.learningDatabase.gameRecords.map(g => g.moves).filter(m => m > 0);
                return allMoves.length > 0 ? allMoves.reduce((sum, moves) => sum + moves, 0) / allMoves.length : 0;
            }
            
            analyzeDifficultyDistribution() {
                const difficulties = this.learningDatabase.gameRecords.reduce((acc, game) => {
                    acc[game.difficulty] = (acc[game.difficulty] || 0) + 1;
                    return acc;
                }, {});
                return difficulties;
            }
            
            setupAutoSave() {
                setInterval(() => {
                    this.saveAllData();
                }, 5 * 60 * 1000);
                
                window.addEventListener('beforeunload', () => {
                    this.saveAllData();
                });
            }
            
            async setupRemoteSync() {
                console.log('🌐 Remote sync capabilities detected - learning data can be exported');
            }
            
            compressGameState(gameState) {
                if (!gameState) return null;
                
                try {
                    return {
                        foundations: gameState.foundations,
                        hiddenCount: gameState.tableau?.reduce((sum, pile) => 
                            sum + pile.filter(c => !c.faceUp).length, 0) || 0,
                        wasteSize: gameState.waste?.length || 0,
                        stockSize: gameState.stock?.length || 0
                    };
                } catch (error) {
                    console.warn('Failed to compress game state:', error);
                    return null;
                }
            }
        }

        // Memory Management System
        class MemoryManager {
            constructor() {
                this.pools = {
                    gameStates: [],
                    moveEvaluations: [],
                    cardObjects: [],
                    analysisResults: [],
                    historicalData: []
                };
                
                this.maxPoolSize = 100;
                this.memoryStats = {
                    allocations: 0,
                    deallocations: 0,
                    poolHits: 0,
                    poolMisses: 0
                };
                
                // Efficient data structures
                this.compactStateCache = new Map(); // LRU cache for game states
                this.patternMap = new Map(); // Efficient pattern storage
                this.moveHistory = new CircularBuffer(1000); // Memory-efficient history
                this.weakObjectMap = new WeakMap(); // Auto-cleanup object associations
                
                this.initializeMemoryMonitoring();
                
                // Prewarm pools for better performance
                setTimeout(() => this.prewarmPools(), 100);
            }
            
            prewarmPools() {
                try {
                    // Pre-create some objects for better cache hit rates
                    for (let i = 0; i < 5; i++) {
                        this.pools.gameStates.push(this.createGameState());
                        this.pools.moveEvaluations.push(this.createMoveEvaluation());
                        this.pools.cardObjects.push({ id: '', suit: '', rank: '', value: 0, faceUp: false });
                    }
                    console.log('🧠 Memory pools prewarmed for better performance');
                } catch (error) {
                    console.warn('Error prewarming memory pools:', error);
                }
            }
            
            // Object Pool Management
            acquireGameState() {
                this.memoryStats.allocations++;
                
                if (this.pools.gameStates.length > 0) {
                    this.memoryStats.poolHits++;
                    const state = this.pools.gameStates.pop();
                    this.resetGameState(state);
                    return state;
                } else {
                    this.memoryStats.poolMisses++;
                    return this.createGameState();
                }
            }
            
            releaseGameState(state) {
                if (this.pools.gameStates.length < this.maxPoolSize) {
                    this.pools.gameStates.push(state);
                }
                this.memoryStats.deallocations++;
            }
            
            acquireMoveEvaluation() {
                this.memoryStats.allocations++;
                
                if (this.pools.moveEvaluations.length > 0) {
                    this.memoryStats.poolHits++;
                    const evaluation = this.pools.moveEvaluations.pop();
                    this.resetMoveEvaluation(evaluation);
                    return evaluation;
                } else {
                    this.memoryStats.poolMisses++;
                    return this.createMoveEvaluation();
                }
            }
            
            releaseMoveEvaluation(evaluation) {
                if (this.pools.moveEvaluations.length < this.maxPoolSize) {
                    this.pools.moveEvaluations.push(evaluation);
                }
                this.memoryStats.deallocations++;
            }
            
            acquireCardObject() {
                this.memoryStats.allocations++;
                
                if (this.pools.cardObjects.length > 0) {
                    this.memoryStats.poolHits++;
                    return this.pools.cardObjects.pop();
                } else {
                    this.memoryStats.poolMisses++;
                    return { id: '', suit: '', rank: '', value: 0, faceUp: false };
                }
            }
            
            releaseCardObject(card) {
                if (this.pools.cardObjects.length < this.maxPoolSize) {
                    this.pools.cardObjects.push(card);
                }
                this.memoryStats.deallocations++;
            }
            
            // Factory methods
            createGameState() {
                return {
                    stock: [],
                    waste: [],
                    tableau: Array.from({ length: 7 }, () => []),
                    foundations: { '♠': [], '♥': [], '♦': [], '♣': [] },
                    gameStats: { moves: 0, time: 0, score: 0 },
                    metadata: new Map() // Efficient metadata storage
                };
            }
            
            createMoveEvaluation() {
                return {
                    move: null,
                    aiScore: 0,
                    confidence: 0,
                    strategicReasoning: [],
                    riskAssessment: { risk: 0, reason: '' },
                    historicalValue: 0,
                    futurePlanning: 0,
                    metadata: new Map()
                };
            }
            
            // Reset methods for object reuse
            resetGameState(state) {
                state.stock.length = 0;
                state.waste.length = 0;
                state.tableau.forEach(pile => pile.length = 0);
                Object.values(state.foundations).forEach(pile => pile.length = 0);
                state.gameStats.moves = 0;
                state.gameStats.time = 0;
                state.gameStats.score = 0;
                state.metadata.clear();
            }
            
            resetMoveEvaluation(evaluation) {
                evaluation.move = null;
                evaluation.aiScore = 0;
                evaluation.confidence = 0;
                evaluation.strategicReasoning.length = 0;
                evaluation.riskAssessment.risk = 0;
                evaluation.riskAssessment.reason = '';
                evaluation.historicalValue = 0;
                evaluation.futurePlanning = 0;
                evaluation.metadata.clear();
            }
            
            // Compact State Representation with error handling
            compressGameState(gameState) {
                try {
                    if (!gameState) {
                        console.warn('Cannot compress null/undefined game state');
                        return new Uint8Array(256); // Return empty buffer
                    }
                    
                    // Create a compact, memory-efficient representation
                    const compressed = new Uint8Array(256); // Fixed-size buffer
                    let offset = 0;
                    
                    // Encode stock count (1 byte)
                    compressed[offset++] = Math.min(255, gameState.stock ? gameState.stock.length : 0);
                    
                    // Encode waste count (1 byte)
                    compressed[offset++] = Math.min(255, gameState.waste ? gameState.waste.length : 0);
                    
                    // Encode tableau state (7 bytes for pile sizes + cards info)
                    for (let i = 0; i < 7; i++) {
                        const pileLength = (gameState.tableau && gameState.tableau[i]) ? gameState.tableau[i].length : 0;
                        compressed[offset++] = Math.min(255, pileLength);
                    }
                    
                    // Encode foundation state (4 bytes)
                    const suits = ['♠', '♥', '♦', '♣'];
                    suits.forEach((suit, i) => {
                        const foundationLength = (gameState.foundations && gameState.foundations[suit]) ? 
                            gameState.foundations[suit].length : 0;
                        compressed[offset + i] = Math.min(255, foundationLength);
                    });
                    offset += 4;
                    
                    // Store game stats in remaining space
                    const view = new DataView(compressed.buffer);
                    const stats = gameState.gameStats || { moves: 0, time: 0, score: 0 };
                    view.setUint32(offset, stats.moves || 0, true);
                    view.setUint32(offset + 4, stats.time || 0, true);
                    view.setInt32(offset + 8, stats.score || 0, true);
                    
                    return compressed;
                } catch (error) {
                    console.warn('Error compressing game state:', error);
                    return new Uint8Array(256); // Return empty buffer on error
                }
            }
            
            decompressGameState(compressed) {
                try {
                    // Validate input
                    if (!compressed) {
                        console.warn('Cannot decompress null/undefined data');
                        return this.acquireGameState();
                    }
                    
                    // Ensure we have a proper Uint8Array
                    let validCompressed;
                    if (compressed instanceof Uint8Array) {
                        validCompressed = compressed;
                    } else if (compressed.buffer && compressed.buffer instanceof ArrayBuffer) {
                        validCompressed = new Uint8Array(compressed.buffer);
                    } else if (Array.isArray(compressed)) {
                        validCompressed = new Uint8Array(compressed);
                    } else {
                        console.warn('Invalid compressed data format, creating default state');
                        return this.acquireGameState();
                    }
                    
                    // Ensure minimum size
                    if (validCompressed.length < 20) {
                        console.warn('Compressed data too small, creating default state');
                        return this.acquireGameState();
                    }
                    
                    const state = this.acquireGameState();
                    let offset = 0;
                    
                    // Decode basic structure (size info only for efficiency)
                    const stockSize = validCompressed[offset++];
                    const wasteSize = validCompressed[offset++];
                    
                    // Skip detailed reconstruction for now - can be expanded as needed
                    offset += 7; // tableau sizes
                    offset += 4; // foundation sizes
                    
                    // Safely create DataView
                    if (validCompressed.buffer && validCompressed.buffer instanceof ArrayBuffer) {
                        const view = new DataView(validCompressed.buffer, validCompressed.byteOffset);
                        state.gameStats.moves = view.getUint32(offset, true);
                        state.gameStats.time = view.getUint32(offset + 4, true);
                        state.gameStats.score = view.getInt32(offset + 8, true);
                    } else {
                        // Fallback for corrupted data
                        state.gameStats.moves = 0;
                        state.gameStats.time = 0;
                        state.gameStats.score = 0;
                    }
                    
                    return state;
                } catch (error) {
                    console.warn('Error decompressing game state:', error);
                    return this.acquireGameState(); // Return default state
                }
            }
            
            // LRU Cache for frequent state lookups
            cacheGameState(key, state) {
                if (this.compactStateCache.size >= 200) {
                    // Remove oldest entry
                    const firstKey = this.compactStateCache.keys().next().value;
                    this.compactStateCache.delete(firstKey);
                }
                
                this.compactStateCache.set(key, this.compressGameState(state));
            }
            
            getCachedGameState(key) {
                if (this.compactStateCache.has(key)) {
                    // Move to end (LRU behavior)
                    const compressed = this.compactStateCache.get(key);
                    this.compactStateCache.delete(key);
                    this.compactStateCache.set(key, compressed);
                    return this.decompressGameState(compressed);
                }
                return null;
            }
            
            // Memory monitoring and cleanup
            initializeMemoryMonitoring() {
                // Monitor memory usage periodically
                setInterval(() => {
                    this.performMemoryCleanup();
                    this.logMemoryStats();
                }, 30000); // Every 30 seconds
            }
            
            performMemoryCleanup() {
                // Limit pool sizes if memory usage is high
                Object.keys(this.pools).forEach(poolName => {
                    const pool = this.pools[poolName];
                    if (pool.length > this.maxPoolSize) {
                        pool.splice(this.maxPoolSize);
                    }
                });
                
                // Clear old cache entries if cache is too large
                if (this.compactStateCache.size > 500) {
                    const entries = Array.from(this.compactStateCache.entries());
                    const keepEntries = entries.slice(-200); // Keep newest 200
                    this.compactStateCache.clear();
                    keepEntries.forEach(([key, value]) => {
                        this.compactStateCache.set(key, value);
                    });
                }
                
                // Trigger garbage collection hint (if available)
                if (window.gc && typeof window.gc === 'function') {
                    window.gc();
                }
            }
            
            logMemoryStats() {
                const stats = this.getMemoryStats();
                console.log(`🧠 Memory Stats: Pool hit rate: ${stats.hitRate}%, Active objects: ${stats.activeObjects}, Cache size: ${stats.cacheSize}`);
            }
            
            getMemoryStats() {
                const totalRequests = this.memoryStats.poolHits + this.memoryStats.poolMisses;
                const hitRate = totalRequests > 0 ? Math.round((this.memoryStats.poolHits / totalRequests) * 100) : 0;
                
                return {
                    hitRate,
                    activeObjects: this.memoryStats.allocations - this.memoryStats.deallocations,
                    cacheSize: this.compactStateCache.size,
                    poolSizes: Object.fromEntries(
                        Object.entries(this.pools).map(([name, pool]) => [name, pool.length])
                    )
                };
            }
            
            // Efficient pattern storage
            storePattern(pattern, outcome) {
                const key = this.hashPattern(pattern);
                if (!this.patternMap.has(key)) {
                    this.patternMap.set(key, {
                        pattern: pattern,
                        outcomes: new Float32Array(10), // Fixed-size array for efficiency
                        count: 0,
                        successRate: 0
                    });
                }
                
                const entry = this.patternMap.get(key);
                const index = entry.count % 10;
                entry.outcomes[index] = outcome ? 1 : 0;
                entry.count++;
                
                // Recalculate success rate efficiently
                let successes = 0;
                const dataLength = Math.min(entry.count, 10);
                for (let i = 0; i < dataLength; i++) {
                    successes += entry.outcomes[i];
                }
                entry.successRate = successes / dataLength;
            }
            
            hashPattern(pattern) {
                // Simple hash function for patterns
                let hash = 0;
                const str = JSON.stringify(pattern);
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(36);
            }
            
            dispose() {
                // Clean up all resources
                Object.values(this.pools).forEach(pool => pool.length = 0);
                this.compactStateCache.clear();
                this.patternMap.clear();
                this.moveHistory.clear();
                console.log('🧠 Memory Manager disposed');
            }
        }
        
        // Circular Buffer for memory-efficient history storage
        class CircularBuffer {
            constructor(capacity) {
                this.capacity = capacity;
                this.buffer = new Array(capacity);
                this.size = 0;
                this.start = 0;
                this.end = 0;
            }
            
            push(item) {
                this.buffer[this.end] = item;
                this.end = (this.end + 1) % this.capacity;
                
                if (this.size < this.capacity) {
                    this.size++;
                } else {
                    this.start = (this.start + 1) % this.capacity;
                }
            }
            
            get(index) {
                if (index >= this.size) return undefined;
                return this.buffer[(this.start + index) % this.capacity];
            }
            
            getLast(count = 1) {
                const result = [];
                for (let i = Math.max(0, this.size - count); i < this.size; i++) {
                    result.push(this.get(i));
                }
                return result;
            }
            
            clear() {
                this.size = 0;
                this.start = 0;
                this.end = 0;
            }
            
            toArray() {
                const result = [];
                for (let i = 0; i < this.size; i++) {
                    result.push(this.get(i));
                }
                return result;
            }
        }

        // Initialize the game with better error handling and memory management
        let game = null;
        
        // Memory cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (game && game.memory) {
                console.log('🧠 Cleaning up memory manager...');
                game.memory.dispose();
            }
            if (game && game.ml) {
                console.log('🧠 Cleaning up ML system...');
                game.ml.dispose();
            }
        });
        
        function safeGameCall(methodPath, ...args) {
            try {
                if (!window.game) {
                    console.error('Game not initialized');
                    return false;
                }
                
                const pathParts = methodPath.split('.');
                let current = window.game;
                
                for (let i = 0; i < pathParts.length - 1; i++) {
                    if (!current[pathParts[i]]) {
                        console.error(`Game component ${pathParts[i]} not ready`);
                        return false;
                    }
                    current = current[pathParts[i]];
                }
                
                const method = current[pathParts[pathParts.length - 1]];
                if (typeof method !== 'function') {
                    console.error(`Method ${methodPath} not found`);
                    return false;
                }
                
                return method.apply(current, args);
            } catch (error) {
                console.error(`Error calling ${methodPath}:`, error);
                return false;
            }
        }
        
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('🔧 SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('❌ SW registration failed: ', registrationError);
                    });
            });
        }

        // ===== VERSION MANAGEMENT =====
        
        const CURRENT_VERSION = "2024.12.19.21.00";
        
        function checkVersion() {
            const lastVersion = localStorage.getItem('klondike_version');
            if (lastVersion !== CURRENT_VERSION) {
                console.log(`🔄 Version update detected: ${lastVersion || 'first-time'} → ${CURRENT_VERSION}`);
                
                // Clear any cached data that might be outdated
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('klondike_') || key.startsWith('solitaire_'))) {
                        if (key !== 'klondike_gameRecords' && key !== 'klondike_learningData') {
                            keysToRemove.push(key);
                        }
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
                
                // Update version
                localStorage.setItem('klondike_version', CURRENT_VERSION);
                
                // Show update notification
                if (lastVersion) {
                    console.log('🎉 Game updated! New features and improvements loaded.');
                    
                    // Show visual update notification
                    setTimeout(() => {
                        const notification = document.createElement('div');
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: linear-gradient(135deg, #10b981, #059669);
                            color: white;
                            padding: 15px 20px;
                            border-radius: 10px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                            z-index: 10000;
                            font-family: Arial, sans-serif;
                            font-size: 14px;
                            max-width: 300px;
                            animation: slideIn 0.5s ease-out;
                        `;
                        notification.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 20px;">🎉</span>
                                <div>
                                    <strong>Game Updated!</strong><br>
                                    <small>New features and improvements loaded</small>
                                </div>
                            </div>
                        `;
                        
                        // Add animation keyframes
                        if (!document.getElementById('update-notification-styles')) {
                            const style = document.createElement('style');
                            style.id = 'update-notification-styles';
                            style.textContent = `
                                @keyframes slideIn {
                                    from { transform: translateX(100%); opacity: 0; }
                                    to { transform: translateX(0); opacity: 1; }
                                }
                                @keyframes slideOut {
                                    from { transform: translateX(0); opacity: 1; }
                                    to { transform: translateX(100%); opacity: 0; }
                                }
                            `;
                            document.head.appendChild(style);
                        }
                        
                        document.body.appendChild(notification);
                        
                        // Auto-remove after 5 seconds
                        setTimeout(() => {
                            notification.style.animation = 'slideOut 0.5s ease-in';
                            setTimeout(() => {
                                if (notification.parentNode) {
                                    notification.parentNode.removeChild(notification);
                                }
                            }, 500);
                        }, 5000);
                    }, 2000);
                }
            }
        }

        function initializeGame() {
            try {
                // Check version first
                checkVersion();
                
                console.log('🎮 Starting game initialization...');
                
                if (typeof KlondikeSolitaire === 'undefined') {
                    throw new Error('KlondikeSolitaire class is not defined');
                }
                
                game = new KlondikeSolitaire();
                window.game = game;
                
                // Load achievements data
                game.achievements.loadAchievements();
                
                // Apply the current theme
                game.ui.applyTheme();
                
                console.log('✅ Klondike Solitaire initialized successfully');
                
                if (game && game.ui && typeof game.ui.showNotification === 'function') {
                    setTimeout(() => {
                        try {
                            game.ui.showNotification('🎮 Game loaded successfully! Click "AI Hint" to test the enhanced hint system.', 'info', 4000);
                        } catch (notifError) {
                            console.error('Notification test failed:', notifError);
                        }
                    }, 1500);
                }
                
            } catch (error) {
                console.error('❌ Failed to initialize game:', error);
                
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #ef4444;
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 400px;
                `;
                errorDiv.innerHTML = `
                    <h3>⚠️ Game Initialization Failed</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #ef4444; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                        🔄 Refresh Page
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }
        
        // Phase 2: Performance Monitor Functions
        let performanceMonitorVisible = false;
        let performanceUpdateInterval = null;

        function togglePerformanceMonitor() {
            const monitor = document.getElementById('performanceMonitor');
            performanceMonitorVisible = !performanceMonitorVisible;
            
            if (performanceMonitorVisible) {
                monitor.style.display = 'block';
                startPerformanceUpdates();
                console.log('📊 Phase 2 Performance Monitor enabled');
            } else {
                monitor.style.display = 'none';
                stopPerformanceUpdates();
                console.log('📊 Performance Monitor disabled');
            }
        }

        function startPerformanceUpdates() {
            if (performanceUpdateInterval) return;
            
            performanceUpdateInterval = setInterval(() => {
                updatePerformanceDisplay();
            }, 1000); // Update every second
        }

        function stopPerformanceUpdates() {
            if (performanceUpdateInterval) {
                clearInterval(performanceUpdateInterval);
                performanceUpdateInterval = null;
            }
        }

        function updatePerformanceDisplay() {
            if (!window.game || !window.game.renderer) return;
            
            const renderer = window.game.renderer;
            const aiWorker = window.game.aiWorkerManager;
            
            // Update FPS
            const fpsElement = document.getElementById('fps-value');
            if (renderer.fps !== undefined) {
                const fps = renderer.fps;
                fpsElement.textContent = fps;
                fpsElement.className = fps >= 55 ? 'performance-value performance-good' : 
                                     fps >= 30 ? 'performance-value performance-warning' : 
                                     'performance-value performance-bad';
            }
            
            // Update Render Time
            const renderTimeElement = document.getElementById('render-time');
            if (renderer.performanceMetrics && renderer.performanceMetrics.renderTime !== undefined) {
                const renderTime = Math.round(renderer.performanceMetrics.renderTime * 10) / 10;
                renderTimeElement.textContent = `${renderTime}ms`;
                renderTimeElement.className = renderTime <= 8 ? 'performance-value performance-good' : 
                                             renderTime <= 16 ? 'performance-value performance-warning' : 
                                             'performance-value performance-bad';
            }
            
            // Update Memory Usage
            const memoryElement = document.getElementById('memory-usage');
            if (performance.memory) {
                const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                memoryElement.textContent = `${memoryMB}MB`;
                memoryElement.className = memoryMB <= 50 ? 'performance-value performance-good' : 
                                         memoryMB <= 100 ? 'performance-value performance-warning' : 
                                         'performance-value performance-bad';
            }
            
            // Update AI Worker Status
            const aiStatusElement = document.getElementById('ai-worker-status');
            if (aiWorker) {
                const status = aiWorker.isInitialized ? 'Ready' : 'Offline';
                aiStatusElement.textContent = status;
                aiStatusElement.className = aiWorker.isInitialized ? 'performance-value performance-good' : 'performance-value performance-bad';
            }
            
            // Update Animation Count
            const animationElement = document.getElementById('animation-count');
            if (renderer.animations !== undefined) {
                const count = renderer.animations.length;
                animationElement.textContent = count;
                animationElement.className = count <= 3 ? 'performance-value performance-good' : 
                                            count <= 6 ? 'performance-value performance-warning' : 
                                            'performance-value performance-bad';
            }
            
            // Update Cache Size
            const cacheElement = document.getElementById('cache-size');
            if (renderer.renderCache !== undefined) {
                const size = renderer.renderCache.size;
                cacheElement.textContent = size;
                cacheElement.className = size <= 50 ? 'performance-value performance-good' : 
                                        size <= 100 ? 'performance-value performance-warning' : 
                                        'performance-value performance-bad';
            }
        }

        if (document.readyState === 'loading') {
            // Global AI Worker Performance Monitor (accessible from console)
            window.monitorAIWorker = async function() {
                if (window.game && window.game.aiWorkerManager) {
                    try {
                        const report = await window.game.aiWorkerManager.getWorkerPerformanceReport();
                        console.log('🤖 AI Worker Performance Report:', report);
                        
                        if (report.metrics) {
                            console.log(`📊 Analysis: ${report.metrics.analysisCount} calls, avg ${report.metrics.averageAnalysisTime?.toFixed(1)}ms`);
                            console.log(`🔍 Path Finding: ${report.metrics.pathFindingCount} calls, avg ${report.metrics.averagePathFindingTime?.toFixed(1)}ms`);
                            console.log(`❌ Errors: ${report.metrics.errorCount}`);
                            console.log(`💾 Cache: ${report.cacheStats.size}/${report.cacheStats.maxSize} (${report.cacheStats.hitRate} hit rate)`);
                            console.log(`🟢 Status: ${report.status}`);
                        }
                        
                        return report;
                    } catch (error) {
                        console.error('Failed to get AI worker performance report:', error);
                        return { error: error.message };
                    }
                } else {
                    console.warn('AI Worker Manager not available');
                    return { error: 'AI Worker Manager not available' };
                }
            };
            
            window.optimizeAIWorker = async function() {
                if (window.game && window.game.aiWorkerManager) {
                    try {
                        const result = await window.game.aiWorkerManager.optimizeWorkerPerformance();
                        console.log('🔧 AI Worker Optimization Result:', result);
                        return result;
                    } catch (error) {
                        console.error('Failed to optimize AI worker:', error);
                        return { error: error.message };
                    }
                } else {
                    console.warn('AI Worker Manager not available');
                    return { error: 'AI Worker Manager not available' };
                }
            };

            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
        
        function debugRender() {
            console.log('🔍 Debug Render called');
            console.log('Game object:', window.game);
            console.log('Renderer:', window.game?.renderer);
            console.log('Canvas:', document.getElementById('gameCanvas'));
            
            if (window.game && window.game.renderer) {
                console.log('Forcing render...');
                window.game.renderer.render();
            } else {
                console.log('Game or renderer not available');
            }
        }
    </script>
</body>
</html>